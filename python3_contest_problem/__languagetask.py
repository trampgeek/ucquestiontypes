"""The generic LanguageTask, subclasses of which manage compiling and executing
   code in a particular language.
"""
from datetime import datetime

WATCHDOG_FREEBOARD = 1

class CompileError(Exception):
    def __init__(self, error_message):
        Exception.__init__(self, error_message)


class RunError(Exception):
    def __init__(self, error_message=''):
        Exception.__init__(self, error_message)

class LanguageTask:
    def __init__(self, params, code=None):
        """Initialise the object, recording the parameters that will control compilation and
           running plus the code if supplied. Code may be alternatively be supplied later by
           calls to set_code.
           self.params is the dictionary of template & global parameters - language specific.
        """
        self.params = params
        self.code = code
        self.executable_built = False
        self.compile_error_message = None
        self.error_message_offset = 0
        self.stderr = ''
        self.stdout = ''
        self.start_time = datetime.now()
        self.timed_out = False
        if 'totaltimeout' not in params:
            self.params['totaltimeout'] = 30 # Secs

    def seconds_remaining(self):
        """The number of seconds of execution time remaining before the watchdog timer goes off.
           The watchdog timer goes off 1 second before runguard kills the job (as determined by the 'timeout' parameter).
        """
        t_elapsed = (datetime.now() - self.start_time).total_seconds()
        return self.params['totaltimeout'] - t_elapsed - WATCHDOG_FREEBOARD

    def set_code(self, code, error_message_offset=0):
        """Set the code to be used for subsequent compiling and running. The optional error_message_offset
           is a number to be subtracted from any error messages generated by compile and run_code calls.
           Exactly how (or even 'if') it is used is language dependent.
        """
        self.code = code
        self.error_message_offset = error_message_offset

    def compile(self, make_executable=False):
        """Compile the currently set code, either to an object file or
           to an executable file depending on the given make_executable parameter.
           Adjust any error message by subtracting error_message_offset.
           Raise CompileError if the code does not
           compile, with the compilation error message within the exception
           and also recorded in self.compile_error_message.
           No return value.
        """
        raise NotImplementedError("compile not implemented by concrete class")

    def discard_executable(self):
        """Called if something breaks in the executable and it will need rebuilding
           (with different source, presumably)
        """
        self.executable_built = False

    def run_code(self, standard_input=None, bash_command=None):
        """Run the code in the executable program that a call to compile is assumed
           to have created, using the given standard input.
           If a bash_command is supplied it used as given.
           Otherwise the command to be executed is the compiled executable.
           Returns a tuple of the output from the
           run and a stderr (or a derivative thereof) string. Those two values
           are also recorded in self.stdout and self.stderr respectively.
        """
        raise NotImplementedError("run_code not implemented by concrete class")