<?xml version="1.0" encoding="UTF-8"?>
<quiz>
<!-- question: 19361  -->
  <question type="coderunner">
    <name>
      <text>UOC_PROTOTYPE_python3_stage1</text>
    </name>
    <questiontext format="html">
      <text><![CDATA[<p><span style="font-size: 0.9375rem;">Prototype for a COSC121 Python3 question that is checked by pylint before being executed. Other style checks are also implemented.</span></p><p><span style="font-size: 0.9375rem;"></span></p><p>It can take the following template parameters.</p><ul><li><p><strong>abortonerror</strong>: true to abort testing when a runtime error occurs. Default: true</p></li><li><p><strong>allowglobals</strong>: set this to true to allow global variables (i.e. to allow lowercase globals, not just "constants"). Default: false.</p></li><li><p><strong>allownestedfunctions</strong>: set this to true to allow functions to be declared with a non-global scope. Default: false.</p></li><li><p></p><div><div><strong>banglobalcode</strong>: If true, no global assignment (except global constants), for, while and if constructs are allowed. Default: true</div></div><p></p></li><li><p><strong>checktemplateparams</strong>: set this false to bypass the usual check for validity of template params (e.g. when doing randomisation, although prefixing the extra template params with '_' is preferred).</p></li><li><strong>dpi</strong>. The dots-per-inch value to use for any matplotlib images. Default value: 65<br></li></ul><ul><li><p><strong>echostandardinput</strong>. If false, the standard builtin Python&nbsp;<em>input</em>&nbsp;function will be used. Otherwise, it will be replaced with a version that echoes the prompt to standard output to mimic the behaviour observed when standard input comes from the keyboard. Default: True<br></p></li><li><p><strong>extra:&nbsp;</strong>should be a string, one of "", "pretest" or "posttest". If set and not empty, the TEST.extra field is inserted into the program before or after TEST.testcode for the values "pretest" and "posttest" respectively. Default: ""</p></li><li><p><strong>floattolerance</strong>: a floating point number which, if defined and non-None, changes the test for correct output as follows. The&nbsp;<em>expected</em>&nbsp;and&nbsp;<em>got</em>&nbsp;outputs are both right-stripped then broken into lines. If the number of lines don't match, the answer is deemed wrong. Then (after compressing white space to a single character if&nbsp;<em>strictwhitespace</em>&nbsp;is false) the&nbsp;<em>got</em>&nbsp;and&nbsp;<em>expected</em>&nbsp;outputs are compared line for line. Each line is split by a regular expression pattern that matches any floating point number or integer and the two lines are compared token by token. If both tokens are numbers they must be equal to within&nbsp;&nbsp;<em>floattolerance</em>. The actual test is abs(float(f1) - float(f2) &lt;= floattolerance * 1.0001. The factor of 1.0001 is to allow for floating point error in the case where two decimal numbers that appear to satisfy the criterion, such as 0.65 and 0.65 with a float tolerance of 0.01, actually don't quite. If&nbsp;<em>floattolerance</em>&nbsp;is 0.0 the effect is to treat ints as floats, e.g.&nbsp; 1 and 1.0 will be deemed equal. Default: None<br></p></li><li><p><strong>forcepylint</strong>: if true, run the precheckers (pylint and/or mypy) regardless of whether or not the local checks found errors. Default: false.</p></li><li><p><strong>globalextra</strong>: should be a string, one of "", "pretest" or "posttest". If set and not empty, the QUESTION.globalextra field is inserted into the program before or after TEST.testcode for the values "pretest" and "posttest" respectively. If TEST.extra and QUESTION.globalextra are both being inserted before the test or both are being inserted after the test, the globalextra precedes the TEST.extra. Default: ""</p></li></ul><ul><li><p><strong>imagewidth</strong>: if this is given it sets the width in pixels of any matplotlib images inserted into the result table. Height is automatically scaled to match. Otherwise the image is inserted unscaled. Ignored unless&nbsp;<em>usesmatplotlib</em>&nbsp;is true. Default: None.</p></li><li><p><strong>imports</strong>: this is a list of python import strings. Each string is either just a python module name or a full python import string. If just&nbsp;<em>name</em>&nbsp;is given, the import statement is simply "import name", otherwise the import string is used as given. For example:</p><pre>{ "imports": ["math", "from blah import thing as twaddle"] }</pre><p>Imports go at the very start of the generated program. This mechanism can be used to import test support functions, too, and is preferred over the use of a&nbsp;<tt>_prefix.py</tt>&nbsp;file.</p></li><li><p><strong>isfunction</strong>: unless this is explicitly set to false, or the student's code already begins with a docstring, a dummy module docstring will be inserted at the start of the program<strong>.</strong>&nbsp; Also, if&nbsp;<em>isfunction</em>&nbsp;is true, the supplied code will be run stand-alone to check if it generates any output and an error message will be generated if it does.&nbsp;Thus, if your question is of the "write a program" variety, you should&nbsp;set this to false. Otherwise omit it. Default: true.</p></li><li><p><strong>localprechecks</strong>: if true, run the local prechecks for things like global code, required/proscribed functions and constructs, unexpected output. If local prechecks give any errors, the precheckers (pylint, mypy) will not be run unless&nbsp;<em>forcepylint&nbsp;</em>is true. Default: true.</p></li><li><p><strong>maxfunctionlength</strong>: this is the maximum number of statements that a function body can contain. Statements within statements are counted. Blank lines and comments aren't statements.&nbsp;&nbsp;This is a more-reliable alternative to the pylint max-statements parameter, which behaves strangely at times.&nbsp;</p></li><li><p><strong>maxnumconstants</strong>: the maximum number of constants (i.e. uppercase globals) allowed. An integer, defaulting to 4.</p></li><li><p><strong>maxoutputbytes</strong>: the maximum allowed number of output bytes. Default 10000.<br></p></li><li><p><strong>maxstringlength:&nbsp;</strong>the maximum allowed length of the output string or error string in the result table. Strings longer than this have their inner content snipped out. An integer defaulting to 2000.</p></li><li><p><strong>norun</strong>: if set to true, the normal execution of the student's code will not take place. Any test code provided will however still be run.</p></li><li><p><strong>nostylechecks</strong>: true to suppress all normal style checking, including the checkers listed in "precheckers". Default: false</p></li><li><p><strong>notest</strong>: if present and set to true, the test code will not be inserted into the code to be executed. Its role is then just as documentation for the student (as it still appears in the result table).</p></li><li><p><strong>parsonsproblemthreshold:&nbsp;</strong>if a wrong answer is submitted and the number of submissions (Checks) is greater than or equal to this value (parsonsproblemthreshold) the student is presented with a link that, if clicked, will expose the author's answer with all indentation removed and the order scrambled.</p></li><li><p><strong>precheckers</strong>: a list of the names of programs to be run when prechecking the correctness of the code. Currently only "pylint" and "mypy" are supported. These prechecks do not run if local checks give an error unless&nbsp;<em>forcepylint&nbsp;</em>is true. Default: ["pylint"].<br></p></li><li><p><strong>prelude</strong>: a possibly multi-line string that is inserted into the file&nbsp;after any imports and other template-generated code but before the student answer (and before the _prefix.py file, if supplied).</p></li><li><p><strong>proscribedbuiltins</strong>: this is a list of the Python built-in functions that cannot be used. Default: ["exec", "eval"].</p></li><li><p><strong>proscribedconstructs</strong>: this is a list of Python constructs (if, while, def, slice, listcomprehension, etc) that<em>&nbsp;must not</em>&nbsp;appear in the student's program.</p></li><li><p><strong>proscribedfunctions</strong>: this is a list of functions (sum, product, etc) that&nbsp;<em>must not</em>&nbsp;appear in the student's program. Default: []</p></li><li><p><strong>proscribedsubstrings</strong>: this is a list of strings that&nbsp;<em>must not</em>&nbsp;appear anywhere in the student's program (even in comments). Default: []</p></li><li><strong>pylintoptions</strong>. A list of strings to be added to the default list of options to pylint (relevant only if "pylint" is specified as one of the precheckers).&nbsp;For example, the Template parameters string in the question authoring form might be set to<pre>{"isfunction": false, "pylintoptions":["--max-statements=20","--max-args=3"]}</pre>to suppress the insertion of a dummy module docstring at the start and to set the maximum number of statements and arguments for each function to 20 and 3 respectively. Default options:<p></p><ul><li>"--disable=C0303,C0325,C0330,R0903,R0915,star-args,unbalanced-tuple-unpacking,consider-using-enumerate,simplifiable-if-statement,consider-iterating-dictionary,trailing-newlines"</li><li>"--enable=C0326"</li><li>"--good-names=i,j,k,n,s,c,_"<br></li></ul></li><li><p><strong>requiredconstructs</strong>:&nbsp;this is a list of Python constructs (if, while, def, etc) that<strong>&nbsp;must&nbsp;</strong>appear in the student's program. Default: []</p></li><li><p><strong>requiredfunctiondefinitions</strong>: this is a list of the names of the functions that must be defined within the student's program. Default: []</p></li><li><p><strong>requiredfunctioncalls</strong>: this is a list of the names of functions that must be explicitly called within the student's code</p></li><li><p><strong>requiredsubstrings</strong>: this is either a list of strings that&nbsp;<strong>must</strong>&nbsp;appear somewhere in the students code. Or a list of json objects with the keys "string", "pattern" and "errormessage". Only one of "string" or "pattern" should be supplies. "String" corresponds to a string that must appear in the students code and "pattern" corresponds to a python regular expression that must match somewhere in the students code. "errormessage" is the feedback that will be given to students when they fail this on precheck.<br></p></li><li><p><strong>requiretypehints</strong>: if&nbsp;<em>True</em>&nbsp;all functions must have type hints for all parameters and the return type. Default: False<br></p></li><li><p><strong>restrictedfiles</strong>: this specifies which files the students program is allowed to open. It is dictionary with two optional keys 'onlyallow' and 'disallow'. Each of these should map to a list of files that are allowed to be opened and filenames that are not allowed to be opened. The filenames in the lists can be a regex.<br>Default:</p><pre>{"disallow": ["__.*", "prog.*", "pytester.py"]</pre><p></p></li><li><p><strong>restrictedmodules</strong>: A dictionary that specifies what modules are to be restricted. Keys are the names of modules and the values are a dictionary with two keys 'onlyallow' and 'disallow'. Each of these is a list of the names of objects within the module which are allowed or disallowed. The names of objects in these lists can be a regex.&nbsp; This is a runtime check only, not part of style checker.<br>Default:</p><pre> "restrictedmodules": {
    "builtins": {"onlyallow": []},
    "imp": {"onlyallow": []},
    "importlib": {"onlyallow": []},
    "os": {"disallow": ["system", "_exit", "_.*"]},
    "subprocess": {"onlyallow": []},
    "sys": {"onlyallow": []},
}</pre><p></p></li><li><p><strong>runextra</strong>: if set (to any value) the Extra Template Data is added to the program as test code&nbsp;<em>before</em>&nbsp;the usual testcode. [Deprecated: use the&nbsp;<em>extra</em>&nbsp;parameter instead.]</p></li><li><strong>showfeedbackwhenright</strong>:<strong>&nbsp;</strong>If true then if a student provides a valid solution then the student is presented with an option to see the question authors solution.<br>Default: false<br></li><li><p><strong>strictwhitespace</strong>: by default when checking correctness trailing blank lines and trailing white space on each line are ignored but otherwise white space must match exactly. If this parameter is set to false, white space within a line may vary, i.e., multiple spaces are treated as 1 space. Default: true</p></li><li><p><strong>stripmain</strong>: if set to true, the program is expected to contain a global invocation of the main function, which is a line starting "main()". That line is deleted from the program. If the line is not present a "Missing call to main" exception is raised.</p></li><li><p><strong>stripmainifpresent</strong>: if set to true and the program contains a global invocation of a main function, which is a line starting "main()", that line is deleted from the program. Otherwise nothing happens (cf stripmain).</p></li><li><p><strong>suppresspassiveoutput</strong>: if set to true, any output generated by the student code even without any CodeRunner tests being run is ignored. This can be used, for example, to ignore output from any test code the student has included&nbsp;<em>and/or</em>&nbsp;to ignore the main output from a "write a program question". Only the output generated by CodeRunner tests will be displayed and marked. Default: false.</p></li><li><p><strong>timeout</strong>: number of seconds allowed for each test case. Default: 5 secs. Be careful to ensure that the total time for all test cases can not exceed&nbsp;<strong>totaltimeout</strong>, particularly if&nbsp;<em>abortonerror</em>&nbsp;is false.</p></li><li><p><strong>totaltimeout</strong>: total number of seconds allowed for the whole run. Cannot exceed the maximum allowed by Jobe, which is 50 seconds (and which is the default value for this parameter).</p></li><li><p><strong>useanswerfortests</strong>: if true, a run with the sample answer precedes the run with the student answer and the results from the sample answer are used for correctness testing&nbsp;<em>but only if no expected output is supplied</em>. However, because this takes place at runtime, this doesn't work for "Use as example" tests, for which the expected output must be supplied by the question author.</p></li><li><p><strong>usesmatplotlib:&nbsp;</strong>if true, header text is inserted at the start of the program to switch matlab graph output to use the non-interactive 'Agg' backend, which writes images to disk an .PNGs. After each test, the current state of the pyplot figure is saved to a new file. When all tests have been run and graded, the set of image files is inserted row-by-row into the result table with each figure below any text in the cell. For this to work correctly at least the first test must create a figure. The image is not graded - it is provided only for reference, so usually the test code will need to extract and display attributes of the current figure independently. See also the template parameters&nbsp;<em>useanswerfortests</em>, which results in the expected images being inserted into the table too and&nbsp;<em>imagewidth&nbsp;</em>which sets the width (and hence height by uniform scaling) to a desired number of pixels. Note that if&nbsp;<em>usesmatplotlib</em>&nbsp;is selected, most of the pylint options relating to imports (ordering, reimporting, positioning etc) are disabled. Also, you may need to increase the timeout value for the question.<br><br>Also, if&nbsp;<em>usesmatplotlib</em>&nbsp;is true, a function&nbsp;&nbsp;<em>print_plot_info(data_type)</em>&nbsp;is made available for use in the test code or post-test extra. This prints various properties of the current plot for grading purposes.&nbsp;<em>data_type</em>&nbsp;should be one of 'points', 'lines' or 'bars'. There are lots of additional parameters to control the output. See the separate section below for details.<br><br>Default (for usesmatplotlib): false.&nbsp;</p></li><li><p><strong>usesnumpy:&nbsp;</strong>if true, the line&nbsp;<em>import numpy as np</em>&nbsp;is inserted at the start of the program, and the usual check for unused imports is turned off. Additionally, since&nbsp;<em>numpy&nbsp;</em>is used in a mathematical context where it is hard to define what variables name might be legitimate, the checking for valid names by pylint is disabled.</p></li><li><p><strong>warnifpassiveoutput</strong>: if set to true and&nbsp;<em>isfunction</em>&nbsp;is also true, generate a style error&nbsp;if the student's code seems to produce output even without any CodeRunner tests being executed. This is probably the result of the student pasting test code as well as requested function(s) into their answer. Default: true</p></li></ul><p>Also, if a file named '_prefix.py' appears in the working directory (i.e. has been attached to the question), the code in that file is inserted into the executable program after any imports and other template-generated code but before the student answer.
    However, the use of an explicit import statement is preferred.</p><p><span style="font-size: 1.40625rem;">The&nbsp;</span><em style="font-size: 1.40625rem;">print_plot_info</em><span style="font-size: 1.40625rem;">&nbsp;function</span><br></p><p>In addition to the mandatory positional parameter&nbsp;<em>data_type</em>, which must be one of&nbsp;<code>points</code>,&nbsp;<code>lines</code>, or&nbsp;<code>bars</code>, the function can take a range of keyword parameters, as defined by the following Python dictionary of default values:</p><pre>DEFAULT_PARAMS = {
    'x_samples': None,        # A list of x-values at which y values should be interpolated.
    'bar_indices': None,      # A list of the 0-origin bar indices to report on. None for all bars.
    'show_xlim': False,       # True to display the x-axis limits
    'show_ylim': False,       # True to display the y-axis limits
    'show_colour': False,     # True to report line/marker colour
    'show_xticklabels': None,  # True to display x-tick labels (defaults True for bars, False otherwise)
    'show_yticklabels': False,  # True to display y-tick labels
    'show_xticks': False,     # True to display x-tick numeric values
    'show_yticks': False,     # True to display y-tick numeric values
    'show_barx': True,        # True to print the x-coordinates of all bars
    'show_linelabels': None,  # True to show line labels, default is True if there's a legend else False
    'sort_points': False,     # True to sort data by x then y.
    'first_num_points': 5,    # Number of points to print at the start of the point list.
    'last_num_points': 5,     # Number of points to print at the end of the point list.
    'float_precision': (1, 1),  # Num digits to display after decimal point for x and y values resp
    'max_label_length': 60,   # Use multiline display if tick label string length exceeds this
    'lines_to_print': None,   # If non-None, a list of indices of lines to print (0 is first line).
    'line_info_only': False,  # True to suppress all except the line/bar/points info
}</pre><br><p></p>]]></text>
    </questiontext>
    <generalfeedback format="html">
      <text></text>
    </generalfeedback>
    <defaultgrade>1</defaultgrade>
    <penalty>0</penalty>
    <hidden>0</hidden>
    <idnumber></idnumber>
    <coderunnertype>python3_stage1</coderunnertype>
    <prototypetype>2</prototypetype>
    <allornothing>1</allornothing>
    <penaltyregime>0, 10, 20, ...</penaltyregime>
    <precheck>1</precheck>
    <hidecheck>0</hidecheck>
    <showsource>0</showsource>
    <answerboxlines>60</answerboxlines>
    <answerboxcolumns>100</answerboxcolumns>
    <answerpreload></answerpreload>
    <globalextra></globalextra>
    <useace>1</useace>
    <resultcolumns></resultcolumns>
    <template><![CDATA[import locale
import json
import os
import re
import html
import random

from pytester import PyTester

STANDARD_PYLINT_OPTIONS = ['--disable=trailing-whitespace,superfluous-parens,' +
                      'bad-continuation,min-public-methods,too-few-public-methods,star-args,' +
                      'unbalanced-tuple-unpacking,too-many-statements,' +
                      'consider-using-enumerate,simplifiable-if-statement,' +
                      'consider-iterating-dictionary,trailing-newlines,no-else-return,' +
                      'consider-using-dict-comprehension,unnecessary-lambda,' +
                      'len-as-condition,inconsistent-return-statements,consider-using-join,' +
                      'singleton-comparison,unused-variable,chained-comparison,no-else-break,' +
	                  'consider-using-in,useless-object-inheritance,unnecessary-pass,' +
	                  'reimported,wrong-import-order,wrong-import-position,ungrouped-imports,' +
                      'consider-using-set-comprehension,no-else-raise,duplicate-string-formatting-argument,' + 
                      'consider-using-f-string,unspecified-encoding,' +
                      'consider-using-dict-items,use-a-generator,' +
                      'consider-using-max-builtin,unnecessary-lambda,consider-using-with,' +
                      'consider-using-f-string,use-dict-literal',
                      '--enable=C0326',
                      '--good-names=i,j,k,n,s,c,_'
                      ]

locale.setlocale(locale.LC_ALL, 'C.UTF-8')

KNOWN_PARAMS = {
    'abortonerror': True,
    'allowglobals': False,
    'banglobalcode': True,
    'allownestedfunctions': False,
    'checktemplateparams': True,
    'dpi': 65,
    'echostandardinput': True,
    'extra': 'None',
    'floattolerance': None,
    'forcepylint': False,
    'globalextra': 'None',
    'imagewidth': None,
    'imports': [],
    'isfunction': True,
    'localprechecks': True,
    'maxfunctionlength': 30,
    'maxnumconstants': 4,
    'maxoutputbytes': 10000,
    'maxstringlength': 2000,
    'norun': False,
    'nostylechecks': False,
    'notest': False,
    'parsonsproblemthreshold': None, # The number of checks before parsons' problem displayed
    'precheckers': ['pylint'],
    'prelude': '',
    'proscribedbuiltins': ['exec', 'eval'],
    'proscribedfunctions': [],
    'proscribedconstructs': ["goto"],
    'proscribedsubstrings': [],
    'pylintoptions': [],
    'requiredconstructs': [],
    'requiredfunctiondefinitions': [],
    'requiredfunctioncalls': [],
    'requiredsubstrings': [],
    'requiretypehints': False,
    'restrictedfiles': {
        'disallow': ['__.*', 'prog.*', 'pytester.py'],
    },
    'restrictedmodules': {
        'builtins': {
            'onlyallow': []
        },
        'imp': {
            'onlyallow': []  
        },
        'importlib': {
            'onlyallow': []  
        },
        'os': {
            'disallow': ['system', '_exit', '_.*']
        },
        'subprocess': {
            'onlyallow': []
        },
        'sys': {
            'disallow': ['_.*']
        },
    },
    'runextra': False,
    'showfeedbackwhenright': False,
    'stdinfromextra': False,
    'strictwhitespace': True,
    'stripmain': False,
    'stripmainifpresent': False,
    'testisbash': False,
    'timeout': 5,
    'totaltimeout': 50,
    'suppresspassiveoutput': False,
    'useanswerfortests': False,
    'usesmatplotlib': False,
    'usesnumpy': False,
    'usesubprocess': False,
    'warnifpassiveoutput': True,
}

class TestCase:
    def __init__(self, dict_rep):
        """Construct a testcase from a dictionary representation obtained via JSON"""
        self.testcode = dict_rep['testcode']
        self.stdin = dict_rep['stdin']
        self.expected = dict_rep['expected']
        self.extra = dict_rep['extra']
        self.display = dict_rep['display']
        try:
            self.testtype = int(dict_rep['testtype'])
        except:
            self.testtype = 0
        self.hiderestiffail = bool(int(dict_rep['hiderestiffail']))
        self.useasexample = bool(int(dict_rep['useasexample']))
        self.mark = float(dict_rep['mark'])


# ================= CODE TO DO ALL TWIG PARAMETER PROCESSING ===================

def process_template_params():
    """Extract the template params into a global dictionary PARAMS"""
    global PARAMS
    PARAMS = json.loads("""{{ QUESTION.parameters | json_encode | e('py') }}""")
    checktemplateparams = PARAMS.get('checktemplateparams', True)
    if checktemplateparams:
        unknown_params = set(PARAMS.keys()) - set(KNOWN_PARAMS.keys())
        filtered_params = [param for param in unknown_params if not param.startswith('_')]
        if filtered_params:
            print("Unexpected template parameter(s):", list(sorted(filtered_params)))

    for param_name, default in KNOWN_PARAMS.items():
        if param_name in PARAMS:
            param = PARAMS[param_name]
            if type(param) != type(default) and default is not None:
                print("Template parameter {} has wrong type (expected {})".format(param_name, type(default)))
        else:
            PARAMS[param_name] = default;

    if PARAMS['extra'] == 'stdin':
        PARAMS['stdinfromextra'] = True
    if PARAMS['runextra']:
        PARAMS['extra'] = 'pretest'  # Legacy support
    if PARAMS['timeout'] < 2:
        PARAMS['timeout'] = 2  # Allow 1 extra second freeboard 
    PARAMS['pylintoptions'] = STANDARD_PYLINT_OPTIONS + PARAMS['pylintoptions']
    if PARAMS['allowglobals']:
        PARAMS['pylintoptions'].append("--const-rgx='[a-zA-Z_][a-zA-Z0-9_]{2,30}$'")
    if PARAMS['usesmatplotlib']:
        PARAMS['pylintoptions'].append("--disable=reimported,wrong-import-position,wrong-import-order,unused-import")
    if PARAMS['testisbash']:
        print("testisbash is not implemented for Python")


def get_test_cases():
    """Return an array of Test objects from the template parameter TESTCASES"""
    test_cases = [TestCase(test) for test in json.loads("""{{ TESTCASES | json_encode | e('py') }}""")]
    return test_cases


def scrambled(answer):
    """Return a randomly reordered version of the given answer"""
    if answer.strip() == '':
        return ''
    docstrings = re.findall(r'""".*?"""', answer) + re.findall(r"'''.*?'''", answer)
    rest = re.sub(r'""".*?"""', '', answer)
    rest2 = re.sub(r"'''.*?'''", '', rest)
    lines = [line.strip() for line in (rest2.splitlines() + docstrings) if line.strip()]
    original = lines[:]
    while len(lines) > 1 and original == lines: # Make sure the order changes!
        random.shuffle(lines)
    return '\n'.join(lines)
    

def process_global_params():
    """Plug into the PARAMS variable all the "global" parameters from
       the question and its answer (as distinct from the template parameters).
    """
    PARAMS['STUDENT_ANSWER'] = """{{ STUDENT_ANSWER | e('py') }}""".strip() + '\n'
    PARAMS['SEPARATOR'] = "#<ab@17943918#@>#"
    PARAMS['IS_PRECHECK'] = "{{ IS_PRECHECK }}" == "1"
    PARAMS['QUESTION_PRECHECK'] = {{ QUESTION.precheck }} # Type of precheck: 0 = None, 1 = Empty etc
    PARAMS['ALL_OR_NOTHING'] = "{{ QUESTION.allornothing }}" == "1" # Whether or not all-or-nothing grading is being used
    PARAMS['GLOBAL_EXTRA'] = """{{ QUESTION.globalextra | e('py') }}\n"""
    PARAMS['STEP_INFO'] = json.loads("""{{ QUESTION.stepinfo | json_encode }}""")
    answer = """{{QUESTION.answer | e('py')}}""".strip()
    if answer:
        if PARAMS['STUDENT_ANSWER'].strip() == answer.strip():
            PARAMS['AUTHOR_ANSWER'] = "<p>Your answer is an <i>exact</i> match with the author's solution.</p>"
        else:
            with open("__author_solution.html") as file:
                PARAMS['AUTHOR_ANSWER'] = (file.read().strip() % html.escape(answer))
        with open("__author_solution_scrambled.html") as file:
            PARAMS['AUTHOR_ANSWER_SCRAMBLED'] = (file.read().strip() % html.escape(scrambled(answer))) + "\n"
    else:
        PARAMS['AUTHOR_ANSWER'] = PARAMS['AUTHOR_ANSWER_SCRAMBLED'] = ''


def update_test_cases(test_cases, outcome):
    """Return the updated testcases after replacing all empty expected fields with those from the
       given outcome's test_results which must have a column header 'Got'. Non-empty existing expected
       fields are left unchanged.
       If any errors occur, the return value will be None and the outcome parameter will have had its prologuehtml
       value updated to include an error message.
    """
    try:
        results = outcome['testresults']
        col_num = results[0].index('Got')
        for i in range(len(test_cases)):
            if test_cases[i].expected.strip() == '':
                test_cases[i].expected = results[i + 1][col_num]
    except ValueError:
        outcome['prologuehtml'] = "No 'Got' column in result table from which to get testcase expecteds"
        test_cases = None
    except Exception as e:
        outcome['prologuehtml'] = "Unexpected error ({}) extracting testcase expecteds from sample answer output".format(e)
        test_cases = None
    return test_cases


def get_expecteds_from_answer(params, test_cases):
    """Run all tests using the sample answer rather than the student answer.
       Fill in the expected field of each test case using the sample answer and return
       the updated test case list.
       Return None if the sample answer gave any sort of runtime error
    """
    new_params = {key: value for key, value in params.items()}
    new_params['IS_PRECHECK'] = False
    new_params['nostylechecks'] = True
    new_params['STUDENT_ANSWER'] = """{{ QUESTION.answer | e('py') }}"""
    new_params['running_sample_answer'] = True
    tester = PyTester(new_params, test_cases)
    outcome = tester.test_code()
    if 'prologuehtml' in outcome:
        outcome['prologuehtml'] = "<h2>ERROR IN QUESTION'S SAMPLE ANSWER. PLEASE REPORT</h2>\n" + outcome['prologuehtml']
        return outcome, None
    else:
        return outcome, update_test_cases(test_cases, outcome)


process_template_params()
test_cases = get_test_cases()
process_global_params()

if PARAMS['useanswerfortests']:
    outcome, test_cases = get_expecteds_from_answer(PARAMS, test_cases)

if test_cases:
    tester = PyTester(PARAMS, test_cases)
    outcome = tester.test_code()
    feedback = ''
    parsons_threshold = float('inf') if PARAMS['parsonsproblemthreshold'] is None else PARAMS['parsonsproblemthreshold']
    if outcome['fraction'] != 1 and not PARAMS['IS_PRECHECK'] and PARAMS['STEP_INFO']['numchecks'] + 1 >= parsons_threshold:
        feedback = PARAMS['AUTHOR_ANSWER_SCRAMBLED']
    elif outcome['fraction'] == 1 and PARAMS['showfeedbackwhenright'] and not (PARAMS['IS_PRECHECK']):
        feedback = PARAMS['AUTHOR_ANSWER']
    if feedback:
        if 'epiloguehtml' in outcome:
            if outcome['epiloguehtml'].strip():
                outcome['epiloguehtml'] += '<br>'
        else:
            outcome['epiloguehtml'] = ''
        outcome['epiloguehtml'] += f'<div style="background-color: #f4f4f4">{feedback}</div>'
print(json.dumps(outcome))
]]></template>
    <iscombinatortemplate>1</iscombinatortemplate>
    <allowmultiplestdins>1</allowmultiplestdins>
    <answer></answer>
    <validateonsave>1</validateonsave>
    <testsplitterre><![CDATA[|#<ab@17943918#@>#\n|ms]]></testsplitterre>
    <language>python3</language>
    <acelang></acelang>
    <sandbox>jobesandbox</sandbox>
    <grader>TemplateGrader</grader>
    <cputimelimitsecs>50</cputimelimitsecs>
    <memlimitmb>1500</memlimitmb>
    <sandboxparams></sandboxparams>
    <templateparams></templateparams>
    <hoisttemplateparams>0</hoisttemplateparams>
    <templateparamslang>twig</templateparamslang>
    <templateparamsevalpertry>0</templateparamsevalpertry>
    <templateparamsevald>{}</templateparamsevald>
    <twigall>0</twigall>
    <uiplugin>ace</uiplugin>
    <uiparameters></uiparameters>
    <attachments>0</attachments>
    <attachmentsrequired>0</attachmentsrequired>
    <maxfilesize>10240</maxfilesize>
    <filenamesregex></filenamesregex>
    <filenamesexplain></filenamesexplain>
    <displayfeedback>1</displayfeedback>
    <giveupallowed>0</giveupallowed>
    <prototypeextra></prototypeextra>
    <testcases>
<file name="__author_solution_scrambled.html" path="/" encoding="base64">PGRpdiBjbGFzcz0iY29kZXJ1bm5lci10ZXN0LXJlc3VsdHMgYmFkIj4KICAgIDxhIGNsYXNzPSJidG4gYnRuLWxpbmsgY29kZXJ1bm5lci1zY3JhbWJsZWQtc29sdXRpb24tbGluayIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6I0ZDQyI+U2hvdyBzY3JhbWJsZWQgYXV0aG9yJ3Mgc29sdXRpb248L2E+CjwvZGl2Pgo8ZGl2IGNsYXNzPSJjb2RlcnVubmVyLXNjcmFtYmxlZC1hdXRob3JzLXNvbHV0aW9uIGNvbGxhcHNlIiBleHBhbmRlZD0iZmFsc2UiIHN0eWxlPSJtYXJnaW4tYm90dG9tOjhweCI+CiAgICA8cHJlIGNsYXNzPSJjb2RlLWhpZ2hsaWdodCI+JXM8L3ByZT4KPC9kaXY+CjxzY3JpcHQ+CiAgICB3aW5kb3cuY29kZXJ1bm5lcl9zb2x1dGlvbl9saW5rX2NsaWNrZWQgPSB3aW5kb3cuY29kZXJ1bm5lcl9zb2x1dGlvbl9saW5rX2NsaWNrZWQgfHwgZnVuY3Rpb24oc3JjKSB7CiAgICAgICAgdmFyIHF1ZXN0aW9uID0gc3JjLnRhcmdldC5jbG9zZXN0KCdkaXYuc3BlY2lmaWNmZWVkYmFjaycpOwogICAgICAgIHZhciBzb2x1dGlvbl9kaXYgPSBxdWVzdGlvbi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjb2RlcnVubmVyLXNjcmFtYmxlZC1hdXRob3JzLXNvbHV0aW9uJylbMF07CiAgICAgICAgdmFyIHNvbHV0aW9uX2xpbmsgPSBxdWVzdGlvbi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjb2RlcnVubmVyLXNjcmFtYmxlZC1zb2x1dGlvbi1saW5rJylbMF07CiAgICAgICAgdmFyIGNvZGUgPSBxdWVzdGlvbi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjb2RlLWhpZ2hsaWdodCcpWzBdOwoKICAgICAgICBpZiAoIWNvZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdoYXMtaGlnaGxpZ2h0JykpIHsKICAgICAgICAgICAgdmFyIGhpZ2hsaWdodCA9IHdpbmRvdy5hY2UucmVxdWlyZSgiYWNlL2V4dC9zdGF0aWNfaGlnaGxpZ2h0Iik7CiAgICAgICAgICAgIGhpZ2hsaWdodChjb2RlLCB7CiAgICAgICAgICAgICAgICBtb2RlOiAiYWNlL21vZGUvcHl0aG9uIiwKICAgICAgICAgICAgICAgIHNob3dHdXR0ZXI6IGZhbHNlCiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGhpZ2hsaWdodGVkKSB7CiAgICAgICAgICAgICAgICBjb2RlLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2FjZV9zdGF0aWNfaGlnaGxpZ2h0JylbMF0uc3R5bGVbJ2ZvbnQtc2l6ZSddID0gIjE0cHgiOwogICAgICAgICAgICB9KTsKICAgICAgICAgICAgY29kZS5jbGFzc0xpc3QuYWRkKCdoYXMtaGlnaGxpZ2h0Jyk7CiAgICAgICAgfQogICAgICAgIAogICAgICAgIGlmICghJChzb2x1dGlvbl9kaXYpLmhhc0NsYXNzKCdjb2xsYXBzaW5nJykpIHsKICAgICAgICAgICAgaWYgKCQoc29sdXRpb25fZGl2KS5hdHRyKCJleHBhbmRlZCIpID09PSAidHJ1ZSIpIHsKICAgICAgICAgICAgICAgIHNvbHV0aW9uX2xpbmsuaW5uZXJIVE1MID0gIlNob3cgc2NyYW1ibGVkIGF1dGhvcidzIHNvbHV0aW9uIjsKICAgICAgICAgICAgICAgICQoc29sdXRpb25fZGl2KS5jb2xsYXBzZSgnaGlkZScpOwogICAgICAgICAgICAgICAgJChzb2x1dGlvbl9kaXYpLmF0dHIoImV4cGFuZGVkIiwgImZhbHNlIik7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBzb2x1dGlvbl9saW5rLmlubmVySFRNTCA9ICJIaWRlIHNjcmFtYmxlZCBhdXRob3IncyBzb2x1dGlvbiI7CiAgICAgICAgICAgICAgICAkKHNvbHV0aW9uX2RpdikuY29sbGFwc2UoJ3Nob3cnKTsKICAgICAgICAgICAgICAgICQoc29sdXRpb25fZGl2KS5hdHRyKCJleHBhbmRlZCIsICJ0cnVlIik7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICB9CiAgICB2YXIgY29kZXJ1bm5lcl9hbGxfbGlua3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjb2RlcnVubmVyLXNjcmFtYmxlZC1zb2x1dGlvbi1saW5rJyk7CiAKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZXJ1bm5lcl9hbGxfbGlua3MubGVuZ3RoOyBpKyspIHsKICAgICAgICB2YXIgZWwgPSBjb2RlcnVubmVyX2FsbF9saW5rc1tpXTsKICAgICAgICBpZiAoIWVsLmNsYXNzTGlzdC5jb250YWlucygnaGFzLWNsaWNrLWhhbmRsZXInKSkgewogICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHdpbmRvdy5jb2RlcnVubmVyX3NvbHV0aW9uX2xpbmtfY2xpY2tlZCk7CiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2hhcy1jbGljay1oYW5kbGVyJyk7CiAgICAgICAgfQogICAgfSAgICAKPC9zY3JpcHQ+Cgo=</file>
<file name="__author_solution.html" path="/" encoding="base64">PGRpdiBjbGFzcz0iY29kZXJ1bm5lci10ZXN0LXJlc3VsdHMgZ29vZCI+CiAgICA8YSBjbGFzcz0iYnRuIGJ0bi1saW5rIGNvZGVydW5uZXItc29sdXRpb24tbGluayIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6I0NGQyI+U2hvdyBhdXRob3IncyBzb2x1dGlvbjwvYT4KPC9kaXY+CjxkaXYgY2xhc3M9ImNvZGVydW5uZXItYXV0aG9ycy1zb2x1dGlvbiBjb2xsYXBzZSIgZXhwYW5kZWQ9ImZhbHNlIiBzdHlsZT0ibWFyZ2luLWJvdHRvbTo4cHgiPgogICAgPHByZSBjbGFzcz0iY29kZS1oaWdobGlnaHQiPiVzPC9wcmU+CjwvZGl2Pgo8c2NyaXB0PgogICAgd2luZG93LmNvZGVydW5uZXJfc29sdXRpb25fbGlua19jbGlja2VkID0gd2luZG93LmNvZGVydW5uZXJfc29sdXRpb25fbGlua19jbGlja2VkIHx8IGZ1bmN0aW9uKHNyYykgewogICAgICAgIHZhciBxdWVzdGlvbiA9IHNyYy50YXJnZXQuY2xvc2VzdCgnZGl2LnNwZWNpZmljZmVlZGJhY2snKTsKICAgICAgICB2YXIgc29sdXRpb25fZGl2ID0gcXVlc3Rpb24uZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnY29kZXJ1bm5lci1hdXRob3JzLXNvbHV0aW9uJylbMF07CiAgICAgICAgdmFyIHNvbHV0aW9uX2xpbmsgPSBxdWVzdGlvbi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjb2RlcnVubmVyLXNvbHV0aW9uLWxpbmsnKVswXTsKICAgICAgICB2YXIgY29kZSA9IHF1ZXN0aW9uLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2NvZGUtaGlnaGxpZ2h0JylbMF07CgogICAgICAgIGlmICghY29kZS5jbGFzc0xpc3QuY29udGFpbnMoJ2hhcy1oaWdobGlnaHQnKSkgewogICAgICAgICAgICB2YXIgaGlnaGxpZ2h0ID0gd2luZG93LmFjZS5yZXF1aXJlKCJhY2UvZXh0L3N0YXRpY19oaWdobGlnaHQiKTsKICAgICAgICAgICAgaGlnaGxpZ2h0KGNvZGUsIHsKICAgICAgICAgICAgICAgIG1vZGU6ICJhY2UvbW9kZS9weXRob24iLAogICAgICAgICAgICAgICAgc2hvd0d1dHRlcjogZmFsc2UKICAgICAgICAgICAgfSwgZnVuY3Rpb24oaGlnaGxpZ2h0ZWQpIHsKICAgICAgICAgICAgICAgIGNvZGUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnYWNlX3N0YXRpY19oaWdobGlnaHQnKVswXS5zdHlsZVsnZm9udC1zaXplJ10gPSAiMTRweCI7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICBjb2RlLmNsYXNzTGlzdC5hZGQoJ2hhcy1oaWdobGlnaHQnKTsKICAgICAgICB9CiAgICAgICAgCiAgICAgICAgaWYgKCEkKHNvbHV0aW9uX2RpdikuaGFzQ2xhc3MoJ2NvbGxhcHNpbmcnKSkgewogICAgICAgICAgICBpZiAoJChzb2x1dGlvbl9kaXYpLmF0dHIoImV4cGFuZGVkIikgPT09ICJ0cnVlIikgewogICAgICAgICAgICAgICAgc29sdXRpb25fbGluay5pbm5lckhUTUwgPSAiU2hvdyBhdXRob3IncyBzb2x1dGlvbiI7CiAgICAgICAgICAgICAgICAkKHNvbHV0aW9uX2RpdikuaGlkZSgzMDApOwogICAgICAgICAgICAgICAgJChzb2x1dGlvbl9kaXYpLmF0dHIoImV4cGFuZGVkIiwgImZhbHNlIik7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBzb2x1dGlvbl9saW5rLmlubmVySFRNTCA9ICJIaWRlIGF1dGhvcidzIHNvbHV0aW9uIjsKICAgICAgICAgICAgICAgICQoc29sdXRpb25fZGl2KS5zaG93KDMwMCk7CiAgICAgICAgICAgICAgICAkKHNvbHV0aW9uX2RpdikuYXR0cigiZXhwYW5kZWQiLCAidHJ1ZSIpOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfQogICAgdmFyIGNvZGVydW5uZXJfYWxsX2xpbmtzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnY29kZXJ1bm5lci1zb2x1dGlvbi1saW5rJyk7CiAKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZXJ1bm5lcl9hbGxfbGlua3MubGVuZ3RoOyBpKyspIHsKICAgICAgICB2YXIgZWwgPSBjb2RlcnVubmVyX2FsbF9saW5rc1tpXTsKICAgICAgICBpZiAoIWVsLmNsYXNzTGlzdC5jb250YWlucygnaGFzLWNsaWNrLWhhbmRsZXInKSkgewogICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHdpbmRvdy5jb2RlcnVubmVyX3NvbHV0aW9uX2xpbmtfY2xpY2tlZCk7CiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2hhcy1jbGljay1oYW5kbGVyJyk7CiAgICAgICAgfQogICAgfSAgICAKPC9zY3JpcHQ+Cgo=</file>
<file name="__languagetask.py" path="/" encoding="base64">IiIiVGhlIGdlbmVyaWMgTGFuZ3VhZ2VUYXNrLCBzdWJjbGFzc2VzIG9mIHdoaWNoIG1hbmFnZSBjb21waWxpbmcgYW5kIGV4ZWN1dGluZwogICBjb2RlIGluIGEgcGFydGljdWxhciBsYW5ndWFnZS4KIiIiCmZyb20gZGF0ZXRpbWUgaW1wb3J0IGRhdGV0aW1lCgpXQVRDSERPR19GUkVFQk9BUkQgPSAxCgpjbGFzcyBDb21waWxlRXJyb3IoRXhjZXB0aW9uKToKICAgIGRlZiBfX2luaXRfXyhzZWxmLCBlcnJvcl9tZXNzYWdlKToKICAgICAgICBFeGNlcHRpb24uX19pbml0X18oc2VsZiwgZXJyb3JfbWVzc2FnZSkKCgpjbGFzcyBSdW5FcnJvcihFeGNlcHRpb24pOgogICAgZGVmIF9faW5pdF9fKHNlbGYsIGVycm9yX21lc3NhZ2U9JycpOgogICAgICAgIEV4Y2VwdGlvbi5fX2luaXRfXyhzZWxmLCBlcnJvcl9tZXNzYWdlKQoKY2xhc3MgTGFuZ3VhZ2VUYXNrOgogICAgZGVmIF9faW5pdF9fKHNlbGYsIHBhcmFtcywgY29kZT1Ob25lKToKICAgICAgICAiIiJJbml0aWFsaXNlIHRoZSBvYmplY3QsIHJlY29yZGluZyB0aGUgcGFyYW1ldGVycyB0aGF0IHdpbGwgY29udHJvbCBjb21waWxhdGlvbiBhbmQKICAgICAgICAgICBydW5uaW5nIHBsdXMgdGhlIGNvZGUgaWYgc3VwcGxpZWQuIENvZGUgbWF5IGJlIGFsdGVybmF0aXZlbHkgYmUgc3VwcGxpZWQgbGF0ZXIgYnkKICAgICAgICAgICBjYWxscyB0byBzZXRfY29kZS4KICAgICAgICAgICBzZWxmLnBhcmFtcyBpcyB0aGUgZGljdGlvbmFyeSBvZiB0ZW1wbGF0ZSAmIGdsb2JhbCBwYXJhbWV0ZXJzIC0gbGFuZ3VhZ2Ugc3BlY2lmaWMuCiAgICAgICAgIiIiCiAgICAgICAgc2VsZi5wYXJhbXMgPSBwYXJhbXMKICAgICAgICBzZWxmLmNvZGUgPSBjb2RlCiAgICAgICAgc2VsZi5leGVjdXRhYmxlX2J1aWx0ID0gRmFsc2UKICAgICAgICBzZWxmLmNvbXBpbGVfZXJyb3JfbWVzc2FnZSA9IE5vbmUKICAgICAgICBzZWxmLmVycm9yX21lc3NhZ2Vfb2Zmc2V0ID0gMAogICAgICAgIHNlbGYuc3RkZXJyID0gJycKICAgICAgICBzZWxmLnN0ZG91dCA9ICcnCiAgICAgICAgc2VsZi5zdGFydF90aW1lID0gZGF0ZXRpbWUubm93KCkKICAgICAgICBzZWxmLnRpbWVkX291dCA9IEZhbHNlCiAgICAgICAgaWYgJ3RvdGFsdGltZW91dCcgbm90IGluIHBhcmFtczoKICAgICAgICAgICAgc2VsZi5wYXJhbXNbJ3RvdGFsdGltZW91dCddID0gMzAgIyBTZWNzCgogICAgZGVmIHNlY29uZHNfcmVtYWluaW5nKHNlbGYpOgogICAgICAgICIiIlRoZSBudW1iZXIgb2Ygc2Vjb25kcyBvZiBleGVjdXRpb24gdGltZSByZW1haW5pbmcgYmVmb3JlIHRoZSB3YXRjaGRvZyB0aW1lciBnb2VzIG9mZi4KICAgICAgICAgICBUaGUgd2F0Y2hkb2cgdGltZXIgZ29lcyBvZmYgMSBzZWNvbmQgYmVmb3JlIHJ1bmd1YXJkIGtpbGxzIHRoZSBqb2IgKGFzIGRldGVybWluZWQgYnkgdGhlICd0aW1lb3V0JyBwYXJhbWV0ZXIpLgogICAgICAgICIiIgogICAgICAgIHRfZWxhcHNlZCA9IChkYXRldGltZS5ub3coKSAtIHNlbGYuc3RhcnRfdGltZSkudG90YWxfc2Vjb25kcygpCiAgICAgICAgcmV0dXJuIHNlbGYucGFyYW1zWyd0b3RhbHRpbWVvdXQnXSAtIHRfZWxhcHNlZCAtIFdBVENIRE9HX0ZSRUVCT0FSRAoKICAgIGRlZiBzZXRfY29kZShzZWxmLCBjb2RlLCBlcnJvcl9tZXNzYWdlX29mZnNldD0wKToKICAgICAgICAiIiJTZXQgdGhlIGNvZGUgdG8gYmUgdXNlZCBmb3Igc3Vic2VxdWVudCBjb21waWxpbmcgYW5kIHJ1bm5pbmcuIFRoZSBvcHRpb25hbCBlcnJvcl9tZXNzYWdlX29mZnNldAogICAgICAgICAgIGlzIGEgbnVtYmVyIHRvIGJlIHN1YnRyYWN0ZWQgZnJvbSBhbnkgZXJyb3IgbWVzc2FnZXMgZ2VuZXJhdGVkIGJ5IGNvbXBpbGUgYW5kIHJ1bl9jb2RlIGNhbGxzLgogICAgICAgICAgIEV4YWN0bHkgaG93IChvciBldmVuICdpZicpIGl0IGlzIHVzZWQgaXMgbGFuZ3VhZ2UgZGVwZW5kZW50LgogICAgICAgICIiIgogICAgICAgIHNlbGYuY29kZSA9IGNvZGUKICAgICAgICBzZWxmLmVycm9yX21lc3NhZ2Vfb2Zmc2V0ID0gZXJyb3JfbWVzc2FnZV9vZmZzZXQKCiAgICBkZWYgY29tcGlsZShzZWxmLCBtYWtlX2V4ZWN1dGFibGU9RmFsc2UpOgogICAgICAgICIiIkNvbXBpbGUgdGhlIGN1cnJlbnRseSBzZXQgY29kZSwgZWl0aGVyIHRvIGFuIG9iamVjdCBmaWxlIG9yCiAgICAgICAgICAgdG8gYW4gZXhlY3V0YWJsZSBmaWxlIGRlcGVuZGluZyBvbiB0aGUgZ2l2ZW4gbWFrZV9leGVjdXRhYmxlIHBhcmFtZXRlci4KICAgICAgICAgICBBZGp1c3QgYW55IGVycm9yIG1lc3NhZ2UgYnkgc3VidHJhY3RpbmcgZXJyb3JfbWVzc2FnZV9vZmZzZXQuCiAgICAgICAgICAgUmFpc2UgQ29tcGlsZUVycm9yIGlmIHRoZSBjb2RlIGRvZXMgbm90CiAgICAgICAgICAgY29tcGlsZSwgd2l0aCB0aGUgY29tcGlsYXRpb24gZXJyb3IgbWVzc2FnZSB3aXRoaW4gdGhlIGV4Y2VwdGlvbgogICAgICAgICAgIGFuZCBhbHNvIHJlY29yZGVkIGluIHNlbGYuY29tcGlsZV9lcnJvcl9tZXNzYWdlLgogICAgICAgICAgIE5vIHJldHVybiB2YWx1ZS4KICAgICAgICAiIiIKICAgICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKCJjb21waWxlIG5vdCBpbXBsZW1lbnRlZCBieSBjb25jcmV0ZSBjbGFzcyIpCgogICAgZGVmIGRpc2NhcmRfZXhlY3V0YWJsZShzZWxmKToKICAgICAgICAiIiJDYWxsZWQgaWYgc29tZXRoaW5nIGJyZWFrcyBpbiB0aGUgZXhlY3V0YWJsZSBhbmQgaXQgd2lsbCBuZWVkIHJlYnVpbGRpbmcKICAgICAgICAgICAod2l0aCBkaWZmZXJlbnQgc291cmNlLCBwcmVzdW1hYmx5KQogICAgICAgICIiIgogICAgICAgIHNlbGYuZXhlY3V0YWJsZV9idWlsdCA9IEZhbHNlCgogICAgZGVmIHJ1bl9jb2RlKHNlbGYsIHN0YW5kYXJkX2lucHV0PU5vbmUsIGJhc2hfY29tbWFuZD1Ob25lKToKICAgICAgICAiIiJSdW4gdGhlIGNvZGUgaW4gdGhlIGV4ZWN1dGFibGUgcHJvZ3JhbSB0aGF0IGEgY2FsbCB0byBjb21waWxlIGlzIGFzc3VtZWQKICAgICAgICAgICB0byBoYXZlIGNyZWF0ZWQsIHVzaW5nIHRoZSBnaXZlbiBzdGFuZGFyZCBpbnB1dC4KICAgICAgICAgICBJZiBhIGJhc2hfY29tbWFuZCBpcyBzdXBwbGllZCBpdCB1c2VkIGFzIGdpdmVuLgogICAgICAgICAgIE90aGVyd2lzZSB0aGUgY29tbWFuZCB0byBiZSBleGVjdXRlZCBpcyB0aGUgY29tcGlsZWQgZXhlY3V0YWJsZS4KICAgICAgICAgICBSZXR1cm5zIGEgdHVwbGUgb2YgdGhlIG91dHB1dCBmcm9tIHRoZQogICAgICAgICAgIHJ1biBhbmQgYSBzdGRlcnIgKG9yIGEgZGVyaXZhdGl2ZSB0aGVyZW9mKSBzdHJpbmcuIFRob3NlIHR3byB2YWx1ZXMKICAgICAgICAgICBhcmUgYWxzbyByZWNvcmRlZCBpbiBzZWxmLnN0ZG91dCBhbmQgc2VsZi5zdGRlcnIgcmVzcGVjdGl2ZWx5LgogICAgICAgICIiIgogICAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoInJ1bl9jb2RlIG5vdCBpbXBsZW1lbnRlZCBieSBjb25jcmV0ZSBjbGFzcyIp</file>
<file name="__plottools.py" path="/" encoding="base64">IiIiRGVmaW5lIHN1cHBvcnQgZnVuY3Rpb25zIGZvciB0ZXN0aW5nIG9mIG1hdHBsb3RsaWIgcXVlc3Rpb25zLgogICBUaGUgbWFpbiBmdW5jdGlvbiBpcyBwcmludF9wbG90X2luZm8sIHdoaWNoIGRpc3BsYXlzIHN1aXRhYmx5IGZvcm1hdHRlZAogICBkYXRhIGFib3V0IHRoZSBjdXJyZW50IG1hdHBsb3RsaWIgcGxvdC4KCiAgIFRoaXMgbW9kdWxlIHdvcmtzIG9ubHkgaWYgaW1wb3J0ZWQgKmFmdGVyKiBhIGNhbGwgdG8gbWF0cGxvdGxpYmcudXNlKCJBZ2ciKSBoYXMKICAgYmVlbiBkb25lLgoiIiIKaW1wb3J0IHRyYWNlYmFjawppbXBvcnQgbnVtcHkgYXMgbnAKaW1wb3J0IG1hdHBsb3RsaWIucHlwbG90IGFzIHBsdApmcm9tIG1hdHBsb3RsaWIgaW1wb3J0IGNvbG9ycyBhcyBjb2xvcnMKZnJvbSBzY2lweSBpbXBvcnQgaW50ZXJwb2xhdGUKCkRFRkFVTFRfUEFSQU1TID0gewogICAgJ3hfc2FtcGxlcyc6IE5vbmUsICAjIEEgbGlzdCBvZiB4LXZhbHVlcyBhdCB3aGljaCB5IHZhbHVlcyBzaG91bGQgYmUgaW50ZXJwb2xhdGVkLgogICAgJ2Jhcl9pbmRpY2VzJzogTm9uZSwgICMgQSBsaXN0IG9mIHRoZSAwLW9yaWdpbiBiYXIgaW5kaWNlcyB0byByZXBvcnQgb24uIE5vbmUgZm9yIGFsbCBiYXJzLgogICAgJ3Nob3dfeGxpbSc6IEZhbHNlLCAgIyBUcnVlIHRvIGRpc3BsYXkgdGhlIHgtYXhpcyBsaW1pdHMKICAgICdzaG93X3lsaW0nOiBGYWxzZSwgICMgVHJ1ZSB0byBkaXNwbGF5IHRoZSB5LWF4aXMgbGltaXRzCiAgICAnc2hvd19jb2xvdXInOiBGYWxzZSwgICMgVHJ1ZSB0byByZXBvcnQgbGluZS9tYXJrZXIgY29sb3VyCiAgICAnc2hvd194dGlja2xhYmVscyc6IE5vbmUsICAjIFRydWUgdG8gZGlzcGxheSB4LXRpY2sgbGFiZWxzIChkZWZhdWx0cyBUcnVlIGZvciBiYXJzLCBGYWxzZSBvdGhlcndpc2UpCiAgICAnc2hvd195dGlja2xhYmVscyc6IEZhbHNlLCAgIyBUcnVlIHRvIGRpc3BsYXkgeS10aWNrIGxhYmVscwogICAgJ3Nob3dfeHRpY2tzJzogRmFsc2UsICAjIFRydWUgdG8gZGlzcGxheSB4LXRpY2sgbnVtZXJpYyB2YWx1ZXMKICAgICdzaG93X3l0aWNrcyc6IEZhbHNlLCAgIyBUcnVlIHRvIGRpc3BsYXkgeS10aWNrIG51bWVyaWMgdmFsdWVzCiAgICAnc2hvd19iYXJ4JzogVHJ1ZSwgICMgVHJ1ZSB0byBwcmludCB0aGUgeC1jb29yZGluYXRlcyBvZiBhbGwgYmFycwogICAgJ3Nob3dfbGluZWxhYmVscyc6IE5vbmUsICAjIFRydWUgdG8gc2hvdyBsaW5lIGxhYmVscywgZGVmYXVsdCBpcyBUcnVlIGlmIHRoZXJlJ3MgYSBsZWdlbmQgZWxzZSBGYWxzZQogICAgJ3NvcnRfcG9pbnRzJzogRmFsc2UsICAjIFRydWUgdG8gc29ydCBkYXRhIGJ5IHggdGhlbiB5LgogICAgJ2ZpcnN0X251bV9wb2ludHMnOiA1LCAgIyBOdW1iZXIgb2YgcG9pbnRzIHRvIHByaW50IGF0IHRoZSBzdGFydCBvZiB0aGUgcG9pbnQgbGlzdC4KICAgICdsYXN0X251bV9wb2ludHMnOiA1LCAgIyBOdW1iZXIgb2YgcG9pbnRzIHRvIHByaW50IGF0IHRoZSBlbmQgb2YgdGhlIHBvaW50IGxpc3QuCiAgICAnZmxvYXRfcHJlY2lzaW9uJzogKDEsIDEpLCAgIyBOdW0gZGlnaXRzIHRvIGRpc3BsYXkgYWZ0ZXIgZGVjaW1hbCBwb2ludCBmb3IgeCBhbmQgeSB2YWx1ZXMgcmVzcAogICAgJ21heF9sYWJlbF9sZW5ndGgnOiA2MCwgICMgVXNlIG11bHRpbGluZSBkaXNwbGF5IGlmIHRpY2sgbGFiZWwgc3RyaW5nIGxlbmd0aCBleGNlZWRzIHRoaXMKICAgICdsaW5lc190b19wcmludCc6IE5vbmUsICAjIElmIG5vbi1Ob25lLCBhIGxpc3Qgb2YgaW5kaWNlcyBvZiBsaW5lcyB0byBwcmludCAoMCBpcyBmaXJzdCBsaW5lKS4KICAgICdsaW5lX2luZm9fb25seSc6IEZhbHNlLCAgIyBUcnVlIHRvIHN1cHByZXNzIGFsbCBleGNlcHQgdGhlIGxpbmUvYmFyL3BvaW50cyBpbmZvCn0KCgpjbGFzcyBQbG90Q2hlY2tlcjoKICAgICIiIldyYXBwZXIgZm9yIGFsbCB0aGUgaW50ZXJuYWwgbWV0aG9kcyB1c2VkIHRvIHByaW50IHBsb3QgaW5mby4iIiIKCiAgICBkZWYgX19pbml0X18oc2VsZiwgcGFyYW1zX2RpY3QpOgogICAgICAgICIiIkluaXRpYWxpc2Ugd2l0aCBhIHN1YnNldCBvZiB0aGUgb3B0aW9ucyBsaXN0ZWQgYWJvdmUiIiIKICAgICAgICBzZWxmLnBhcmFtcyA9IERFRkFVTFRfUEFSQU1TLmNvcHkoKQogICAgICAgIHNlbGYucGFyYW1zLnVwZGF0ZShwYXJhbXNfZGljdCkKCiAgICBAc3RhdGljbWV0aG9kCiAgICBkZWYgbXlfaW50ZXJwb2xhdGUoZGF0YSwgeHMpOgogICAgICAgICIiIlJldHVybiB0aGUgc3BsaW5lIGludGVycG9sYXRlZCBsaXN0IG9mICh4LCB5KSB2YWx1ZXMgYXQgYWJzY2lzc2EgeHMsIGdpdmVuCiAgICAgICAgICAgYSBsaXN0IG9mICh4LCB5KSBwYWlycwogICAgICAgICIiIgoKICAgICAgICBkZWYgbGluZWFyKHgsIHhhLCB5YSwgeGIsIHliKToKICAgICAgICAgICAgcmV0dXJuIHlhICsgKHggLSB4YSkgLyAoeGIgLSB4YSkgKiAoeWIgLSB5YSkKCiAgICAgICAgaWYgbGVuKGRhdGFbOiwgMF0pID09IDI6CiAgICAgICAgICAgIHgwLCB5MCA9IGRhdGFbMF1bMF0sIGRhdGFbMF1bMV0KICAgICAgICAgICAgeDEsIHkxID0gZGF0YVstMV1bMF0sIGRhdGFbLTFdWzFdCiAgICAgICAgICAgIHJldHVybiBbKHgsIGxpbmVhcih4LCB4MCwgeTAsIHgxLCB5MSkpIGZvciB4IGluIHhzXQogICAgICAgIGVsc2U6ICAjIGN1YmljCiAgICAgICAgICAgIHRjayA9IGludGVycG9sYXRlLnNwbHJlcChkYXRhWzosIDBdLCBkYXRhWzosIDFdLCBzPTApICAjIEN1YmljIHNwbGluZSBpbnRlcnBvbGF0b3IKICAgICAgICAgICAgcmV0dXJuIHppcCh4cywgaW50ZXJwb2xhdGUuc3BsZXYoeHMsIHRjaykpICAjIEV2YWx1YXRlIGF0IHJlcXVpcmVkIHggdmFsdWVzCgogICAgQHN0YXRpY21ldGhvZAogICAgZGVmIGZtdF9mbG9hdCh2YWx1ZSwgZGlnaXRzX3ByZWNpc2lvbj0yKToKICAgICAgICAiIiJSZXR1cm4gYSBmb3JtYXR0ZWQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIHRvIHRoZSBwcmVjaXNpb24gc3BlY2lmaWVkLAogICAgICAgICAgIHJlcGxhY2luZyAtMCB3aXRoIDAiIiIKICAgICAgICBmb3JtYXRfc3RyaW5nID0gZicue2RpZ2l0c19wcmVjaXNpb259ZicKICAgICAgICBzID0gZm9ybWF0KHZhbHVlLCBmb3JtYXRfc3RyaW5nKQogICAgICAgIGlmIHMuc3RhcnRzd2l0aCgnLScpIGFuZCBmbG9hdChzKSA9PSAwLjA6CiAgICAgICAgICAgIHMgPSBzWzE6XSAgIyBTdHJpcCBvZmYgdGhlIG1pbnVzIHNpZ24uCiAgICAgICAgcmV0dXJuIHMKCiAgICBkZWYgZm10X2Zsb2F0X3goc2VsZiwgdmFsdWUpOgogICAgICAgICIiIlJldHVybiBhIGZvcm1hdHRlZCB4LXZhbHVlIHVzaW5nIHRoZSBwcmVjaXNpb24gc3BlY2lmaWVkIGZvciB0aGUgeC1heGVzLAogICAgICAgICAgIGV4Y2VwdCBpZiB2YWx1ZSBpcyBhIHN0cmluZywgcmV0dXJuIGl0IHVuY2hhbmdlZC4KICAgICAgICAiIiIKICAgICAgICBpZiBpc2luc3RhbmNlKHZhbHVlLCBzdHIpOgogICAgICAgICAgICByZXR1cm4gdmFsdWUKICAgICAgICBlbHNlOgogICAgICAgICAgICB4X3ByZWNpc2lvbiA9IHNlbGYucGFyYW1zWydmbG9hdF9wcmVjaXNpb24nXVswXQogICAgICAgICAgICByZXR1cm4gc2VsZi5mbXRfZmxvYXQodmFsdWUsIHhfcHJlY2lzaW9uKQoKICAgIGRlZiBmbXRfZmxvYXRfeShzZWxmLCB2YWx1ZSk6CiAgICAgICAgIiIiUmV0dXJuIGEgZm9ybWF0dGVkIHgtdmFsdWUgdXNpbmcgdGhlIHByZWNpc2lvbiBzcGVjaWZpZWQgZm9yIHRoZSB5LWF4ZXMsCiAgICAgICAgICAgZXhjZXB0IGlmIHZhbHVlIGlzIGEgc3RyaW5nLCByZXR1cm4gaXQgdW5jaGFuZ2VkLgogICAgICAgICIiIgogICAgICAgIGlmIGlzaW5zdGFuY2UodmFsdWUsIHN0cik6CiAgICAgICAgICAgIHJldHVybiB2YWx1ZQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHhfcHJlY2lzaW9uID0gc2VsZi5wYXJhbXNbJ2Zsb2F0X3ByZWNpc2lvbiddWzFdCiAgICAgICAgICAgIHJldHVybiBzZWxmLmZtdF9mbG9hdCh2YWx1ZSwgeF9wcmVjaXNpb24pCgogICAgZGVmIGZtdF9mbG9hdF9wYWlyKHNlbGYsIHAsIHByZWNpc2lvbj1Ob25lKToKICAgICAgICAiIiJBIGZvcm1hdHRlZCAoeCwgeSkgcG9pbnQgb3Igb3RoZXIgcGFpciBvZiBmbG9hdGluZy1wb2ludCBudW1iZXJzLgogICAgICAgICAgIEJ5IGRlZmF1bHQsIHVzZSBmbG9hdF9wcmVjaXNpb25feCBhbmQgZmxvYXRfcHJlY2lzaW9uX3kgZm9yIHRoZQogICAgICAgICAgIGZpcnN0IGFuZCBzZWNvbmQgbnVtYmVycyByZXNwLCBlbHNlIHVzZSBwcmVjaXNpb24gaWYgZ2l2ZW4uCiAgICAgICAgIiIiCiAgICAgICAgaWYgcHJlY2lzaW9uIGlzIE5vbmU6CiAgICAgICAgICAgIHhfcHJlY2lzaW9uID0gc2VsZi5wYXJhbXNbJ2Zsb2F0X3ByZWNpc2lvbiddWzBdCiAgICAgICAgICAgIHlfcHJlY2lzaW9uID0gc2VsZi5wYXJhbXNbJ2Zsb2F0X3ByZWNpc2lvbiddWzFdCiAgICAgICAgZWxzZToKICAgICAgICAgICAgeF9wcmVjaXNpb24gPSB5X3ByZWNpc2lvbiA9IHByZWNpc2lvbgogICAgICAgIHJldHVybiBmIih7c2VsZi5mbXRfZmxvYXQocFswXSwgeF9wcmVjaXNpb24pfSwge3NlbGYuZm10X2Zsb2F0KHBbMV0sIHlfcHJlY2lzaW9uKX0pIgoKICAgIEBzdGF0aWNtZXRob2QKICAgIGRlZiBub3JtYWxpc2VfY29sb3VyKGNvbG91cik6CiAgICAgICAgIiIiR2l2ZW4gYSBtYXRwbG90bGliIGNvbG91ciwgY29udmVydCB0byBhIHN0YW5kYXJpc2VkIGZvcm1hdCIiIgogICAgICAgIHJnYiA9IGNvbG9ycy50b19yZ2IoY29sb3VyKQogICAgICAgIHJldHVybiBmIlJHQih7cmdiWzBdOjAuMmZ9LCB7cmdiWzFdOjAuMmZ9LCB7cmdiWzJdOjAuMmZ9KSIKCiAgICBkZWYgcHJpbnRfbGluZShzZWxmLCBsaW5lLCB4c2FtcGxlcyk6CiAgICAgICAgIiIiUHJpbnQgdGhlIGluZm8gZm9yIHRoZSBnaXZlbiBsaW5lIiIiCiAgICAgICAgaWYgc2VsZi5wYXJhbXNbJ3Nob3dfY29sb3VyJ106CiAgICAgICAgICAgIHByaW50KCJDb2xvcjoiLCBzZWxmLm5vcm1hbGlzZV9jb2xvdXIobGluZS5nZXRfY29sb3IoKSkpCiAgICAgICAgcHJpbnQoIk1hcmtlcjoiLCBsaW5lLmdldF9tYXJrZXIoKSkKICAgICAgICBwcmludCgiTGluZSBzdHlsZToiLCBsaW5lLmdldF9saW5lc3R5bGUoKSkKICAgICAgICBsYWJlbCA9IGxpbmUuZ2V0X2xhYmVsKCkKICAgICAgICBpZiBsYWJlbCBhbmQgc2VsZi5wYXJhbXNbJ3Nob3dfbGluZWxhYmVscyddOgogICAgICAgICAgICBwcmludCgiTGFiZWw6IiwgbGFiZWwpCiAgICAgICAgZGF0YSA9IGxpbmUuZ2V0X3h5ZGF0YSgpCgogICAgICAgIGlmIHNlbGYucGFyYW1zWydzb3J0X3BvaW50cyddOgogICAgICAgICAgICBkYXRhID0gbnAuYXJyYXkoc29ydGVkKFtbcm93WzBdLCByb3dbMV1dIGZvciByb3cgaW4gZGF0YV0pKQogICAgICAgICAgICBwcmludCgiUGxvdHRlZCBkYXRhLCBhZnRlciBzb3J0aW5nIC4uLiIpCgogICAgICAgIGlmIHhzYW1wbGVzIGlzIG5vdCBOb25lOgogICAgICAgICAgICBwcmludChmIkZpcnN0IHBvaW50OiB7c2VsZi5mbXRfZmxvYXRfcGFpcihkYXRhWzBdKX0iKQogICAgICAgICAgICBwcmludChmIkxhc3QgcG9pbnQ6IHtzZWxmLmZtdF9mbG9hdF9wYWlyKGRhdGFbLTFdKX0iKQogICAgICAgICAgICBwcmludChmIkludGVycG9sYXRpbmcgbGluZSBhdCBzZWxlY3RlZCB4IHZhbHVlczoiKQogICAgICAgICAgICBpbnRlcnBvbGF0ZWQgPSBzZWxmLm15X2ludGVycG9sYXRlKGRhdGEsIHhzYW1wbGVzKQogICAgICAgICAgICBmb3IgcCBpbiBpbnRlcnBvbGF0ZWQ6CiAgICAgICAgICAgICAgICBwcmludCgnICAgJywgc2VsZi5mbXRfZmxvYXRfcGFpcihwKSkKICAgICAgICBlbHNlOgogICAgICAgICAgICBwcmludChmIk51bSBwb2ludHM6IHtsZW4oZGF0YSl9IikKICAgICAgICAgICAgbiA9IG1pbihsZW4oZGF0YSksIHNlbGYucGFyYW1zWydmaXJzdF9udW1fcG9pbnRzJ10pCiAgICAgICAgICAgIGlmIG46CiAgICAgICAgICAgICAgICBwb2ludHMgPSAnXG4gICAgJy5qb2luKHNlbGYuZm10X2Zsb2F0X3BhaXIocCkgZm9yIHAgaW4gZGF0YVs6bl0pCiAgICAgICAgICAgICAgICBpZiBuIDwgbGVuKGRhdGEpOgogICAgICAgICAgICAgICAgICAgIHByaW50KGYiRmlyc3Qge259IHBvaW50czpcbiAgICB7cG9pbnRzfSIpCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIHByaW50KGYiICAgIHtwb2ludHN9IikKICAgICAgICAgICAgbGFzdF9uID0gbWluKGxlbihkYXRhKSAtIG4sIHNlbGYucGFyYW1zWydsYXN0X251bV9wb2ludHMnXSkKICAgICAgICAgICAgaWYgbGFzdF9uOgogICAgICAgICAgICAgICAgcG9pbnRzID0gJ1xuICAgICcuam9pbihzZWxmLmZtdF9mbG9hdF9wYWlyKHApIGZvciBwIGluIGRhdGFbLWxhc3RfbjpdKQogICAgICAgICAgICAgICAgcHJpbnQoZiJMYXN0IHtsYXN0X259IHBvaW50czpcbiAgICB7cG9pbnRzfSIpCgogICAgZGVmIHByaW50X2xpbmVzKHNlbGYsIHN1YnBsb3QsIHhzYW1wbGVzKToKICAgICAgICAiIiJQcmludCBhbGwgc2VsZWN0ZWQgbGluZXMgaW4gdGhlIHBsb3Qgc2hvd2luZyB5IHZhbHVlcyBpbnRlcnBsb2xhdGVkIGF0IHRoZSB4IHNhbXBsZSBwb2ludHMsCiAgICAgICAgICAgaWYgZ2l2ZW4uIE90aGVyd2lzZSwgcHJpbnQganVzdCB0aGUgZmlyc3QgZmlyc3RfbnVtX3BvaW50cyBhbmQgbGFzdCBsYXN0X251bV9wb2ludHMuIEFsc28KICAgICAgICAgICBzaG93IGxpbmUgY29sb3VycyBpZiB0aGUgc2hvd19jb2xvdXIgcGFyYW1ldGVyIGlzIFRydWUuCiAgICAgICAgIiIiCiAgICAgICAgbGluZXMgPSBzdWJwbG90LmdldF9saW5lcygpCiAgICAgICAgaWYgbGVuKGxpbmVzKSA9PSAwOgogICAgICAgICAgICBwcmludCgiTm8gcGxvdHRlZCBsaW5lcyBmb3VuZCIpCiAgICAgICAgICAgIHJldHVybgogICAgICAgIGxpbmVfaW5kaWNlcyA9IHNlbGYucGFyYW1zWydsaW5lc190b19wcmludCddCiAgICAgICAgaWYgbGluZV9pbmRpY2VzIGlzIE5vbmU6CiAgICAgICAgICAgIHdhbnRlZF9saW5lcyA9IGxpbmVzCiAgICAgICAgZWxzZToKICAgICAgICAgICAgd2FudGVkX2xpbmVzID0gW10KICAgICAgICAgICAgZm9yIGkgaW4gbGluZV9pbmRpY2VzOgogICAgICAgICAgICAgICAgaWYgaSA+PSBsZW4obGluZXMpOgogICAgICAgICAgICAgICAgICAgIHByaW50KGYiQ2FuJ3QgZGlzcGxheSBpbmZvIGZvciBwbG90IHtpfSAtIG5vIHN1Y2ggcGxvdCEiKQogICAgICAgICAgICAgICAgICAgIHJldHVybgogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICB3YW50ZWRfbGluZXMuYXBwZW5kKGxpbmVzW2ldKQoKICAgICAgICBtdWx0aWxpbmVzID0gbGVuKHdhbnRlZF9saW5lcykgPiAxCiAgICAgICAgaWYgbXVsdGlsaW5lczoKICAgICAgICAgICAgcHJpbnQoZiJEaXNwbGF5aW5nIGluZm8gZm9yIHtsZW4od2FudGVkX2xpbmVzKX0gbGluZXMiKQogICAgICAgIGZvciBpLCBsaW5lIGluIGVudW1lcmF0ZSh3YW50ZWRfbGluZXMsIDEpOgogICAgICAgICAgICBpZiBtdWx0aWxpbmVzOgogICAgICAgICAgICAgICAgcHJpbnQoZiJMaW5lIHtpfToiKQogICAgICAgICAgICBzZWxmLnByaW50X2xpbmUobGluZSwgeHNhbXBsZXMpCiAgICAgICAgICAgIGlmIG11bHRpbGluZXM6CiAgICAgICAgICAgICAgICBwcmludCgpCgogICAgQHN0YXRpY21ldGhvZAogICAgZGVmIGluX3JhbmdlKGxhYmVscywgbGltaXRzKToKICAgICAgICAiIiJSZXR1cm4gdGhlIGxpc3Qgb2YgYXhpcyBsYWJlbHMsIGZpbHRlcmVkIHRvIGluY2x1ZGUgb25seSB0aG9zZSB3aXRoaW4KICAgICAgICAgICB0aGUgZ2l2ZW4gbGltaXRzIChtaW4sIG1heCkuIElmIGFueSBvZiB0aGUgYXhpcyBsYWJlbHMgYXJlIG5vbi1udW1lcmljCiAgICAgICAgICAgdGhlIGxpc3QgaXMgcmV0dXJuZWQgdW5jaGFuZ2VkLgogICAgICAgICIiIgogICAgICAgIHRyeToKICAgICAgICAgICAgY2xpcHBlZF9sYWJlbHMgPSBbXQogICAgICAgICAgICBmb3IgcyBpbiBsYWJlbHM6CiAgICAgICAgICAgICAgICBpZiBpc2luc3RhbmNlKHMsIHN0cik6CiAgICAgICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgn4oiSJywgJy0nKQogICAgICAgICAgICAgICAgaWYgbGltaXRzWzBdIDw9IGZsb2F0KHMpIDw9IGxpbWl0c1sxXToKICAgICAgICAgICAgICAgICAgICBjbGlwcGVkX2xhYmVscy5hcHBlbmQocykKICAgICAgICAgICAgcmV0dXJuIGNsaXBwZWRfbGFiZWxzCiAgICAgICAgZXhjZXB0IFZhbHVlRXJyb3I6CiAgICAgICAgICAgIHJldHVybiBsYWJlbHMKCiAgICBkZWYgcHJpbnRfYmFycyhzZWxmLCBzdWJwbG90KToKICAgICAgICAiIiJQcmludCBhIGxpc3Qgb2YgYWxsIGJhcnMgaWYgdGhlIGJhcl9pbmRpY2VzIHBhcmFtIGlzIE5vbmUgb3IgYSBsaXN0IG9mIHRoZQogICAgICAgICAgIGJhcnMgd2l0aCB0aGUgZ2l2ZW4gaW5kaWNlcywgb3RoZXJ3aXNlLgogICAgICAgICIiIgogICAgICAgIHByaW50KCJCYXJzOiIpCiAgICAgICAgYmFycyA9IHN1YnBsb3QucGF0Y2hlcwogICAgICAgIGlmIGJhcnMgYW5kIHNlbGYucGFyYW1zWydzaG93X2NvbG91ciddOgogICAgICAgICAgICBwcmludChmIkZpcnN0IGJhciBjb2xvdXI6IHtzZWxmLm5vcm1hbGlzZV9jb2xvdXIoYmFyc1swXS5nZXRfZmFjZWNvbG9yKCkpfSIpCiAgICAgICAgYmFyX2luZGljZXMgPSBzZWxmLnBhcmFtc1snYmFyX2luZGljZXMnXQogICAgICAgIGlmIGJhcl9pbmRpY2VzIGlzIE5vbmU6CiAgICAgICAgICAgIGJhcl9pbmRpY2VzID0gcmFuZ2UoMCwgbGVuKHN1YnBsb3QucGF0Y2hlcykpCiAgICAgICAgZm9yIGkgaW4gYmFyX2luZGljZXM6CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIGJhciA9IHN1YnBsb3QucGF0Y2hlc1tpXQogICAgICAgICAgICAgICAgeSA9IGJhci5nZXRfaGVpZ2h0KCkKICAgICAgICAgICAgICAgIGlmIHNlbGYucGFyYW1zWydzaG93X2JhcngnXToKICAgICAgICAgICAgICAgICAgICB4ID0gYmFyLmdldF94eSgpWzBdICsgYmFyLmdldF93aWR0aCgpIC8gMgogICAgICAgICAgICAgICAgICAgIGJhcl9zcGVjID0gZiJCYXJ7aX06IHggPSB7c2VsZi5mbXRfZmxvYXRfeCh4KX0sIGhlaWdodCA9IHtzZWxmLmZtdF9mbG9hdF95KHkpfSIKICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgYmFyX3NwZWMgPSBmIkJhcntpfTogaGVpZ2h0ID0ge3NlbGYuZm10X2Zsb2F0X3koeSl9IgogICAgICAgICAgICAgICAgcHJpbnQoYmFyX3NwZWMpCiAgICAgICAgICAgIGV4Y2VwdCBJbmRleEVycm9yOgogICAgICAgICAgICAgICAgcHJpbnQoZiJCYXJ7aX0gbm90IGZvdW5kLiBOdW1iZXIgb2YgYmFycyA9IHtsZW4oc3VicGxvdC5wYXRjaGVzKX0iKQogICAgICAgICAgICAgICAgYnJlYWsKCiAgICBkZWYgdGlja19sYWJlbF90ZXh0KHNlbGYsIGxhYmVscyk6CiAgICAgICAgIiIiUmV0dXJuIGEgc3RyaW5nIHN1aXRhYmxlIGZvciBkaXNwbGF5aW5nIHRpY2sgbGFiZWxzIiIiCiAgICAgICAgbGFiZWxfdGV4dCA9ICcsICcuam9pbihsYWJlbHMpCiAgICAgICAgaWYgbGVuKGxhYmVsX3RleHQpID4gc2VsZi5wYXJhbXNbJ21heF9sYWJlbF9sZW5ndGgnXToKICAgICAgICAgICAgbGFiZWxfdGV4dCA9ICdcbicuam9pbihsYWJlbHMpCiAgICAgICAgcmV0dXJuIGxhYmVsX3RleHQKCiAgICBkZWYgcHJpbnRfdGlja3Moc2VsZiwgc3VicGxvdCwgeGxpbSwgeWxpbSk6CiAgICAgICAgIiIiUHJpbnQgdGljayBhbmQgdGlja2xhYmVsIGluZm8gZm9yIHRoZSBnaXZlbiBzdWJwbG90LiIiIgogICAgICAgIGlmIHNlbGYucGFyYW1zWydzaG93X3h0aWNrcyddOgogICAgICAgICAgICB4X3RpY2tzID0gW3NlbGYuZm10X2Zsb2F0X3gocG9zKSBmb3IgcG9zIGluIHN1YnBsb3QuZ2V0X3h0aWNrcygpXQogICAgICAgICAgICBwcmludCgnWC1heGlzIHRpY2tzIGF0ICcsICcsICcuam9pbih4X3RpY2tzKSkKCiAgICAgICAgaWYgc2VsZi5wYXJhbXNbJ3Nob3dfeHRpY2tsYWJlbHMnXToKICAgICAgICAgICAgeF90aWNrX2xhYmVscyA9IFtsYWJlbC5nZXRfdGV4dCgpIGZvciBsYWJlbCBpbiBzdWJwbG90LmdldF94dGlja2xhYmVscygpXQogICAgICAgICAgICAjIEEgcHJvYmxlbSBoZXJlIGlzIHRoYXQgaW4gYSBjYWxsIHRvIGJhcihheGlzX2xhYmVscywgYmFyX2hlaWdodHMpIHRoZSBjYWxsIHRvIGdldF94dGlja2xhYmVscyBkb2Vzbid0CiAgICAgICAgICAgICMgcmV0dXJuIHRoZSBhY3R1YWwgbGFiZWxzLCBidXQgcmF0aGVyIHRoZWlyIHRpY2sgbG9jYXRpb25zLiBJIGNhbid0IGZpbmQgYSB3b3JrYXJvdW5kIGZvciB0aGlzLgogICAgICAgICAgICBpZiBhbGwobGFiZWwuc3RyaXAoKSA9PSAnJyBmb3IgbGFiZWwgaW4geF90aWNrX2xhYmVscyk6CiAgICAgICAgICAgICAgICB4X3RpY2tfbGFiZWxzID0gW3NlbGYuZm10X2Zsb2F0X3gocG9zKSBmb3IgcG9zIGluIHN1YnBsb3QuZ2V0X3h0aWNrcygpXQogICAgICAgICAgICB4X3RpY2tfbGFiZWxzID0gc2VsZi5pbl9yYW5nZSh4X3RpY2tfbGFiZWxzLCB4bGltKQogICAgICAgICAgICBwcmludCgnWC1heGlzIHRpY2sgbGFiZWxzOicpCiAgICAgICAgICAgIHByaW50KHNlbGYudGlja19sYWJlbF90ZXh0KHhfdGlja19sYWJlbHMpKQoKICAgICAgICBpZiBzZWxmLnBhcmFtc1snc2hvd195dGlja3MnXToKICAgICAgICAgICAgeV90aWNrcyA9IFtzZWxmLmZtdF9mbG9hdF95KHBvcykgZm9yIHBvcyBpbiBzdWJwbG90LmdldF95dGlja3MoKV0KICAgICAgICAgICAgcHJpbnQoJ1xuWS1heGlzIHRpY2tzIGF0ICcsICcsICcuam9pbih5X3RpY2tzKSkKCiAgICAgICAgaWYgc2VsZi5wYXJhbXNbJ3Nob3dfeXRpY2tsYWJlbHMnXToKICAgICAgICAgICAgeV90aWNrX2xhYmVscyA9IFtsYWJlbC5nZXRfdGV4dCgpIGZvciBsYWJlbCBpbiBzdWJwbG90LmdldF95dGlja2xhYmVscygpXQogICAgICAgICAgICBpZiBhbGwobGFiZWwuc3RyaXAoKSA9PSAnJyBmb3IgbGFiZWwgaW4geV90aWNrX2xhYmVscyk6CiAgICAgICAgICAgICAgICB5X3RpY2tfbGFiZWxzID0gW3NlbGYuZm10X2Zsb2F0X3kocG9zKSBmb3IgcG9zIGluIHN1YnBsb3QuZ2V0X3l0aWNrcygpXQogICAgICAgICAgICB5X3RpY2tfbGFiZWxzID0gc2VsZi5pbl9yYW5nZSh5X3RpY2tfbGFiZWxzLCB5bGltKQogICAgICAgICAgICBwcmludCgiXG5ZLWF4aXMgdGljayBsYWJlbHM6IikKICAgICAgICAgICAgcHJpbnQoc2VsZi50aWNrX2xhYmVsX3RleHQoeV90aWNrX2xhYmVscykpCgogICAgZGVmIHByaW50X2F4aXNfaW5mbyhzZWxmLCBzdWJwbG90KToKICAgICAgICAiIiJQcmludCB0aGUgYXhpcyBpbmZvIGZvciB0aGUgZ2l2ZW4gc3VicGxvdCIiIgoKICAgICAgICBwcmludCgiWC1heGlzIGxhYmVsOiAne30nIi5mb3JtYXQoc3VicGxvdC5nZXRfeGxhYmVsKCkpKQogICAgICAgIHByaW50KCJZLWF4aXMgbGFiZWw6ICd7fSciLmZvcm1hdChzdWJwbG90LmdldF95bGFiZWwoKSkpCiAgICAgICAgeGdyaWRsaW5lcyA9IHN1YnBsb3QuZ2V0X3hncmlkbGluZXMoKQogICAgICAgIHlncmlkbGluZXMgPSBzdWJwbG90LmdldF95Z3JpZGxpbmVzKCkKICAgICAgICBncmlkeF9vbiA9IGxlbih4Z3JpZGxpbmVzKSA+IDAgYW5kIGJvb2woeGdyaWRsaW5lc1swXS5nZXRfdmlzaWJsZSgpKQogICAgICAgIGdyaWR5X29uID0gbGVuKHlncmlkbGluZXMpID4gMCBhbmQgYm9vbCh5Z3JpZGxpbmVzWzBdLmdldF92aXNpYmxlKCkpCiAgICAgICAgcHJpbnQoZiIoeCwgeSkgZ3JpZCBsaW5lcyBlbmFibGVkOiAoe2dyaWR4X29ufSwge2dyaWR5X29ufSkiKQogICAgICAgIHhsaW0gPSBzdWJwbG90LmdldF94bGltKCkKICAgICAgICB5bGltID0gc3VicGxvdC5nZXRfeWxpbSgpCiAgICAgICAgaWYgc2VsZi5wYXJhbXNbJ3Nob3dfeGxpbSddOgogICAgICAgICAgICBwcmludChmIlgtYXhpcyBsaW1pdHM6IHtzZWxmLmZtdF9mbG9hdF9wYWlyKHhsaW0sIHByZWNpc2lvbj1zZWxmLnBhcmFtc1snZmxvYXRfcHJlY2lzaW9uJ11bMF0pfSIpCiAgICAgICAgaWYgc2VsZi5wYXJhbXNbJ3Nob3dfeWxpbSddOgogICAgICAgICAgICBwcmludChmIlktYXhpcyBsaW1pdHM6IHtzZWxmLmZtdF9mbG9hdF9wYWlyKHlsaW0sIHByZWNpc2lvbj1zZWxmLnBhcmFtc1snZmxvYXRfcHJlY2lzaW9uJ11bMV0pfSIpCiAgICAgICAgc2VsZi5wcmludF90aWNrcyhzdWJwbG90LCB4bGltLCB5bGltKQoKICAgICAgICBpZiBzdWJwbG90LmdldF9sZWdlbmQoKSBpcyBub3QgTm9uZToKICAgICAgICAgICAgcHJpbnQoZiJMZWdlbmQ6IFRydWUiKQogICAgICAgIHByaW50KCkKCiAgICBkZWYgcHJpbnRfc3VicGxvdF9pbmZvKHNlbGYsIGRhdGFfdHlwZSwgc3VicGxvdCwgdGl0bGUpOgogICAgICAgICIiIlByaW50IHRoZSBpbmZvIGZvciBhIHNpbmdsZSBnaXZlbiBzdWJwbG90LgogICAgICAgICAgIElmIHRoZSBkYXRhX3R5cGUgaXMgJ2xpbmVzJyBhbiBvcHRpb25hbCBwYXJhbWV0ZXIgeF9zYW1wbGVzCiAgICAgICAgICAgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB4IHZhbHVlcyBhdCB3aGljaCB0aGUgbGluZSBzaG91bGQgYmUgc2FtcGxlZC4KICAgICAgICAgICBJZiB0aGUgZGF0YV90eXBlIGlzIGxpbmVzLCB0aGUgeC10aWNrIGxhYmVscyBhcmUgc2hvd24gdW5sZXNzCiAgICAgICAgICAgdGhlIHNob3dfeHRpY2tsYWJlbHMgcGFyYW1ldGVycyBpcyBleHBsaWNpdGx5IHNldCB0byBGYWxzZS4KICAgICAgICAiIiIKICAgICAgICBpZiBub3Qgc2VsZi5wYXJhbXNbJ2xpbmVfaW5mb19vbmx5J106CiAgICAgICAgICAgIGlmIHNlbGYucGFyYW1zWydzaG93X3h0aWNrbGFiZWxzJ10gaXMgTm9uZSBhbmQgZGF0YV90eXBlID09ICdiYXJzJzoKICAgICAgICAgICAgICAgIHNlbGYucGFyYW1zWydzaG93X3h0aWNrbGFiZWxzJ10gPSBUcnVlCiAgICAgICAgICAgIGhhc19sZWdlbmQgPSBzdWJwbG90LmdldF9sZWdlbmQoKSBpcyBub3QgTm9uZQogICAgICAgICAgICBpZiBoYXNfbGVnZW5kIGFuZCBzZWxmLnBhcmFtc1snc2hvd19saW5lbGFiZWxzJ10gaXMgTm9uZToKICAgICAgICAgICAgICAgIHNlbGYucGFyYW1zWydzaG93X2xpbmVsYWJlbHMnXSA9IFRydWUKICAgICAgICAgICAgcHJpbnQoIlBsb3QgdGl0bGU6ICd7fSciLmZvcm1hdCh0aXRsZSkpCiAgICAgICAgICAgIHNlbGYucHJpbnRfYXhpc19pbmZvKHN1YnBsb3QpCgogICAgICAgIGlmIGRhdGFfdHlwZSA9PSAncG9pbnRzJzoKICAgICAgICAgICAgc2VsZi5wcmludF9saW5lcyhzdWJwbG90LCBOb25lKQogICAgICAgIGVsaWYgZGF0YV90eXBlID09ICdsaW5lcyc6CiAgICAgICAgICAgIHNlbGYucHJpbnRfbGluZXMoc3VicGxvdCwgc2VsZi5wYXJhbXNbJ3hfc2FtcGxlcyddKQogICAgICAgIGVsaWYgZGF0YV90eXBlID09ICdiYXJzJzoKICAgICAgICAgICAgc2VsZi5wcmludF9iYXJzKHN1YnBsb3QpCgogICAgZGVmIHByaW50X2luZm8oc2VsZiwgZGF0YV90eXBlKToKICAgICAgICAiIiJQcmludCBhbGwgdGhlIGluZm9ybWF0aW9uIGZvciB0aGUgY3VycmVudCBwbG90LiBkYXRhX3R5cGUKICAgICAgICAgICBtdXN0IGJlICdwb2ludHMnLCAnbGluZXMnIG9yICdiYXJzJy4KICAgICAgICAiIiIKICAgICAgICB0cnk6CiAgICAgICAgICAgIGF4ZXMgPSBwbHQuZ2NmKCkuZ2V0X2F4ZXMoKQogICAgICAgICAgICB0ZXh0cyA9IHBsdC5nY2YoKS50ZXh0cwogICAgICAgICAgICBpZiBub3Qgc2VsZi5wYXJhbXNbJ2xpbmVfaW5mb19vbmx5J106CiAgICAgICAgICAgICAgICBpZiBsZW4oYXhlcykgPiAxOgogICAgICAgICAgICAgICAgICAgIHByaW50KGYiRmlndXJlIGhhcyB7bGVuKGF4ZXMpfSBzdWJwbG90cyIpCiAgICAgICAgICAgICAgICBpZiBsZW4odGV4dHMpICE9IDA6CiAgICAgICAgICAgICAgICAgICAgcHJpbnQoZiJTdXB0aXRsZToge3RleHRzWzBdLmdldF90ZXh0KCl9XG4iKQogICAgICAgICAgICBmb3IgaSwgY3VycmVudF9heGVzIGluIGVudW1lcmF0ZShheGVzLCAxKToKICAgICAgICAgICAgICAgIGlmIGxlbihheGVzKSA+IDEgYW5kIG5vdCBzZWxmLnBhcmFtc1snbGluZV9pbmZvX29ubHknXToKICAgICAgICAgICAgICAgICAgICBwcmludChmIlN1YnBsb3Qge2l9XG4tLS0tLS0tLS0iKQogICAgICAgICAgICAgICAgc3VicGxvdCA9IGN1cnJlbnRfYXhlcy5heGVzCiAgICAgICAgICAgICAgICB0aXRsZSA9IGN1cnJlbnRfYXhlcy50aXRsZS5nZXRfdGV4dCgpCiAgICAgICAgICAgICAgICBzZWxmLnByaW50X3N1YnBsb3RfaW5mbyhkYXRhX3R5cGUsIHN1YnBsb3QsIHRpdGxlKQogICAgICAgICAgICAgICAgaWYgbGVuKGF4ZXMpID4gMSBhbmQgbm90IHNlbGYucGFyYW1zWydsaW5lX2luZm9fb25seSddOgogICAgICAgICAgICAgICAgICAgIHByaW50KDQwICogIj0iKQogICAgICAgICAgICAgICAgICAgIHByaW50KCkKCiAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgICAgICBwcmludCgiRmFpbGVkIHRvIGdldCBwbG90IGluZm86IiwgcmVwcihlKSkKICAgICAgICAgICAgdHJhY2ViYWNrLnByaW50X2V4Y2VwdGlvbihlKQoKCmRlZiBwcmludF9wbG90X2luZm8oZGF0YV90eXBlLCAqKmt3cGFyYW1zKToKICAgICIiIk91dHB1dCBrZXkgYXR0cmlidXRlcyBvZiBjdXJyZW50IHBsb3QsIGFzIGRlZmluZWQgYnkgcGx0LmdjYSgpLgogICAgICAgZGF0YV90eXBlIG11c3QgYmUgb25lIG9mICdwb2ludHMnLCAnbGluZXMnIG9yICdiYXJzJywgdG8gcHJpbnQgdGhlCiAgICAgICBhcHByb3ByaWF0ZSB0eXBlIG9mIGRhdGEuCiAgICAgICBGb3IgdmFsdWVzIG9mIHBvc3NpYmxlIGtleXdvcmQgcGFyYW1ldGVycyBzZWUgREVGQVVMVF9QQVJBTVMgZGVjbGFyYXRpb24KICAgICIiIgoKICAgIHVua25vd25fcGFyYW1zID0gc2V0KGt3cGFyYW1zKSAtIHNldChERUZBVUxUX1BBUkFNUykKICAgIGlmIHVua25vd25fcGFyYW1zOgogICAgICAgIHByaW50KGYiVW5rbm93biBwYXJhbWV0ZXIocykgcGFzc2VkIHRvIHByaW50X3Bsb3RfaW5mbzogeycsICcuam9pbih1bmtub3duX3BhcmFtcyl9IikKICAgICAgICByZXR1cm4KCiAgICBjaGVja2VyID0gUGxvdENoZWNrZXIoa3dwYXJhbXMpCiAgICBjaGVja2VyLnByaW50X2luZm8oZGF0YV90eXBlKQo=</file>
<file name="__pystylechecker.py" path="/" encoding="base64">IiIiQWxsIHRoZSBzdHlsZSBjaGVja2luZyBjb2RlIGZvciBQeXRob24zIiIiCgpmcm9tIGlvIGltcG9ydCBCeXRlc0lPCmltcG9ydCBvcwppbXBvcnQgc3VicHJvY2VzcwppbXBvcnQgYXN0CmltcG9ydCB0b2tlbml6ZQppbXBvcnQgdG9rZW4KaW1wb3J0IHJlCmltcG9ydCBzaHV0aWwKZnJvbSBjb2xsZWN0aW9ucyBpbXBvcnQgZGVmYXVsdGRpY3QKCmNsYXNzIFN0eWxlQ2hlY2tlcjoKICAgIGRlZiBfX2luaXRfXyhzZWxmLCBwcmVsdWRlLCBzdHVkZW50X2Fuc3dlciwgcGFyYW1zKToKICAgICAgICBzZWxmLnByZWx1ZGUgPSBwcmVsdWRlCiAgICAgICAgc2VsZi5zdHVkZW50X2Fuc3dlciA9IHN0dWRlbnRfYW5zd2VyCiAgICAgICAgc2VsZi5wYXJhbXMgPSBwYXJhbXMKICAgICAgICBzZWxmLmZ1bmN0aW9uX2NhbGxfbWFwID0gTm9uZQogICAgICAgIHNlbGYuX3RyZWUgPSBOb25lCgogICAgQHByb3BlcnR5CiAgICBkZWYgdHJlZShzZWxmKToKICAgICAgICBpZiBzZWxmLl90cmVlIGlzIE5vbmU6CiAgICAgICAgICAgIHNlbGYuX3RyZWUgPSBhc3QucGFyc2Uoc2VsZi5zdHVkZW50X2Fuc3dlcikKICAgICAgICByZXR1cm4gc2VsZi5fdHJlZQoKICAgIGRlZiBzdHlsZV9lcnJvcnMoc2VsZik6CiAgICAgICAgIiIiUmV0dXJuIGEgbGlzdCBvZiBlcnJvcnMgZnJvbSBsb2NhbCBzdHlsZSBjaGVja3MgcGx1cyBweWxpbnQgYW5kL29yIG15cHkKICAgICAgICAiIiIKICAgICAgICBlcnJvcnMgPSBbXQogICAgICAgIHNvdXJjZSA9IG9wZW4oJ19fc291cmNlLnB5JywgJ3cnLCBlbmNvZGluZz0idXRmLTgiKQogICAgICAgIGNvZGVfdG9fY2hlY2sgPSBzZWxmLnByZWx1ZGUgKyBzZWxmLnN0dWRlbnRfYW5zd2VyCiAgICAgICAgcHJlbHVkZV9sZW4gPSBsZW4oc2VsZi5wcmVsdWRlLnNwbGl0bGluZXMoKSkKICAgICAgICBzb3VyY2Uud3JpdGUoY29kZV90b19jaGVjaykKICAgICAgICBzb3VyY2UuY2xvc2UoKQogICAgICAgIGVudiA9IG9zLmVudmlyb24uY29weSgpCiAgICAgICAgZW52WydIT01FJ10gPSBvcy5nZXRjd2QoKQogICAgICAgIHB5bGludF9vcHRzID0gc2VsZi5wYXJhbXMuZ2V0KCdweWxpbnRvcHRpb25zJyxbXSkKICAgICAgICBwcmVjaGVja2VycyA9IHNlbGYucGFyYW1zLmdldCgncHJlY2hlY2tlcnMnLCBbJ3B5bGludCddKQogICAgICAgIHJlc3VsdCA9ICcnCgogICAgICAgIGlmICdweWxpbnQnIGluIHByZWNoZWNrZXJzOgogICAgICAgICAgICB0cnk6ICAjIFJ1biBweWxpbnQKICAgICAgICAgICAgICAgIGNtZCA9ICdweXRob24zLjEwIC1tIHB5bGludCAnICsgJyAnLmpvaW4ocHlsaW50X29wdHMpICsgJyBfX3NvdXJjZS5weScKICAgICAgICAgICAgICAgIHJlc3VsdCA9IHN1YnByb2Nlc3MuY2hlY2tfb3V0cHV0KGNtZCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RkZXJyPXN1YnByb2Nlc3MuU1RET1VULAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bml2ZXJzYWxfbmV3bGluZXM9VHJ1ZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW52PWVudiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hlbGw9VHJ1ZSkKICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgICAgICAgICAgcmVzdWx0ID0gZS5vdXRwdXQKICAgICAgICAgICAgICAgIAogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgIyAobWN0NjMpIEFib3J0IGlmIHRoZXJlIGFyZSBhbnkgY29tbWVudHMgY29udGFpbmluZyAncHlsaW50OicuCiAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgdG9rZW5pemVyID0gdG9rZW5pemUudG9rZW5pemUoQnl0ZXNJTyhzZWxmLnN0dWRlbnRfYW5zd2VyLmVuY29kZSgndXRmLTgnKSkucmVhZGxpbmUpCiAgICAgICAgICAgICAgICAgICAgZm9yIHRva2VuX3R5cGUsIHRva2VuX3RleHQsICpfIGluIHRva2VuaXplcjoKICAgICAgICAgICAgICAgICAgICAgICAgaWYgdG9rZW5fdHlwZSA9PSB0b2tlbml6ZS5DT01NRU5UIGFuZCAncHlsaW50OicgaW4gdG9rZW5fdGV4dDoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5hcHBlbmQoIkNvbW1lbnRzIGNhbiBub3QgaW5jbHVkZSAncHlsaW50OiciKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsKICAgICAgICAKICAgICAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLmFwcGVuZCgiU29tZXRoaW5nIHdlbnQgd3Jvbmcgd2hpbGUgcGFyc2luZyBjb21tZW50cy4gUmVwb3J0IHRoaXMuIikKCiAgICAgICAgICAgIGlmICJVc2luZyBjb25maWcgZmlsZSIgaW4gcmVzdWx0OgogICAgICAgICAgICAgICAgcmVzdWx0ID0gJ1xuJy5qb2luKHJlc3VsdC5zcGxpdGxpbmVzKClbMTpdKS5zcGxpdCgpCgogICAgICAgIGlmIHJlc3VsdCA9PSAnJyBhbmQgJ215cHknIGluIHByZWNoZWNrZXJzOgogICAgICAgICAgICBjb2RlX3RvX2NoZWNrID0gJ2Zyb20gdHlwaW5nIGltcG9ydCBMaXN0IGFzIGxpc3QsIERpY3QgYXMgZGljdCwgVHVwbGUgYXMgdHVwbGUsIFNldCBhcyBzZXQsIEFueVxuJyArIGNvZGVfdG9fY2hlY2sKICAgICAgICAgICAgd2l0aCBvcGVuKCdfX3NvdXJjZTIucHknLCAndycsIGVuY29kaW5nPSd1dGYtOCcpIGFzIG91dGZpbGU6CiAgICAgICAgICAgICAgICBvdXRmaWxlLndyaXRlKGNvZGVfdG9fY2hlY2spCiAgICAgICAgICAgIGNtZCA9ICdweXRob24zLjEwIC1tIG15cHkgLS1uby1lcnJvci1zdW1tYXJ5IC0tbm8tc3RyaWN0LW9wdGlvbmFsIF9fc291cmNlMi5weScKICAgICAgICAgICAgdHJ5OiAjIFJ1biBteXB5CiAgICAgICAgICAgICAgICBzdWJwcm9jZXNzLmNoZWNrX291dHB1dChjbWQsICAjIFJhaXNlcyBhbiBleGNlcHRpb24gaWYgdGhlcmUgYXJlIGVycm9ycwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RkZXJyPXN1YnByb2Nlc3MuU1RET1VULAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pdmVyc2FsX25ld2xpbmVzPVRydWUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnY9ZW52LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hlbGw9VHJ1ZSkKICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgICAgICAgICAgcmVzdWx0ID0gZS5vdXRwdXQKICAgICAgICAgICAgICAgIGxpbmVfbnVtX2ZpeCA9IGxhbWJkYSBtYXRjaDogIkxpbmUgIiArIHN0cihpbnQobWF0Y2hbMV0pIC0gMSAtIHByZWx1ZGVfbGVuKSArIG1hdGNoWzJdCiAgICAgICAgICAgICAgICByZXN1bHQgPSByZS5zdWIocidfX3NvdXJjZTIucHk6KFxkKykoLiopJywgbGluZV9udW1fZml4LCByZXN1bHQpCgogICAgICAgIGlmIHJlc3VsdCA9PSAnJyBhbmQgc2VsZi5wYXJhbXMuZ2V0KCdyZXF1aXJldHlwZWhpbnRzJywgRmFsc2UpOgogICAgICAgICAgICBiYWRfZnVuY3MgPSBzZWxmLmNoZWNrX3R5cGVfaGludHMoKQogICAgICAgICAgICBmb3IgZnVuIGluIGJhZF9mdW5jczoKICAgICAgICAgICAgICAgIHJlc3VsdCArPSBmIkZ1bmN0aW9uICd7ZnVufScgZG9lcyBub3QgaGF2ZSBjb3JyZWN0IHR5cGUgaGludHNcbiIKCiAgICAgICAgaWYgcmVzdWx0OgogICAgICAgICAgICBlcnJvcnMgPSByZXN1bHQuc3RyaXAoKS5zcGxpdGxpbmVzKCkKCiAgICAgICAgcmV0dXJuIGVycm9ycwogICAgCiAgICBkZWYgcHJldHRpZWQoc2VsZiwgY29uc3RydWN0KToKICAgICAgICAiIiJFeHBhbmQsIGlmIHBvc3NpYmxlLCB0aGUgbmFtZSBvZiB0aGUgZ2l2ZW4gUHl0aG9uIGNvbnN0cnVjdCB0byBhIG1vcmUKICAgICAgICAgICB1c2VyIGZyaWVuZGx5IHZlcnNpb24sIGUuZy4gJ2xpc3Rjb21wcmVoZW5zaW9uJyAtPiAnbGlzdCBjb21wcmVoZW5zaW9uJwogICAgICAgICIiIgogICAgICAgIGV4cGFuZGVkID0gewogICAgICAgICAgICAnbGlzdGNvbXByZWhlbnNpb24nOiAnbGlzdCBjb21wcmVoZW5zaW9uJywKICAgICAgICAgICAgJ3doaWxlJzogJ3doaWxlIGxvb3AnLAogICAgICAgICAgICAnZm9yJzogJ2ZvciBsb29wJywKICAgICAgICAgICAgJ3RyeSc6ICd0cnkgLi4uIGV4Y2VwdCBzdGF0ZW1lbnQnLAogICAgICAgICAgICAnZGljdGNvbXByZWhlbnNpb24nOiAnZGljdGlvbmFyeSBjb21wcmVoZW5zaW9uJywKICAgICAgICAgICAgJ3NsaWNlJzogJ3NsaWNlJwogICAgICAgIH0KICAgICAgICBpZiBjb25zdHJ1Y3QgaW4gZXhwYW5kZWQ6CiAgICAgICAgICAgIHJldHVybiBleHBhbmRlZFtjb25zdHJ1Y3RdCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcmV0dXJuIGYie2NvbnN0cnVjdH0gc3RhdGVtZW50IgoKICAgIGRlZiBsb2NhbF9lcnJvcnMoc2VsZik6CiAgICAgICAgIiIiUGVyZm9ybSB2YXJpb3VzIGxvY2FsIGNoZWNrcyBhcyBzcGVjaWZpZWQgYnkgdGhlIGN1cnJlbnQgc2V0IG9mCiAgICAgICAgICAgdGVtcGxhdGUgcGFyYW1ldGVycy4KICAgICAgICAiIiIKICAgICAgICBlcnJvcnMgPSBbXQoKICAgICAgICBmb3IgYmFubmVkIGluIHNlbGYucGFyYW1zLmdldCgncHJvc2NyaWJlZHN1YnN0cmluZ3MnLCBbXSk6CiAgICAgICAgICAgIGlmIGJhbm5lZCBpbiBzZWxmLnN0dWRlbnRfYW5zd2VyOgogICAgICAgICAgICAgICAgZXJyb3JzLmFwcGVuZChmIlRoZSBzdHJpbmcgJ3tiYW5uZWR9JyBpcyBub3QgcGVybWl0dGVkIGFueXdoZXJlIGluIHlvdXIgY29kZS4iKQoKICAgICAgICBmb3IgcmVxdWlyZWQgaW4gc2VsZi5wYXJhbXMuZ2V0KCdyZXF1aXJlZHN1YnN0cmluZ3MnLCBbXSk6CiAgICAgICAgICAgIGlmIGlzaW5zdGFuY2UocmVxdWlyZWQsIHN0cikgYW5kIHJlcXVpcmVkIG5vdCBpbiBzZWxmLnN0dWRlbnRfYW5zd2VyOgogICAgICAgICAgICAgICAgZXJyb3JzLmFwcGVuZChmJ1RoZSBzdHJpbmcgIntyZXF1aXJlZH0iIG11c3Qgb2NjdXIgc29tZXdoZXJlIGluIHlvdXIgY29kZS4nKQogICAgICAgICAgICBlbGlmIGlzaW5zdGFuY2UocmVxdWlyZWQsIGRpY3QpOiAKICAgICAgICAgICAgICAgIGlmICdwYXR0ZXJuJyBpbiByZXF1aXJlZCBhbmQgbm90IHJlLmZpbmRhbGwocmVxdWlyZWRbJ3BhdHRlcm4nXSwgc2VsZi5zdHVkZW50X2Fuc3dlcik6CiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLmFwcGVuZChyZXF1aXJlZFsnZXJyb3JtZXNzYWdlJ10pCiAgICAgICAgICAgICAgICBlbGlmICdzdHJpbmcnIGluIHJlcXVpcmVkIGFuZCByZXF1aXJlZFsnc3RyaW5nJ10gbm90IGluIHNlbGYuc3R1ZGVudF9hbnN3ZXI6CiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLmFwcGVuZChyZXF1aXJlZFsnZXJyb3JtZXNzYWdlJ10pCgogICAgICAgIGlmIHNlbGYucGFyYW1zLmdldCgnYmFuZ2xvYmFsY29kZScsIFRydWUpOgogICAgICAgICAgICBlcnJvcnMgKz0gc2VsZi5maW5kX2dsb2JhbF9jb2RlKCkKCiAgICAgICAgaWYgbm90IHNlbGYucGFyYW1zLmdldCgnYWxsb3duZXN0ZWRmdW5jdGlvbnMnLCBUcnVlKToKICAgICAgICAgICAgIyBFeGNlcHQgZm9yIGxlZ2FjeSBxdWVzdGlvbnMgb3Igd2hlcmUgZXhwbGljaXRseSBhbGxvd2VkLCBuZXN0ZWQgZnVuY3Rpb25zIGFyZSBiYW5uZWQKICAgICAgICAgICAgbmVzdGVkX2Z1bmNzID0gc2VsZi5maW5kX25lc3RlZF9mdW5jdGlvbnMoKQogICAgICAgICAgICBmb3IgZnVuYyBpbiBuZXN0ZWRfZnVuY3M6CiAgICAgICAgICAgICAgICBlcnJvcnMuYXBwZW5kKCJGdW5jdGlvbiAne30nIGlzIGRlZmluZWQgaW5zaWRlIGFub3RoZXIgZnVuY3Rpb24iLmZvcm1hdChmdW5jKSkKCiAgICAgICAgbWF4X2xlbmd0aCA9IHNlbGYucGFyYW1zWydtYXhmdW5jdGlvbmxlbmd0aCddCiAgICAgICAgYmFkX2Z1bmNzID0gc2VsZi5maW5kX3Rvb19sb25nX2Z1bmNzKG1heF9sZW5ndGgpCiAgICAgICAgZm9yIGZ1bmMsIGNvdW50IGluIGJhZF9mdW5jczoKICAgICAgICAgICAgZXJyb3JzLmFwcGVuZCgiRnVuY3Rpb24gJ3t9JyBpcyB0b28gbG9uZ1xuKHt9IHN0YXRlbWVudHMsIG1heCBpcyB7fSkiCiAgICAgICAgICAgICAgICAgICAgICAgICAgIiIuZm9ybWF0KGZ1bmMsIGNvdW50LCBtYXhfbGVuZ3RoKSkKCiAgICAgICAgYmFkX3VzZWQgPSBzZWxmLmZpbmRfaWxsZWdhbF9mdW5jdGlvbnMoKQogICAgICAgIGZvciBuYW1lIGluIGJhZF91c2VkOgogICAgICAgICAgICBlcnJvcnMuYXBwZW5kKCJZb3UgY2FsbGVkIHRoZSBiYW5uZWQgZnVuY3Rpb24gJ3t9Jy4iLmZvcm1hdChuYW1lKSkKCiAgICAgICAgbWlzc2luZ19mdW5jcyA9IHNlbGYuZmluZF9taXNzaW5nX3JlcXVpcmVkX2Z1bmN0aW9uX2NhbGxzKCkKICAgICAgICBmb3IgbmFtZSBpbiBtaXNzaW5nX2Z1bmNzOgogICAgICAgICAgICBlcnJvcnMuYXBwZW5kKCJZb3UgZm9yZ290IHRvIHVzZSB0aGUgcmVxdWlyZWQgZnVuY3Rpb24gJ3t9Jy4iLmZvcm1hdChuYW1lKSkKCiAgICAgICAgbWlzc2luZ19mdW5jcyA9IHNlbGYuZmluZF9taXNzaW5nX3JlcXVpcmVkX2Z1bmN0aW9uX2RlZmluaXRpb25zKCkKICAgICAgICBmb3IgbmFtZSBpbiBtaXNzaW5nX2Z1bmNzOgogICAgICAgICAgICBlcnJvcnMuYXBwZW5kKCJZb3UgZm9yZ290IHRvIGRlZmluZSB0aGUgcmVxdWlyZWQgZnVuY3Rpb24gJ3t9Jy4iLmZvcm1hdChuYW1lKSkKCiAgICAgICAgbWlzc2luZ19jb25zdHJ1Y3RzID0gc2VsZi5maW5kX21pc3NpbmdfcmVxdWlyZWRfY29uc3RydWN0cygpCiAgICAgICAgZm9yIHJlcWQgaW4gbWlzc2luZ19jb25zdHJ1Y3RzOgogICAgICAgICAgICBleHBhbmRlZCA9IHNlbGYucHJldHRpZWQocmVxZCkKICAgICAgICAgICAgZXJyb3JzLmFwcGVuZChmIllvdXIgcHJvZ3JhbSBtdXN0IGluY2x1ZGUgYXQgbGVhc3Qgb25lIHtleHBhbmRlZH0uIikKCiAgICAgICAgYmFkX2NvbnN0cnVjdHMgPSBzZWxmLmZpbmRfaWxsZWdhbF9jb25zdHJ1Y3RzKCkKICAgICAgICBmb3Igbm90YWxsb3dlZCBpbiBiYWRfY29uc3RydWN0czoKICAgICAgICAgICAgZXhwYW5kZWQgPSBzZWxmLnByZXR0aWVkKG5vdGFsbG93ZWQpCiAgICAgICAgICAgIGVycm9ycy5hcHBlbmQoZiJZb3VyIHByb2dyYW0gbXVzdCBub3QgaW5jbHVkZSBhbnkge2V4cGFuZGVkfXMuIikKCiAgICAgICAgbnVtX2NvbnN0YW50cyA9IGxlbihbbGluZSBmb3IgbGluZSBpbiBzZWxmLnN0dWRlbnRfYW5zd2VyLnNwbGl0KCdcbicpIGlmIHJlLm1hdGNoKCcgKltBLVpfXVtBLVpfMC05XSogKj0nLCBsaW5lKV0pCiAgICAgICAgaWYgbnVtX2NvbnN0YW50cyA+IHNlbGYucGFyYW1zWydtYXhudW1jb25zdGFudHMnXToKICAgICAgICAgICAgZXJyb3JzLmFwcGVuZCgiWW91IG1heSBub3QgdXNlIG1vcmUgdGhhbiAiICsgc3RyKHNlbGYucGFyYW1zWydtYXhudW1jb25zdGFudHMnXSkgKyAiIGNvbnN0YW50cy4iKQoKICAgICAgICAjIChtY3Q2MykgQ2hlY2sgaWYgYW55dGhpbmcgcmVzdHJpY3RlZCBpcyBiZWluZyBpbXBvcnRlZC4KICAgICAgICBpZiAncmVzdHJpY3RlZG1vZHVsZXMnIGluIHNlbGYucGFyYW1zOgogICAgICAgICAgICByZXN0cmljdGVkID0gc2VsZi5wYXJhbXNbJ3Jlc3RyaWN0ZWRtb2R1bGVzJ10KICAgICAgICAgICAgZm9yIGltcG9ydF9uYW1lLCBuYW1lcyBpbiBzZWxmLmZpbmRfYWxsX2ltcG9ydHMoKS5pdGVtcygpOgogICAgICAgICAgICAgICAgaWYgaW1wb3J0X25hbWUgaW4gcmVzdHJpY3RlZDoKICAgICAgICAgICAgICAgICAgICBpZiByZXN0cmljdGVkW2ltcG9ydF9uYW1lXS5nZXQoJ29ubHlhbGxvdycsIE5vbmUpID09IFtdOgogICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMuYXBwZW5kKCJZb3VyIHByb2dyYW0gc2hvdWxkIG5vdCBpbXBvcnQgYW55dGhpbmcgZnJvbSAne30nLiIuZm9ybWF0KGltcG9ydF9uYW1lKSkKICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICBmb3IgbmFtZSBpbiBuYW1lczoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoJ29ubHlhbGxvdycgaW4gcmVzdHJpY3RlZFtpbXBvcnRfbmFtZV0gYW5kIG5hbWUgbm90IGluIHJlc3RyaWN0ZWRbaW1wb3J0X25hbWVdWydvbmx5YWxsb3cnXSkgb3IKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSBpbiByZXN0cmljdGVkW2ltcG9ydF9uYW1lXS5nZXQoJ2Rpc2FsbG93JywgW10pKToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMuYXBwZW5kKCJZb3VyIHByb2dyYW0gc2hvdWxkIG5vdCBpbXBvcnQgJ3t9JyBmcm9tICd7fScuIi5mb3JtYXQobmFtZSwgaW1wb3J0X25hbWUpKQoKICAgICAgICByZXR1cm4gZXJyb3JzCgogICAgZGVmIGZpbmRfYWxsX2ltcG9ydHMoc2VsZik6CiAgICAgICAgIiIiUmV0dXJucyBhIGRpY3Rpb25hcnkgbWFwcGluZyBpbiB3aGljaCB0aGUga2V5cyBhcmUgYWxsIG1vZHVsZXMKICAgICAgICAgICBiZWluZyBpbXBvcnRlZCBhbmQgdGhlIHZhbHVlcyBhcmUgYSBsaXN0IG9mIHdoYXQgdGhpbmdzIHdpdGhpbgogICAgICAgICAgIHRoZSBtb2R1bGUgYXJlIGJlaW5nIG1vZHVsZXMuIEFuIGVtcHR5IGxpc3QgaW5kaWNhdGVzIHRoZSBlbnRpcmUKICAgICAgICAgICBtb2R1bGUgaXMgaW1wb3J0ZWQuIiIiCiAgICAgICAgZm91bmRfaW1wb3J0cyA9IHt9CiAgICAgICAgY2xhc3MgSW1wb3J0RmluZGVyKGFzdC5Ob2RlVmlzaXRvcik6CiAgICAgICAgICAgIGRlZiB2aXNpdF9JbXBvcnQoc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBmb3IgYWxpYXMgaW4gbm9kZS5uYW1lczoKICAgICAgICAgICAgICAgICAgICBpZiBhbGlhcy5uYW1lIG5vdCBpbiBmb3VuZF9pbXBvcnRzOgogICAgICAgICAgICAgICAgICAgICAgICBmb3VuZF9pbXBvcnRzW2FsaWFzLm5hbWVdID0gW10KICAgICAgICAgICAgICAgIHNlbGYuZ2VuZXJpY192aXNpdChub2RlKQogICAgICAgICAgICBkZWYgdmlzaXRfSW1wb3J0RnJvbShzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGlmIG5vZGUubW9kdWxlIG5vdCBpbiBmb3VuZF9pbXBvcnRzOgogICAgICAgICAgICAgICAgICAgIGZvdW5kX2ltcG9ydHNbbm9kZS5tb2R1bGVdID0gW10KICAgICAgICAgICAgICAgIGZvciBhbGlhcyBpbiBub2RlLm5hbWVzOgogICAgICAgICAgICAgICAgICAgIGZvdW5kX2ltcG9ydHNbbm9kZS5tb2R1bGVdLmFwcGVuZChhbGlhcy5uYW1lKQogICAgICAgICAgICAgICAgc2VsZi5nZW5lcmljX3Zpc2l0KG5vZGUpCgogICAgICAgIHZpc2l0b3IgPSBJbXBvcnRGaW5kZXIoKQogICAgICAgIHZpc2l0b3IudmlzaXQoc2VsZi50cmVlKQogICAgICAgIHJldHVybiBmb3VuZF9pbXBvcnRzCgogICAgZGVmIGZpbmRfYWxsX2Z1bmN0aW9uX2NhbGxzKHNlbGYpOgogICAgICAgICIiIlJldHVybiBhIGRpY3Rpb25hcnkgbWFwcGluZyBpbiB3aGljaCB0aGUga2V5cyBhcmUgYWxsIGZ1bmN0aW9ucwogICAgICAgICAgIGNhbGxlZCBieSB0aGUgc291cmNlIGNvZGUgYW5kIHZhbHVlcyBhcmUgYSBsaXN0IG9mCiAgICAgICAgICAgKGxpbmVfbnVtYmVyLCBuZXN0aW5nX2RlcHRoKSB0dXBsZXMuIiIiCiAgICAgICAgY2xhc3MgRnVuY0ZpbmRlcihhc3QuTm9kZVZpc2l0b3IpOgoKICAgICAgICAgICAgZGVmIF9faW5pdF9fKHNlbGYsICphcmdzLCAqKmt3YXJncyk6CiAgICAgICAgICAgICAgICBzZWxmLmRlcHRoID0gMAogICAgICAgICAgICAgICAgc2VsZi5mb3VuZF9mdW5jcyA9IGRlZmF1bHRkaWN0KGxpc3QpCiAgICAgICAgICAgICAgICBzdXBlcigpLl9faW5pdF9fKCphcmdzLCAqKmt3YXJncykKCiAgICAgICAgICAgIGRlZiB2aXNpdF9GdW5jdGlvbkRlZihzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgICIiIiBFdmVyeSB0aW1lIHdlIGVudGVyIGEgZnVuY3Rpb24sIHdlIGdldCAnZGVlcGVyJyBpbnRvIHRoZSBjb2RlLgogICAgICAgICAgICAgICAgICAgIFdlIHdhbnQgdG8gbm90ZSBob3cgZGVlcCBhIGZ1bmN0aW9uIGlzIHdoZW4gd2UgZmluZCBpdHMgY2FsbC4iIiIKICAgICAgICAgICAgICAgIHNlbGYuZGVwdGggKz0gMQogICAgICAgICAgICAgICAgc2VsZi5nZW5lcmljX3Zpc2l0KG5vZGUpCiAgICAgICAgICAgICAgICBzZWxmLmRlcHRoIC09IDEKCiAgICAgICAgICAgIGRlZiB2aXNpdF9DYWxsKHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgIiIiQSBmdW5jdGlvbiBoYXMgYmVlbiBjYWxsZWQsIHNvIGNoZWNrIGl0cyBuYW1lCiAgICAgICAgICAgICAgICAgICBhZ2FpbnN0IHRoZSBnaXZlbiBvbmUuIiIiCiAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgaWYgJ2lkJyBpbiBkaXIobm9kZS5mdW5jKToKICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG5vZGUuZnVuYy5pZAogICAgICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBub2RlLmZ1bmMuYXR0cgogICAgICAgICAgICAgICAgICAgICMgTGluZSBudW1iZXJzIGFyZSAxLWluZGV4ZWQsIHNvIGRlY3JlbWVudCBieSAxCiAgICAgICAgICAgICAgICAgICAgc2VsZi5mb3VuZF9mdW5jc1tuYW1lXS5hcHBlbmQoKG5vZGUubGluZW5vIC0gMSwgc2VsZi5kZXB0aCkpCiAgICAgICAgICAgICAgICBleGNlcHQgQXR0cmlidXRlRXJyb3I6CiAgICAgICAgICAgICAgICAgICAgcGFzcyAgIyBlaXRoZXIgbm90IGNhbGxpbmcgYSBmdW5jdGlvbiAoPz8pIG9yIGl0J3Mgbm90IG5hbWVkLgogICAgICAgICAgICAgICAgc2VsZi5nZW5lcmljX3Zpc2l0KG5vZGUpCgogICAgICAgIGlmIHNlbGYuZnVuY3Rpb25fY2FsbF9tYXAgaXMgTm9uZToKICAgICAgICAgICAgdmlzaXRvciA9IEZ1bmNGaW5kZXIoKQogICAgICAgICAgICB2aXNpdG9yLnZpc2l0KHNlbGYudHJlZSkKICAgICAgICAgICAgc2VsZi5mdW5jdGlvbl9jYWxsX21hcCA9IHZpc2l0b3IuZm91bmRfZnVuY3MKICAgICAgICByZXR1cm4gc2VsZi5mdW5jdGlvbl9jYWxsX21hcAoKCiAgICBkZWYgZmluZF9kZWZpbmVkX2Z1bmN0aW9ucyhzZWxmKToKICAgICAgICAiIiJGaW5kIGFsbCB0aGUgZnVuY3Rpb25zIGRlZmluZWQuIiIiCiAgICAgICAgZGVmaW5lZCA9IHNldCgpCiAgICAgICAgY2xhc3MgRnVuY0ZpbmRlcihhc3QuTm9kZVZpc2l0b3IpOgoKICAgICAgICAgICAgZGVmIF9faW5pdF9fKHNlbGYpOgogICAgICAgICAgICAgICAgc2VsZi5wcmVmaXggPSAnJwoKICAgICAgICAgICAgZGVmIHZpc2l0X0NsYXNzRGVmKHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgb2xkX3ByZWZpeCA9IHNlbGYucHJlZml4CiAgICAgICAgICAgICAgICBzZWxmLnByZWZpeCArPSBub2RlLm5hbWUgKyAnLicKICAgICAgICAgICAgICAgIHNlbGYuZ2VuZXJpY192aXNpdChub2RlKQogICAgICAgICAgICAgICAgc2VsZi5wcmVmaXggPSBvbGRfcHJlZml4CgogICAgICAgICAgICBkZWYgdmlzaXRfRnVuY3Rpb25EZWYoc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBkZWZpbmVkLmFkZChzZWxmLnByZWZpeCArIG5vZGUubmFtZSkKICAgICAgICAgICAgICAgIG9sZF9wcmVmaXggPSBzZWxmLnByZWZpeAogICAgICAgICAgICAgICAgc2VsZi5wcmVmaXggKz0gbm9kZS5uYW1lICsgJy4nCiAgICAgICAgICAgICAgICBzZWxmLmdlbmVyaWNfdmlzaXQobm9kZSkKICAgICAgICAgICAgICAgIHNlbGYucHJlZml4ID0gb2xkX3ByZWZpeAoKICAgICAgICAgICAgZGVmIHZpc2l0X0FzeW5jRnVuY3Rpb25EZWYoc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBzZWxmLnZpc2l0X0Z1bmN0aW9uRGVmKG5vZGUpCgogICAgICAgIHZpc2l0b3IgPSBGdW5jRmluZGVyKCkKICAgICAgICB2aXNpdG9yLnZpc2l0KHNlbGYudHJlZSkKICAgICAgICByZXR1cm4gZGVmaW5lZAoKCiAgICBkZWYgY29uc3RydWN0c191c2VkKHNlbGYpOgogICAgICAgICIiIlJldHVybiBhIHNldCBvZiBhbGwgY29uc3RydWN0cyBlbmNvdW50ZXJlZCBpbiB0aGUgcGFyc2UgdHJlZSIiIgogICAgICAgIGNvbnN0cnVjdHNfc2VlbiA9IHNldCgpCiAgICAgICAgY2xhc3MgQ29uc3RydWN0RmluZGVyKGFzdC5Ob2RlVmlzaXRvcik6CiAgICAgICAgICAgIGRlZiB2aXNpdF9Bc3NlcnQoc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RzX3NlZW4uYWRkKCdhc3NlcnQnKQogICAgICAgICAgICAgICAgc2VsZi5nZW5lcmljX3Zpc2l0KG5vZGUpCiAgICAgICAgICAgIGRlZiB2aXNpdF9SYWlzZShzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGNvbnN0cnVjdHNfc2Vlbi5hZGQoJ3JhaXNlJykKICAgICAgICAgICAgICAgIHNlbGYuZ2VuZXJpY192aXNpdChub2RlKQogICAgICAgICAgICBkZWYgdmlzaXRfTGFtYmRhKHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgY29uc3RydWN0c19zZWVuLmFkZCgnbGFtYmRhJykKICAgICAgICAgICAgICAgIHNlbGYuZ2VuZXJpY192aXNpdChub2RlKQogICAgICAgICAgICBkZWYgdmlzaXRfSW1wb3J0KHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgY29uc3RydWN0c19zZWVuLmFkZCgnaW1wb3J0JykKICAgICAgICAgICAgICAgIHNlbGYuZ2VuZXJpY192aXNpdChub2RlKQogICAgICAgICAgICBkZWYgdmlzaXRfSW1wb3J0RnJvbShzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGNvbnN0cnVjdHNfc2Vlbi5hZGQoJ2ltcG9ydCcpCiAgICAgICAgICAgICAgICBzZWxmLmdlbmVyaWNfdmlzaXQobm9kZSkKICAgICAgICAgICAgZGVmIHZpc2l0X0ZvcihzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGNvbnN0cnVjdHNfc2Vlbi5hZGQoJ2ZvcicpCiAgICAgICAgICAgICAgICBzZWxmLmdlbmVyaWNfdmlzaXQobm9kZSkKICAgICAgICAgICAgZGVmIHZpc2l0X1doaWxlKHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgY29uc3RydWN0c19zZWVuLmFkZCgnd2hpbGUnKQogICAgICAgICAgICAgICAgc2VsZi5nZW5lcmljX3Zpc2l0KG5vZGUpCiAgICAgICAgICAgIGRlZiB2aXNpdF9Db21wcmVoZW5zaW9uKHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgY29uc3RydWN0c19zZWVuLmFkZCgnY29tcHJlaGVuc2lvbicpCiAgICAgICAgICAgICAgICBzZWxmLmdlbmVyaWNfdmlzaXQobm9kZSkKICAgICAgICAgICAgZGVmIHZpc2l0X0xpc3RDb21wKHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgY29uc3RydWN0c19zZWVuLmFkZCgnbGlzdGNvbXByZWhlbnNpb24nKQogICAgICAgICAgICAgICAgc2VsZi5nZW5lcmljX3Zpc2l0KG5vZGUpCiAgICAgICAgICAgIGRlZiB2aXNpdF9TZXRDb21wKHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgY29uc3RydWN0c19zZWVuLmFkZCgnc2V0Y29tcHJlaGVuc2lvbicpCiAgICAgICAgICAgICAgICBzZWxmLmdlbmVyaWNfdmlzaXQobm9kZSkKICAgICAgICAgICAgZGVmIHZpc2l0X0RpY3RDb21wKHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgY29uc3RydWN0c19zZWVuLmFkZCgnZGljdGNvbXByZWhlbnNpb24nKQogICAgICAgICAgICAgICAgc2VsZi5nZW5lcmljX3Zpc2l0KG5vZGUpCiAgICAgICAgICAgIGRlZiB2aXNpdF9TbGljZShzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGNvbnN0cnVjdHNfc2Vlbi5hZGQoJ3NsaWNlJykKICAgICAgICAgICAgZGVmIHZpc2l0X0lmKHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgY29uc3RydWN0c19zZWVuLmFkZCgnaWYnKQogICAgICAgICAgICAgICAgc2VsZi5nZW5lcmljX3Zpc2l0KG5vZGUpCiAgICAgICAgICAgIGRlZiB2aXNpdF9CcmVhayhzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGNvbnN0cnVjdHNfc2Vlbi5hZGQoJ2JyZWFrJykKICAgICAgICAgICAgICAgIHNlbGYuZ2VuZXJpY192aXNpdChub2RlKQogICAgICAgICAgICBkZWYgdmlzaXRfQ29udGludWUoc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RzX3NlZW4uYWRkKCdjb250aW51ZScpCiAgICAgICAgICAgICAgICBzZWxmLmdlbmVyaWNfdmlzaXQobm9kZSkKICAgICAgICAgICAgZGVmIHZpc2l0X1RyeShzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGNvbnN0cnVjdHNfc2Vlbi5hZGQoJ3RyeScpCiAgICAgICAgICAgICAgICBzZWxmLmdlbmVyaWNfdmlzaXQobm9kZSkKICAgICAgICAgICAgZGVmIHZpc2l0X1RyeUV4Y2VwdChzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGNvbnN0cnVjdHNfc2Vlbi5hZGQoJ3RyeScpCiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RzX3NlZW4uYWRkKCdleGNlcHQnKQogICAgICAgICAgICAgICAgc2VsZi5nZW5lcmljX3Zpc2l0KG5vZGUpCiAgICAgICAgICAgIGRlZiB2aXNpdF9UcnlGaW5hbGx5KHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgY29uc3RydWN0c19zZWVuLmFkZCgndHJ5JykKICAgICAgICAgICAgICAgIGNvbnN0cnVjdHNfc2Vlbi5hZGQoJ2ZpbmFsbHknKQogICAgICAgICAgICAgICAgc2VsZi5nZW5lcmljX3Zpc2l0KG5vZGUpCiAgICAgICAgICAgIGRlZiB2aXNpdF9FeGNlcHRIYW5kbGVyKHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgY29uc3RydWN0c19zZWVuLmFkZCgnZXhjZXB0JykKICAgICAgICAgICAgICAgIHNlbGYuZ2VuZXJpY192aXNpdChub2RlKQogICAgICAgICAgICBkZWYgdmlzaXRfV2l0aChzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGNvbnN0cnVjdHNfc2Vlbi5hZGQoJ3dpdGgnKQogICAgICAgICAgICAgICAgc2VsZi5nZW5lcmljX3Zpc2l0KG5vZGUpCiAgICAgICAgICAgIGRlZiB2aXNpdF9ZaWVsZChzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGNvbnN0cnVjdHNfc2Vlbi5hZGQoJ3lpZWxkJykKICAgICAgICAgICAgICAgIHNlbGYuZ2VuZXJpY192aXNpdChub2RlKQogICAgICAgICAgICBkZWYgdmlzaXRfWWllbGRGcm9tKHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgY29uc3RydWN0c19zZWVuLmFkZCgneWllbGQnKQogICAgICAgICAgICAgICAgc2VsZi5nZW5lcmljX3Zpc2l0KG5vZGUpCiAgICAgICAgICAgIGRlZiB2aXNpdF9SZXR1cm4oc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RzX3NlZW4uYWRkKCdyZXR1cm4nKQogICAgICAgICAgICAgICAgc2VsZi5nZW5lcmljX3Zpc2l0KG5vZGUpCgogICAgICAgIHZpc2l0b3IgPSBDb25zdHJ1Y3RGaW5kZXIoKQogICAgICAgIHZpc2l0b3IudmlzaXQoc2VsZi50cmVlKQogICAgICAgIHJldHVybiBjb25zdHJ1Y3RzX3NlZW4KCiAgICBkZWYgY2hlY2tfdHlwZV9oaW50cyhzZWxmKToKICAgICAgICAiIiJSZXR1cm4gYSBsaXN0IG9mIHRoZSBuYW1lcyBvZiBmdW5jdGlvbnMgdGhhdCBkb24ndCBoYXZlIGZ1bGwgdHlwZSBoaW50aW5nLiIiIgogICAgICAgIHVuaGludGVkID0gW10KICAgICAgICBjbGFzcyBNeVZpc2l0b3IoYXN0Lk5vZGVWaXNpdG9yKToKICAgICAgICAgICAgZGVmIHZpc2l0X0Z1bmN0aW9uRGVmKHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgaWYgbm9kZS5yZXR1cm5zIGlzIE5vbmUgb3IgYW55KFthcmcuYW5ub3RhdGlvbiBpcyBOb25lIGZvciBhcmcgaW4gbm9kZS5hcmdzLmFyZ3NdKToKICAgICAgICAgICAgICAgICAgICB1bmhpbnRlZC5hcHBlbmQobm9kZS5uYW1lKQoKICAgICAgICB2aXNpdG9yID0gTXlWaXNpdG9yKCkKICAgICAgICB0cmVlID0gc2VsZi50cmVlCiAgICAgICAgdmlzaXRvci52aXNpdChzZWxmLnRyZWUpCiAgICAgICAgcmV0dXJuIHVuaGludGVkCgogICAgZGVmIGZpbmRfZnVuY3Rpb25fY2FsbHMoc2VsZiwgbmFtZSk6CiAgICAgICAgIiIiTG9vayBmb3Igb2NjdXJhbmNlcyBvZiBhIHNwZWNpZmljIGZ1bmN0aW9uIGNhbGwiIiIKICAgICAgICByZXR1cm4gc2VsZi5maW5kX2FsbF9mdW5jdGlvbl9jYWxscygpLmdldChuYW1lLCBbXSkKCgogICAgZGVmIGZpbmRfaWxsZWdhbF9mdW5jdGlvbnMoc2VsZik6CiAgICAgICAgIiIiRmluZCBhIHNldCBvZiBhbGwgdGhlIGZ1bmN0aW9ucyB0aGF0IHRoZSBzdHVkZW50IHVzZXMKICAgICAgICAgICB0aGF0IHRoZXkgYXJlIG5vdCBhbGxvd2VkIHRvIHVzZS4gIiIiCiAgICAgICAgZnVuY19jYWxscyA9IHNlbGYuZmluZF9hbGxfZnVuY3Rpb25fY2FsbHMoKQogICAgICAgIHJldHVybiBmdW5jX2NhbGxzLmtleXMoKSAmIHNldChzZWxmLnBhcmFtc1sncHJvc2NyaWJlZGZ1bmN0aW9ucyddKQoKCiAgICBkZWYgZmluZF9taXNzaW5nX3JlcXVpcmVkX2Z1bmN0aW9uX2NhbGxzKHNlbGYpOgogICAgICAgICIiIkZpbmQgYSBzZXQgb2YgdGhlIHJlcXVpcmVkIGZ1bmN0aW9ucyB0aGF0IHRoZSBzdHVkZW50IGZhaWxzIHRvIHVzZSIiIgogICAgICAgIGZ1bmNfY2FsbHMgPSBzZWxmLmZpbmRfYWxsX2Z1bmN0aW9uX2NhbGxzKCkKICAgICAgICByZXR1cm4gc2V0KHNlbGYucGFyYW1zWydyZXF1aXJlZGZ1bmN0aW9uY2FsbHMnXSkgLSBmdW5jX2NhbGxzLmtleXMoKQoKCiAgICBkZWYgZmluZF9taXNzaW5nX3JlcXVpcmVkX2Z1bmN0aW9uX2RlZmluaXRpb25zKHNlbGYpOgogICAgICAgICIiIkZpbmQgYSBzZXQgb2YgcmVxdWlyZWQgZnVuY3Rpb25zIHRoYXQgdGhlIHN0dWRlbnQgZmFpbHMgdG8gZGVmaW5lIiIiCiAgICAgICAgZnVuY19kZWZzID0gc2VsZi5maW5kX2RlZmluZWRfZnVuY3Rpb25zKCkKICAgICAgICByZXR1cm4gc2V0KHNlbGYucGFyYW1zWydyZXF1aXJlZGZ1bmN0aW9uZGVmaW5pdGlvbnMnXSkgLSBmdW5jX2RlZnMKCgogICAgZGVmIGZpbmRfaWxsZWdhbF9jb25zdHJ1Y3RzKHNlbGYpOgogICAgICAgICIiIkZpbmQgYWxsIHRoZSBjb25zdHJ1Y3RzIHRoYXQgd2VyZSB1c2VkIGJ1dCBub3QgYWxsb3dlZCIiIgogICAgICAgIGNvbnN0cnVjdHMgPSBzZWxmLmNvbnN0cnVjdHNfdXNlZCgpCiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdHMgJiBzZXQoc2VsZi5wYXJhbXNbJ3Byb3NjcmliZWRjb25zdHJ1Y3RzJ10pCgoKICAgIGRlZiBmaW5kX21pc3NpbmdfcmVxdWlyZWRfY29uc3RydWN0cyhzZWxmKToKICAgICAgICAiIiJGaW5kIHdoaWNoIG9mIHRoZSByZXF1aXJlZCBjb25zdHJ1Y3RzIHdlcmUgbm90IHVzZWQiIiIKICAgICAgICBjb25zdHJ1Y3RzID0gc2VsZi5jb25zdHJ1Y3RzX3VzZWQoKQogICAgICAgIHJldHVybiBzZXQoc2VsZi5wYXJhbXNbJ3JlcXVpcmVkY29uc3RydWN0cyddKSAtIGNvbnN0cnVjdHMKCgogICAgZGVmIGZpbmRfdG9vX2xvbmdfZnVuY3Moc2VsZiwgbWF4X2xlbmd0aCk6CiAgICAgICAgIiIiUmV0dXJuIGEgbGlzdCBvZiB0aGUgZnVuY3Rpb25zIHRoYXQgZXhjZWVkIHRoZSBnaXZlbiBtYXhfbGVuZ3RoCiAgICAgICAgICAgRWFjaCBsaXN0IGVsZW1lbnQgaXMgYSB0dXBsZSBvZiB0aGUgZnVuY3Rpb24gbmFtZSBhbmQgdGhlIG51bWJlciBvZiBzdGF0ZW1lbnRzCiAgICAgICAgICAgaW4gaXRzIGJvZHkuIiIiCgogICAgICAgIGJhZF9mdW5jcyA9IFtdCgogICAgICAgIGNsYXNzIE15VmlzaXRvcihhc3QuTm9kZVZpc2l0b3IpOgoKICAgICAgICAgICAgZGVmIHZpc2l0X0Z1bmN0aW9uRGVmKHNlbGYsIG5vZGUpOgoKICAgICAgICAgICAgICAgIGRlZiBjb3VudF9zdGF0ZW1lbnRzKG5vZGUpOgogICAgICAgICAgICAgICAgICAgICIiIk51bWJlciBvZiBzdGF0ZW1lbnRzIGluIHRoZSBnaXZlbiBub2RlIGFuZCBpdHMgY2hpbGRyZW4iIiIKICAgICAgICAgICAgICAgICAgICBjb3VudCA9IDEKICAgICAgICAgICAgICAgICAgICBpZiBpc2luc3RhbmNlKG5vZGUsIGFzdC5FeHByKSBhbmQgaXNpbnN0YW5jZShub2RlLnZhbHVlLCBhc3QuU3RyKToKICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgPSAwCiAgICAgICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICAgICAgZm9yIGF0dHIgaW4gWydib2R5JywgJ29yZWxzZScsICdmaW5hbGJvZHknXToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIGhhc2F0dHIobm9kZSwgYXR0cik6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4gPSBub2RlLl9fZGljdF9fW2F0dHJdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgKz0gc3VtKGNvdW50X3N0YXRlbWVudHMoY2hpbGQpIGZvciBjaGlsZCBpbiBjaGlsZHJlbikKICAgICAgICAgICAgICAgICAgICByZXR1cm4gY291bnQKCiAgICAgICAgICAgICAgICBudW1fc3RhdGVtZW50cyA9IGNvdW50X3N0YXRlbWVudHMobm9kZSkgLSAxICMgRGlzcmVnYXJkIGRlZiBpdHNlbGYKICAgICAgICAgICAgICAgIGlmIG51bV9zdGF0ZW1lbnRzID4gbWF4X2xlbmd0aDoKICAgICAgICAgICAgICAgICAgICBiYWRfZnVuY3MuYXBwZW5kKChub2RlLm5hbWUsIG51bV9zdGF0ZW1lbnRzKSkKCiAgICAgICAgICAgIGRlZiB2aXNpdF9Bc3luY0Z1bmN0aW9uRGVmKHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgc2VsZi52aXNpdF9GdW5jdGlvbkRlZihub2RlKQoKICAgICAgICB2aXNpdG9yID0gTXlWaXNpdG9yKCkKICAgICAgICB2aXNpdG9yLnZpc2l0KHNlbGYudHJlZSkKICAgICAgICByZXR1cm4gYmFkX2Z1bmNzCgoKICAgIGRlZiBmaW5kX2dsb2JhbF9jb2RlKHNlbGYpOgogICAgICAgICIiIlJldHVybiBhIGxpc3Qgb2YgZXJyb3IgbWVzc2FnZXMgcmVsYXRpbmcgdG8gdGhlIGV4aXN0ZW5jZSBvZgogICAgICAgICAgIGFueSBnbG9iYWwgYXNzaWdubWVudCwgZm9yLCB3aGlsZSBhbmQgaWYgbm9kZXMuIElnbm9yZXMKICAgICAgICAgICBnbG9iYWwgYXNzaWdubWVudCBzdGF0ZW1lbnRzIHdpdGggYW4gQUxMX0NBUFMgdGFyZ2V0LiIiIgoKICAgICAgICBnbG9iYWxfZXJyb3JzID0gW10KICAgICAgICBjbGFzcyBNeVZpc2l0b3IoYXN0Lk5vZGVWaXNpdG9yKToKICAgICAgICAgICAgZGVmIHZpc2l0X0Fzc2lnbihzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGlmIG5vZGUuY29sX29mZnNldCA9PSAwOgogICAgICAgICAgICAgICAgICAgIGlmIGxlbihub2RlLnRhcmdldHMpID4gMSBvciBpc2luc3RhbmNlKG5vZGUudGFyZ2V0c1swXSwgYXN0LlR1cGxlKToKICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsX2Vycm9ycy5hcHBlbmQoZiJNdWx0aXBsZSB0YXJnZXRzIGluIGdsb2JhbCBhc3NpZ25tZW50IHN0YXRlbWVudCBhdCBsaW5lIHtub2RlLmxpbmVub30iKQogICAgICAgICAgICAgICAgICAgIGVsaWYgbm90IG5vZGUudGFyZ2V0c1swXS5pZC5pc3VwcGVyKCk6CiAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbF9lcnJvcnMuYXBwZW5kKGYiR2xvYmFsIGFzc2lnbm1lbnQgc3RhdGVtZW50IGF0IGxpbmUge25vZGUubGluZW5vfSIpCgogICAgICAgICAgICBkZWYgdmlzaXRfRm9yKHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgaWYgbm9kZS5jb2xfb2Zmc2V0ID09IDA6CiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsX2Vycm9ycy5hcHBlbmQoZiJHbG9iYWwgZm9yIGxvb3AgYXQgbGluZSB7bm9kZS5saW5lbm99IikKCiAgICAgICAgICAgIGRlZiB2aXNpdF9XaGlsZShzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGlmIG5vZGUuY29sX29mZnNldCA9PSAwOgogICAgICAgICAgICAgICAgICAgIGdsb2JhbF9lcnJvcnMuYXBwZW5kKGYiR2xvYmFsIHdoaWxlIGxvb3AgYXQgbGluZSB7bm9kZS5saW5lbm99IikKCiAgICAgICAgICAgIGRlZiB2aXNpdF9JZihzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGlmIG5vZGUuY29sX29mZnNldCA9PSAwOgogICAgICAgICAgICAgICAgICAgIGdsb2JhbF9lcnJvcnMuYXBwZW5kKGYiR2xvYmFsIGlmIHN0YXRlbWVudCBhdCBsaW5lIHtub2RlLmxpbmVub30iKQoKICAgICAgICB2aXNpdG9yID0gTXlWaXNpdG9yKCkKICAgICAgICB2aXNpdG9yLnZpc2l0KHNlbGYudHJlZSkKICAgICAgICByZXR1cm4gZ2xvYmFsX2Vycm9ycwoKCiAgICBkZWYgZmluZF9uZXN0ZWRfZnVuY3Rpb25zKHNlbGYpOgogICAgICAgICIiIlJldHVybiBhIGxpc3Qgb2YgZnVuY3Rpb25zIHRoYXQgYXJlIGRlY2xhcmVkIHdpdGggbm9uLWdsb2JhbCBzY29wZSIiIgogICAgICAgIGJhZF9mdW5jcyA9IFtdCgogICAgICAgIGNsYXNzIE15VmlzaXRvcihhc3QuTm9kZVZpc2l0b3IpOgogICAgICAgICAgICBpc192aXNpdGluZ19mdW5jID0gRmFsc2UKCiAgICAgICAgICAgIGRlZiB2aXNpdF9GdW5jdGlvbkRlZihzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGlmIHNlbGYuaXNfdmlzaXRpbmdfZnVuYzoKICAgICAgICAgICAgICAgICAgICBiYWRfZnVuY3MuYXBwZW5kKG5vZGUubmFtZSkKICAgICAgICAgICAgICAgIHNlbGYuaXNfdmlzaXRpbmdfZnVuYyA9IFRydWUKICAgICAgICAgICAgICAgIHNlbGYuZ2VuZXJpY192aXNpdChub2RlKSAjIFZpc2l0IGFsbCBjaGlsZHJlbiByZWN1cnNpdmVseQogICAgICAgICAgICAgICAgc2VsZi5pc192aXNpdGluZ19mdW5jID0gRmFsc2UKCiAgICAgICAgICAgIGRlZiB2aXNpdF9Bc3luY0Z1bmN0aW9uRGVmKHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgc2VsZi52aXNpdF9GdW5jdGlvbkRlZihub2RlKQoKICAgICAgICB2aXNpdG9yID0gTXlWaXNpdG9yKCkKICAgICAgICB2aXNpdG9yLnZpc2l0KHNlbGYudHJlZSkKICAgICAgICByZXR1cm4gYmFkX2Z1bmNzCg==</file>
<file name="__pytask.py" path="/" encoding="base64">IiIiIENvZGUgZm9yIGNvbXBpbGluZyAoTi9BKSBhbmQgcnVubmluZyBhIFB5dGhvbjMgdGFzay4KIiIiCmltcG9ydCBfX2xhbmd1YWdldGFzayBhcyBsYW5ndWFnZXRhc2sKaW1wb3J0IGlvCmltcG9ydCBzeXMKaW1wb3J0IHRyYWNlYmFjawppbXBvcnQgdHlwZXMKZnJvbSBtYXRoIGltcG9ydCBmbG9vcgppbXBvcnQgb3MKaW1wb3J0IHJlCmZyb20gX193YXRjaGRvZyBpbXBvcnQgV2F0Y2hkb2cKClNPVVJDRV9GSUxFTkFNRSA9ICdzdHVkZW50X2Fuc3dlci5weScKREVGQVVMVF9USU1FT1VUID0gMyAjIHNlY3MKREVGQVVMVF9NQVhPVVRQVVRCWVRFUyA9IDEwMDAwMDAgIyAxIE1CCgpjbGFzcyBPdXRPZklucHV0KEV4Y2VwdGlvbik6CiAgICBwYXNzCgojIChtY3QpIE5ldyBleGNlcHRpb24gZm9yIGhhbmRsaW5nIHNpdHVhdGlvbnMgd2hlcmUgc3VibWl0dGVkIGNvZGUgZG9lcyBzb21ldGhpbmcgaXQgc2hvdWxkIG5vdC4KY2xhc3MgSW52YWxpZEFjdGlvbihFeGNlcHRpb24pOgogICAgZGVmIF9faW5pdF9fKHNlbGYsIGVycm9yX21lc3NhZ2U9JycpOgogICAgICAgIEV4Y2VwdGlvbi5fX2luaXRfXyhzZWxmLCBlcnJvcl9tZXNzYWdlKQoKZGVmIG5hbWVfbWF0Y2hlc19yZXMobmFtZSwgcmVfc3RyaW5ncyk6CiAgICByZXR1cm4gYm9vbChyZS5tYXRjaChmIl57JyR8Xicuam9pbihyZV9zdHJpbmdzKX0kIiwgbmFtZSkpCgpjbGFzcyBDb2RlVHJhcChvYmplY3QpOgogICAgIiIiIEEgc2FmZSBsaXR0bGUgY29udGFpbmVyIHRvIGhvbGQgdGhlIHN0dWRlbnQncyBjb2RlIGFuZCBncmFiCiAgICAgICAgaXRzIG91dHB1dCwgd2hpbGUgYWxzbyByZWZvcm1hdHRpbmcgZXhjZXB0aW9ucyB0byBiZSBuaWNlcm1heG91dHB1dAogICAgIiIiCgogICAgZGVmIF9faW5pdF9fKHNlbGYsIHN0dWRlbnRfY29kZSwgcGFyYW1zLCBzZWNvbmRzX3JlbWFpbmluZz1Ob25lKToKICAgICAgICBzZWxmLnBhcmFtcyA9IHBhcmFtcwogICAgICAgIGlmICd0aW1lb3V0JyBub3QgaW4gcGFyYW1zOgogICAgICAgICAgICBzZWxmLnBhcmFtc1sndGltZW91dCddID0gREVGQVVMVF9USU1FT1VUCiAgICAgICAgaWYgJ21heG91dHB1dGJ5dGVzJyBub3QgaW4gcGFyYW1zOgogICAgICAgICAgICBzZWxmLnBhcmFtc1snbWF4b3V0cHV0Ynl0ZXMnXSA9IERFRkFVTFRfTUFYT1VUUFVUCiAgICAgICAgaWYgJ2VjaG9zdGFuZGFyZGlucHV0JyBub3QgaW4gcGFyYW1zOgogICAgICAgICAgICBzZWxmLnBhcmFtc1snZWNob3N0YW5kYXJkaW5wdXQnXSA9IFRydWUKICAgICAgICBzZWxmLnJ1bl9jb2RlID0gc3R1ZGVudF9jb2RlCiAgICAgICAgc2VsZi5zY29wZWRfZ2xvYmFscyA9IHNlbGYuX2dldF9nbG9iYWxzKCkKCiAgICAgICAgaWYgc2Vjb25kc19yZW1haW5pbmcgaXMgTm9uZToKICAgICAgICAgICAgc2VsZi5zZWNvbmRzX3JlbWFpbmluZyA9IHNlbGYucGFyYW1zWyd0aW1lb3V0J10KICAgICAgICBlbHNlOgogICAgICAgICAgICBzZWxmLnNlY29uZHNfcmVtYWluaW5nID0gbWluKHNlY29uZHNfcmVtYWluaW5nLCBzZWxmLnBhcmFtc1sndGltZW91dCddKQoKICAgIGRlZiBfZ2V0X2dsb2JhbHMoc2VsZik6CiAgICAgICAgIiIiIEhlcmUgd2UgZGVmaW5lIGFueSBnbG9iYWxzIHRoYXQgbXVzdCBiZSBhdmFpbGFibGUgIiIiCiAgICAgICAgIyBjaGFuZ2UgdGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgJ29wZW4nLgogICAgICAgIGdsb2JhbCBucCAgIyBNYXkgbm90IGFjdHVhbGx5IGJlIGRlZmluZWQgYnV0IHdlJ2xsIGNoZWNrIHNvb24KICAgICAgICBkZWYgbmV3X29wZW4oZmlsZSwgbW9kZT0ncicsIGJ1ZmZlcmluZz0tMSwKICAgICAgICAgICAgICAgICAgICAgZW5jb2Rpbmc9J3V0Zi04JywgZXJyb3JzPU5vbmUsCiAgICAgICAgICAgICAgICAgICAgIG5ld2xpbmU9Tm9uZSwgY2xvc2VmZD1UcnVlLCBvcGVuZXI9Tm9uZSk6CiAgICAgICAgICAgIAogICAgICAgICAgICAjIChtY3Q2MykgT25seSBvcGVuIGFsbG93ZWQgZmlsZXMuCiAgICAgICAgICAgIGlmICgncmVzdHJpY3RlZGZpbGVzJyBpbiBzZWxmLnBhcmFtcwogICAgICAgICAgICAgICAgICAgIGFuZCAoJ29ubHlhbGxvdycgbm90IGluIHNlbGYucGFyYW1zWydyZXN0cmljdGVkZmlsZXMnXSBvciBuYW1lX21hdGNoZXNfcmVzKGZpbGUsIHNlbGYucGFyYW1zWydyZXN0cmljdGVkZmlsZXMnXVsnb25seWFsbG93J10pKQogICAgICAgICAgICAgICAgICAgIGFuZCBub3QgbmFtZV9tYXRjaGVzX3JlcyhmaWxlLCBzZWxmLnBhcmFtc1sncmVzdHJpY3RlZGZpbGVzJ10uZ2V0KCdkaXNhbGxvdycsIFtdKSkpOgogICAgICAgICAgICAgICAgcmV0dXJuIG9wZW4oZmlsZSwgbW9kZSwgYnVmZmVyaW5nLCBlbmNvZGluZywgZXJyb3JzLCBuZXdsaW5lLCBjbG9zZWZkLCBvcGVuZXIpCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICByYWlzZSBJbnZhbGlkQWN0aW9uKGYiWW91IGFyZSBub3QgYWxsb3dlZCB0byBvcGVuICd7ZmlsZX0nLiIpCiAgICAgICAgICAgICAgICAKICAgICAgICAjIChtY3Q2MykgRnVuY3Rpb24gdGhhdCBjcmVhdGVzIHN0dWIgaW52YWxpZCBmdW5jdGlvbi4KICAgICAgICBkZWYgY3JlYXRlX2ludmFsaWRfZnVuYyhuYW1lKToKICAgICAgICAgICAgZGVmIGludmFsaWRfZnVuYygqYXJncywgKiprd2FyZ3MpOgogICAgICAgICAgICAgICAgcmFpc2UgSW52YWxpZEFjdGlvbihmIllvdSBhcmUgbm90IGFsbG93ZWQgdG8gdXNlICd7bmFtZX0nISIpCiAgICAgICAgICAgIHJldHVybiBpbnZhbGlkX2Z1bmMKICAgICAgICAKICAgICAgICAjIChtY3Q2MykgQ2hlY2tzIHdoYXQgaXMgYmVpbmcgaW1wb3J0ZWQgYW5kIG1ha2VzIHN1cmUgaXQgaXMgYWxsb3dlZC4gSWYgaXQgaXMgbm90LCB0aGUgdGhpbmcgdGhhdCAKICAgICAgICAjIGlzIG5vdCBhbGxvd2VkIGlzIHJlcGxhY2VkIGJ5IGFuICdpbnZhbGlkIGZ1bmN0aW9uJy4gSWYgaXQgaXMgYW4gYXR0cmlidXRlIHRoZW4gaXQgaXMgCiAgICAgICAgIyBub3QgaW5jbHVkZWQgc2luY2UgSSBjb3VsZCBub3QgdGhpbmsgb2YgYSBiZXR0ZXIgdGhpbmcgdG8gZG8uIENvdWxkIGxldCBpdCByYWlzZQogICAgICAgICMgICdBdHRyaWJ1dGVOb3RGb3VuZCcgZXhjZXB0aW9uIGFuZCB0aGVuIGNoZWNrIGlmIHRoaXMgd2FzIGNhdXNlZCBmcm9tIHJlbW92aW5nIHRoZSAKICAgICAgICAjIGF0dHJpYnV0ZSBmcm9tIHRoZSBtb2R1bGUgYnV0IGdpdmVuIGhvdyB1bmxpa2VseSB0aGlzIGlzIGl0cyBub3Qgd29ydGggaXQgYXQgdGhpcyB0aW1lLgogICAgICAgIGRlZiBuZXdfaW1wb3J0KG5hbWUsICphcmdzLCAqKmt3YXJncyk6CiAgICAgICAgICAgIG1vZHVsZSA9IF9faW1wb3J0X18obmFtZSwgKmFyZ3MsICoqa3dhcmdzKQogICAgICAgICAgICByZXN0cmljdGVkX21vZHVsZSA9IG1vZHVsZQogICAgICAgICAgICBpZiAncmVzdHJpY3RlZG1vZHVsZXMnIGluIHNlbGYucGFyYW1zIGFuZCBuYW1lIGluIHNlbGYucGFyYW1zWydyZXN0cmljdGVkbW9kdWxlcyddOgogICAgICAgICAgICAgICAgTmV3TW9kdWxlVHlwZSA9IHR5cGUoJ21vZHVsZScsICh0eXBlcy5Nb2R1bGVUeXBlLCksIHt9KQogICAgICAgICAgICAgICAgcmVzdHJpY3RlZF9tb2R1bGUgPSBOZXdNb2R1bGVUeXBlKG5hbWUpCiAgICAgICAgICAgICAgICBmb3IgdmFyIGluIGRpcihtb2R1bGUpOgogICAgICAgICAgICAgICAgICAgIGlmICgoJ29ubHlhbGxvdycgbm90IGluIHNlbGYucGFyYW1zWydyZXN0cmljdGVkbW9kdWxlcyddW25hbWVdIG9yCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lX21hdGNoZXNfcmVzKHZhciwgc2VsZi5wYXJhbXNbJ3Jlc3RyaWN0ZWRtb2R1bGVzJ11bbmFtZV1bJ29ubHlhbGxvdyddKSkgYW5kCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3QgbmFtZV9tYXRjaGVzX3Jlcyh2YXIsIHNlbGYucGFyYW1zWydyZXN0cmljdGVkbW9kdWxlcyddW25hbWVdLmdldCgnZGlzYWxsb3cnLCBbXSkpKToKICAgICAgICAgICAgICAgICAgICAgICAgc2V0YXR0cihyZXN0cmljdGVkX21vZHVsZSwgdmFyLCBnZXRhdHRyKG1vZHVsZSwgdmFyKSkKICAgICAgICAgICAgICAgICAgICBlbGlmIGNhbGxhYmxlKGdldGF0dHIobW9kdWxlLCB2YXIpKToKICAgICAgICAgICAgICAgICAgICAgICAgc2V0YXR0cihyZXN0cmljdGVkX21vZHVsZSwgdmFyLCBjcmVhdGVfaW52YWxpZF9mdW5jKGYne25hbWV9Lnt2YXJ9JykpCiAgICAgICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0YXR0cihOZXdNb2R1bGVUeXBlLCB2YXIsIHByb3BlcnR5KGNyZWF0ZV9pbnZhbGlkX2Z1bmMoZid7bmFtZX0ue3Zhcn0nKSkpCiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdCBUeXBlRXJyb3I6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIFNvbWUgYXR0cmlidXRlcyBjYW4gbm90IGJlIHNldCB0byBhIHByb3BlcnR5IHNvIHdlIGlnbm9yZSB0aGVtLgogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUKCiAgICAgICAgICAgIHJldHVybiByZXN0cmljdGVkX21vZHVsZQoKICAgICAgICAjIChtY3Q2MykgSW5zdXJlIHByaW50IGFsd2F5cyBwcmludHMgdG8gdGhlIHJlZGlyZWN0ZWQgc3Rkb3V0IGFuZCBub3QgYWN0dWFsIHN0ZG91dC4KICAgICAgICBkZWYgbmV3X3ByaW50KCp2YWx1ZXMsIHNlcD0nICcsIGVuZD0nXG4nLCBmaWxlPU5vbmUsIGZsdXNoPUZhbHNlKToKICAgICAgICAgICAgcmV0dXJuIHByaW50KCp2YWx1ZXMsIHNlcD1zZXAsIGVuZD1lbmQsIGZpbGU9c3lzLnN0ZG91dCkKICAgICAgICAgICAgCiAgICAgICAgIyBmb3JjZSAnaW5wdXQnIHRvIGVjaG8gdG8gc3RkaW4gdG8gc3Rkb3V0CiAgICAgICAgaWYgc2VsZi5wYXJhbXNbJ2VjaG9zdGFuZGFyZGlucHV0J106CiAgICAgICAgICAgIGRlZiBuZXdfaW5wdXQocHJvbXB0PScnKToKICAgICAgICAgICAgICAgICIiIiBSZXBsYWNlIHRoZSBzdGFuZGFyZCBpbnB1dCBwcm9tcHQgd2l0aCBhIGNsZXZlcmVyIG9uZS4gIiIiCiAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgcyA9IGlucHV0KHByb21wdCkKICAgICAgICAgICAgICAgIGV4Y2VwdCBFT0ZFcnJvcjoKICAgICAgICAgICAgICAgICAgICByYWlzZSBPdXRPZklucHV0KCkKICAgICAgICAgICAgICAgIHByaW50KHMpCiAgICAgICAgICAgICAgICByZXR1cm4gcwogICAgICAgIGVsc2U6CiAgICAgICAgICAgIG5ld19pbnB1dCA9IGlucHV0CiAgICAgICAgCiAgICAgICAgIyAobWN0NjMpIENyZWF0ZSBhIG5ldyBidWlsdGlucyBkaWN0aW9uYXJ5LCByZWRmaW5pbmcgYW55IGZ1bmN0aW9ucyB0aGF0IGFyZSBub3QgYWxsb3dlZC4KICAgICAgICBuZXdfYnVpbHRpbnMgPSB7a2V5OnZhbHVlIGZvciBrZXksIHZhbHVlIGluIF9fYnVpbHRpbnNfXy5pdGVtcygpfQogICAgICAgIG5ld19idWlsdGluc1snb3BlbiddID0gbmV3X29wZW4KICAgICAgICBuZXdfYnVpbHRpbnNbJ2lucHV0J10gPSBuZXdfaW5wdXQKICAgICAgICBuZXdfYnVpbHRpbnNbJ3ByaW50J10gPSBuZXdfcHJpbnQKICAgICAgICBuZXdfYnVpbHRpbnNbJ19faW1wb3J0X18nXSA9IG5ld19pbXBvcnQKCiAgICAgICAgaWYgJ3Byb3NjcmliZWRidWlsdGlucycgaW4gc2VsZi5wYXJhbXM6CiAgICAgICAgICAgIGZvciBmdW5jIGluIHNlbGYucGFyYW1zWydwcm9zY3JpYmVkYnVpbHRpbnMnXToKICAgICAgICAgICAgICAgIG5ld19idWlsdGluc1tmdW5jXSA9IGNyZWF0ZV9pbnZhbGlkX2Z1bmMoZnVuYykKCiAgICAgICAgIyBUaGlzIHdvdWxkIGJlIG5pY2UgYnV0IGl0IGNhbiBtZXNzIHdpdGggdGVzdGluZyBjb2RlLgogICAgICAgICMgZm9yIGZ1bmMgaW4gc2VsZi5wYXJhbXNbJ3Byb3NjcmliZWRmdW5jdGlvbnMnXToKICAgICAgICAjICAgICAgICAgbmV3X2J1aWx0aW5zW2Z1bmNdID0gY3JlYXRlX2ludmFsaWRfZnVuYyhmdW5jKQogICAgICAgIAogICAgICAgIGdsb2JhbF9kaWN0ID0gewogICAgICAgICAgICAnX19idWlsdGluc19fJzogbmV3X2J1aWx0aW5zLAogICAgICAgICAgICAnX19uYW1lX18nOiAnX19tYWluX18nCiAgICAgICAgfQogICAgICAgIGlmICd1c2VzbnVtcHknIGluIHNlbGYucGFyYW1zIGFuZCBzZWxmLnBhcmFtc1sndXNlc251bXB5J106CiAgICAgICAgICAgIGltcG9ydCBudW1weSBhcyBucAogICAgICAgICAgICBnbG9iYWxfZGljdFsnbnAnXSA9IG5wCgogICAgICAgIHJldHVybiBnbG9iYWxfZGljdAoKICAgIGRlZiBfX2VudGVyX18oc2VsZik6CiAgICAgICAgaWYgJ01QTENPTkZJR0RJUicgbm90IGluIG9zLmVudmlyb24gb3Igb3MuZW52aXJvblsnTVBMQ09ORklHRElSJ10uc3RhcnRzd2l0aCgnL2hvbWUnKToKICAgICAgICAgICAgaW1wb3J0IHRlbXBmaWxlCiAgICAgICAgICAgIG9zLmVudmlyb25bJ01QTENPTkZJR0RJUiddID0gdGVtcGZpbGUubWtkdGVtcCgpCiAgICAgICAgc2VsZi5vbGRfc3Rkb3V0ID0gc3lzLnN0ZG91dAogICAgICAgIHNlbGYub2xkX3N0ZGVyciA9IHN5cy5zdGRlcnIKICAgICAgICBzZWxmLm9sZF9wYXRoID0gb3MuZW52aXJvblsiUEFUSCJdCiAgICAgICAgc3lzLnN0ZG91dCA9IGlvLlN0cmluZ0lPKCkKICAgICAgICBzeXMuc3RkZXJyID0gaW8uU3RyaW5nSU8oKQogICAgICAgIG9zLmVudmlyb25bIlBBVEgiXSA9ICcnICAgICAjIChtY3Q2MykgR2V0IHJpZCBvZiBQQVRIIHRvIG1ha2UgaXQgaGFyZGVyIHRvIGV4ZWN1dGUgY29tbWFuZHMuCiAgICAgICAgcmV0dXJuIHNlbGYKCiAgICBkZWYgX19leGl0X18oc2VsZiwgKmFyZ3MpOgogICAgICAgIHN5cy5zdGRvdXQgPSBzZWxmLm9sZF9zdGRvdXQKICAgICAgICBzeXMuc3RkZXJyID0gc2VsZi5vbGRfc3RkZXJyCiAgICAgICAgb3MuZW52aXJvblsiUEFUSCJdID0gc2VsZi5vbGRfcGF0aAoKICAgIGRlZiBleGVjKHNlbGYpOgogICAgICAgICIiIiBSdW4gdGhlIGNvZGUuIE91dHB1dCB0byBzdGRvdXQgYW5kIHN0ZGVyciBpcyBzdG9yZWQgYW5kCiAgICAgICAgICAgIHJldHVybmVkIG9uIGEgY2FsbCB0byByZWFkCiAgICAgICAgIiIiCiAgICAgICAgaWYgc2VsZi5zZWNvbmRzX3JlbWFpbmluZyA8PSAxOgogICAgICAgICAgICBwcmludCgiT3V0IG9mIHRpbWUuIEFib3J0ZWQuIiwgZmlsZT1zeXMuc3RkZXJyKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHdpdGggV2F0Y2hkb2coc2VsZi5zZWNvbmRzX3JlbWFpbmluZyk6CiAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgZXhlYyhzZWxmLnJ1bl9jb2RlLCBzZWxmLnNjb3BlZF9nbG9iYWxzKQogICAgICAgICAgICAgICAgZXhjZXB0IE91dE9mSW5wdXQ6CiAgICAgICAgICAgICAgICAgICAgcHJpbnQoIidpbnB1dCcgZnVuY3Rpb24gY2FsbGVkIHdoZW4gbm8gaW5wdXQgZGF0YSBhdmFpbGFibGUuIiwKICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlPXN5cy5zdGRlcnIpCiAgICAgICAgICAgICAgICBleGNlcHQgV2F0Y2hkb2c6CiAgICAgICAgICAgICAgICAgICAgcHJpbnQoIlRpbWUgbGltaXQgZXhjZWVkZWQiLCBmaWxlPXN5cy5zdGRlcnIpCiAgICAgICAgICAgICAgICAjIChtY3Q2MykgQ2F0Y2ggYW55IGludmFsaWQgYWN0aW9ucy4KICAgICAgICAgICAgICAgIGV4Y2VwdCBJbnZhbGlkQWN0aW9uIGFzIGU6CiAgICAgICAgICAgICAgICAgICAgcHJpbnQoZiJJbnZhbGlkIEFjdGlvbjoge2V9IiwgZmlsZT1zeXMuc3RkZXJyKQogICAgICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgICAgICAgICBldHlwZSwgdmFsdWUsIHRiID0gc3lzLmV4Y19pbmZvKCkKICAgICAgICAgICAgICAgICAgICB0Yl90dXBsZXMgPSB0cmFjZWJhY2suZXh0cmFjdF90Yih0YikKICAgICAgICAgICAgICAgICAgICBuZXdfdGIgPSBbXQogICAgICAgICAgICAgICAgICAgIGZvciBmaWxlbmFtZSwgbGluZW51bWJlciwgc2NvcGUsIHRleHQgaW4gdGJfdHVwbGVzOgogICAgICAgICAgICAgICAgICAgICAgICBpZiBmaWxlbmFtZSA9PSAiPHN0cmluZz4iOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld190Yi5hcHBlbmQoKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX19zb3VyY2UucHkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lbnVtYmVyLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5ydW5fY29kZS5zcGxpdGxpbmVzKClbbGluZW51bWJlciAtIDFdLnN0cmlwKCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApKQogICAgICAgICAgICAgICAgICAgIHByaW50KCJUcmFjZWJhY2sgKG1vc3QgcmVjZW50IGNhbGwgbGFzdCk6IiwgZmlsZT1zeXMuc3RkZXJyKQogICAgICAgICAgICAgICAgICAgIHByaW50KCcnLmpvaW4odHJhY2ViYWNrLmZvcm1hdF9saXN0KG5ld190YikpLCBlbmQ9JycsIGZpbGU9c3lzLnN0ZGVycikKICAgICAgICAgICAgICAgICAgICBwcmludCh0cmFjZWJhY2suZm9ybWF0X2V4Y2VwdGlvbl9vbmx5KGV0eXBlLCB2YWx1ZSlbLTFdLCBlbmQ9JycsIGZpbGU9c3lzLnN0ZGVycikKICAgICAgICAgICAgICAgIGV4Y2VwdCBTeXN0ZW1FeGl0OgogICAgICAgICAgICAgICAgICAgIHByaW50KCJVbmV4cGVjdGVkIHRlcm1pbmF0aW9uOiBQbGVhc2UgZG8gbm90IGNhbGwgZXhpdCgpIG9yIHF1aXQoKS4iLAogICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGU9c3lzLnN0ZGVycikKICAgICAgICAgICAgICAgIGV4Y2VwdCBLZXlib2FyZEludGVycnVwdDoKICAgICAgICAgICAgICAgICAgICBwcmludCgiS2V5Ym9hcmRJbnRlcnJ1cHQiLCBmaWxlPXN5cy5zdGRlcnIpCiAgICAgICAgICAgICAgICBleGNlcHQgR2VuZXJhdG9yRXhpdDoKICAgICAgICAgICAgICAgICAgICBwcmludCgiR2VuZXJhdG9yRXhpdCIsIGZpbGU9c3lzLnN0ZGVycikKCiAgICAgICAgICAgICAgICAjIChtY3Q2MykgTWlnaHQgYXMgd2VsbCBjYXRjaCB0aGUgYmFzZSBleGNlcHRpb24gaW4gY2FzZSBzb21ldGhpbmcgdmVyeSBzdHJhbmdlIGhhcHBlbnMuCiAgICAgICAgICAgICAgICAjIEZvciBleGFtcGxlIGludGVudGlvbmFsbHkgcmFpc2VpbmcgdGhlIEJhc2VFeGNlcHRpb24gdG8gdHJ5IGFuZCBza2lwIGFsbCBvZiB0aGlzLiAKICAgICAgICAgICAgICAgIGV4Y2VwdCBCYXNlRXhjZXB0aW9uOgogICAgICAgICAgICAgICAgICAgIHByaW50KCJDYXVnaHQgQmFzZUV4Y2VwdGlvbi4gWW91IGRpZCBzb21ldGhpbmcgdmVyeSBzdHJhbmdlIHRvIGdldCB0aGlzIG1lc3NhZ2UuIiwKICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlPXN5cy5zdGRlcnIpCgoKCiAgICBkZWYgcmVhZChzZWxmKToKICAgICAgICAiIiIgR2V0IHRoZSBvdXRwdXQgYW5kIGVycm9yIGZyb20gdGhlIGV4ZWMKICAgICAgICAiIiIKICAgICAgICBpZiBzeXMuc3Rkb3V0LnRlbGwoKSArIHN5cy5zdGRlcnIudGVsbCgpICA+IHNlbGYucGFyYW1zWydtYXhvdXRwdXRieXRlcyddOgogICAgICAgICAgICByZXR1cm4gKCcnLCAiPT09IEV4Y2Vzc2l2ZSBPdXRwdXQgPT09XG4gICAgSW5maW5pdGUgbG9vcD8iKQogICAgICAgIHJldHVybiBzeXMuc3Rkb3V0LmdldHZhbHVlKCksIHN5cy5zdGRlcnIuZ2V0dmFsdWUoKQoKCmNsYXNzIFB5VGFzayhsYW5ndWFnZXRhc2suTGFuZ3VhZ2VUYXNrKToKICAgICIiIkEgUHlUYXNrIG1hbmFnZXMgY29tcGlsaW5nIChhbG1vc3QgYSBOT1ApIGFuZCBleGVjdXRpbmcgb2YgYSBQeXRob24zIHByb2dyYW0uCiAgICAiIiIKICAgIGRlZiBfX2luaXRfXyhzZWxmLCBwYXJhbXMsIGNvZGU9Tm9uZSk6CiAgICAgICAgIiIiSW5pdGlhbGlzYXRpb24gaXMgZGVsZWdhdGVkIHRvIHRoZSBzdXBlcmNsYXNzLgogICAgICAgICIiIgogICAgICAgIHN1cGVyKCkuX19pbml0X18ocGFyYW1zLCBjb2RlKQogICAgICAgIHNlbGYuZXhlY3V0YWJsZV9idWlsdCA9IEZhbHNlCgogICAgZGVmIGNvbXBpbGUoc2VsZiwgbWFrZV9leGVjdXRhYmxlPUZhbHNlKToKICAgICAgICAiIiJBIE5vLW9wIGZvciBQeXRob24uCiAgICAgICAgIiIiCiAgICAgICAgcGFzcwoKICAgIGRlZiBkaXNjYXJkX2V4ZWN1dGFibGUoc2VsZik6CiAgICAgICAgIiIiQSBuby1vcCBmb3IgcHl0aG9uIiIiCiAgICAgICAgcGFzcwoKICAgIGRlZiBydW5fY29kZShzZWxmLCBzdGFuZGFyZF9pbnB1dD1Ob25lKToKICAgICAgICAiIiJSdW4gY29kZSB1c2luZyBBYXJvbidzIENvZGVUcmFwCiAgICAgICAgIiIiCiAgICAgICAgc3lzLnN0ZGluID0gaW8uU3RyaW5nSU8oc3RhbmRhcmRfaW5wdXQpCiAgICAgICAgd2l0aCBDb2RlVHJhcChzZWxmLmNvZGUsIHNlbGYucGFyYW1zLCBmbG9vcihzZWxmLnNlY29uZHNfcmVtYWluaW5nKCkpKSBhcyBydW5uZXI6CiAgICAgICAgICAgIHJ1bm5lci5leGVjKCkKICAgICAgICAgICAgb3V0cHV0LCBlcnJvciA9IHJ1bm5lci5yZWFkKCkKICAgICAgICBzZWxmLnN0ZG91dCwgc2VsZi5zdGRlcnIgPSBvdXRwdXQsIGVycm9yCiAgICAgICAgcmV0dXJuIG91dHB1dCwgZXJyb3IKCg==</file>
<file name="__resulttable.py" path="/" encoding="base64">IiIiQ29kZSBmb3IgYnVpbGRpbmcgYW5kIG1hbmFnaW5nIHRoZSByZXN1bHQgdGFibGUgZm9yIHRoZSB0ZXN0cy4KICAgVGhlIHJlc3VsdCB0YWJsZSBpdHNlbGYgKHRoZSAndGFibGUnIGZpZWxkIG9mIGFuIG9iamVjdCBvZiB0aGlzIGNsYXNzKQogICAgaXMgYSBsaXN0IG9mIGxpc3RzIG9mIHN0cmluZ3MuIFRoZSBmaXJzdCByb3cgaXMgdGhlIGhlYWRlciByb3cuCiAgIENvbHVtbnMgYXJlICJUZXN0IiwgIklucHV0IiAob3B0aW9uYWwpLCAiRXhwZWN0ZWQiLCAiR290IiwgImlzY29ycmVjdCIsICJpc2hpZGRlbiIKIiIiCmltcG9ydCBodG1sCmltcG9ydCByZQpmcm9tIGNvbGxlY3Rpb25zIGltcG9ydCBkZWZhdWx0ZGljdAoKTUFYX1NUUklOR19MRU5HVEggPSA0MDAwICAjIDRrIGlzIGRlZmF1bHQgbWF4aW11bSBzdHJpbmcgbGVuZ3RoCgoKY2xhc3MgUmVzdWx0VGFibGU6CiAgICBkZWYgX19pbml0X18oc2VsZiwgcGFyYW1zKToKICAgICAgICBzZWxmLnBhcmFtcyA9IHBhcmFtcwogICAgICAgIHNlbGYubWFyayA9IDAKICAgICAgICBzZWxmLnRhYmxlID0gTm9uZQogICAgICAgIHNlbGYuZmFpbGVkX2hpZGRlbiA9IEZhbHNlCiAgICAgICAgc2VsZi5hYm9ydGVkID0gRmFsc2UKICAgICAgICBzZWxmLmhhc19zdGRpbnMgPSBGYWxzZQogICAgICAgIHNlbGYuaGFzX3Rlc3RzID0gRmFsc2UKICAgICAgICBzZWxmLmhpZGluZyA9IEZhbHNlCiAgICAgICAgc2VsZi5udW1fZmFpbGVkX3Rlc3RzID0gMAogICAgICAgIHNlbGYubWlzc2luZ190ZXN0cyA9IDAKICAgICAgICBzZWxmLmdsb2JhbF9lcnJvciA9ICcnCiAgICAgICAgc2VsZi5jb2x1bW5fZm9ybWF0cyA9IE5vbmUKICAgICAgICBzZWxmLmltYWdlcyA9IGRlZmF1bHRkaWN0KGxpc3QpCiAgICAgICAgZGVmYXVsdF9wYXJhbXMgPSB7CiAgICAgICAgICAgICdzdGRpbmZyb21leHRyYSc6IEZhbHNlLAogICAgICAgICAgICAnc3RyaWN0d2hpdGVzcGFjZSc6IFRydWUsCiAgICAgICAgICAgICdmbG9hdHRvbGVyYW5jZSc6IE5vbmUsCiAgICAgICAgICAgICdBTExfT1JfTk9USElORyc6IFRydWUKICAgICAgICB9CiAgICAgICAgZm9yIHBhcmFtLCB2YWx1ZSBpbiBkZWZhdWx0X3BhcmFtcy5pdGVtcygpOgogICAgICAgICAgICBpZiBwYXJhbSBub3QgaW4gcGFyYW1zOgogICAgICAgICAgICAgICAgc2VsZi5wYXJhbXNbcGFyYW1dID0gdmFsdWUKCgogICAgZGVmIHNldF9oZWFkZXIoc2VsZiwgdGVzdGNhc2VzKToKICAgICAgICAiIiJHaXZlbiB0aGUgc2V0IG9mIHRlc3RjYXNlcywgc2V0IHRoZSBoZWFkZXIgYXMgdGhlIGZpcnN0IHJvdyBvZiB0aGUgcmVzdWx0IHRhYmxlCiAgICAgICAgICAgYW5kIHNldCBmbGFncyB0byBpbmRpY2F0ZSBwcmVzZW5jZSBvciBhYnNlbmNlCiAgICAgICAgICAgb2YgdmFyaW91cyB0YWJsZSBjb2x1bW5zLgogICAgICAgICIiIgogICAgICAgIGhlYWRlciA9IFsnaXNjb3JyZWN0J10KICAgICAgICBzZWxmLmNvbHVtbl9mb3JtYXRzID0gWyclcyddCiAgICAgICAgaWYgYW55KHRlc3QudGVzdGNvZGUuc3RyaXAoKSAhPSAnJyBmb3IgdGVzdCBpbiB0ZXN0Y2FzZXMpOgogICAgICAgICAgICBoZWFkZXIuYXBwZW5kKCJUZXN0IikKICAgICAgICAgICAgc2VsZi5oYXNfdGVzdHMgPSBUcnVlCiAgICAgICAgICAgICMgSWYgdGhlIHRlc3QgY29kZSBzaG91bGQgYmUgcmVuZGVyZWQgaW4gaHRtbCB0aGVuIHNldCB0aGF0IGFzIGNvbHVtbiBmb3JtYXQuCiAgICAgICAgICAgIGlmIGFueShnZXRhdHRyKHRlc3QsICd0ZXN0X2NvZGVfaHRtbCcsIE5vbmUpIGZvciB0ZXN0IGluIHRlc3RjYXNlcyk6CiAgICAgICAgICAgICAgICBzZWxmLmNvbHVtbl9mb3JtYXRzLmFwcGVuZCgnJWgnKQogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgc2VsZi5jb2x1bW5fZm9ybWF0cy5hcHBlbmQoJyVzJykKCiAgICAgICAgc3RkaW5zID0gW3Rlc3QuZXh0cmEgaWYgc2VsZi5wYXJhbXNbJ3N0ZGluZnJvbWV4dHJhJ10gZWxzZSB0ZXN0LnN0ZGluIGZvciB0ZXN0IGluIHRlc3RjYXNlc10KICAgICAgICBpZiBhbnkoc3RkaW4ucnN0cmlwKCkgIT0gJycgZm9yIHN0ZGluIGluIHN0ZGlucyk6CiAgICAgICAgICAgIGhlYWRlci5hcHBlbmQoJ0lucHV0JykKICAgICAgICAgICAgc2VsZi5jb2x1bW5fZm9ybWF0cy5hcHBlbmQoJyVzJykKICAgICAgICAgICAgc2VsZi5oYXNfc3RkaW5zID0gVHJ1ZQogICAgICAgIGhlYWRlciArPSBbJ0V4cGVjdGVkJywgJ0dvdCcsICdpc2NvcnJlY3QnLCAnaXNoaWRkZW4nXQogICAgICAgIHNlbGYuY29sdW1uX2Zvcm1hdHMgKz0gWyclcycsICclcycsICclcycsICclcyddCiAgICAgICAgc2VsZi50YWJsZSA9IFtoZWFkZXJdCgogICAgZGVmIGltYWdlX2NvbHVtbl9udW1zKHNlbGYpOgogICAgICAgICIiIkEgbGlzdCBvZiB0aGUgbnVtYmVycyBvZiBjb2x1bW5zIGNvbnRhaW5pbmcgaW1hZ2VzIiIiCiAgICAgICAgcmV0dXJuIHNvcnRlZChzZXQoW2tleVswXSBmb3Iga2V5IGluIHNlbGYuaW1hZ2VzLmtleXMoKV0pKQoKICAgIGRlZiBnZXRfY29sdW1uX2Zvcm1hdHMoc2VsZik6CiAgICAgICAgIiIiIEFuIG9yZGVyZWQgbGlzdCBvZiB0aGUgY29sdW1uIGZvcm1hdHMuIENvbHVtbnMgY29udGFpbmluZyBpbWFnZXMgYXJlIGZvcmNlZCBpbnRvICVoIGZvcm1hdC4KICAgICAgICAgICAgRG9uJ3QgaGF2ZSBmb3JtYXRzIGZvciBpc2NvcnJlY3QgYW5kIGlzaGlkZGVuIGNvbHVtbnMuCiAgICAgICAgIiIiCiAgICAgICAgaW1hZ2VfY29sdW1ucyA9IHNlbGYuaW1hZ2VfY29sdW1uX251bXMoKQogICAgICAgIGZvcm1hdHMgPSBbc2VsZi5jb2x1bW5fZm9ybWF0c1tpXSBpZiBpIG5vdCBpbiBpbWFnZV9jb2x1bW5zIGVsc2UgJyVoJyBmb3IgaSBpbiByYW5nZShsZW4oc2VsZi5jb2x1bW5fZm9ybWF0cykpXQogICAgICAgIHJldHVybiBmb3JtYXRzWzE6LTJdCgogICAgZGVmIGdldF90YWJsZShzZWxmKToKICAgICAgICAiIiJSZXR1cm4gdGhlIGN1cnJlbnQgcmVzdWx0IHRhYmxlLCB3aXRoIGltYWdlcyBhZGRlZCB0byBhcHByb3ByaWF0ZSBjZWxscy4KICAgICAgICAgICBDb2x1bW5zIHRoYXQgY29udGFpbiBpbWFnZXMgYW55d2hlcmUgYXJlIGNvbnZlcnRlZCB0byAlaCBmb3JtYXQgYW5kIGV4aXN0aW5nIGNvbnRlbnQgaW4gdGhhdCBjb2x1bW4KICAgICAgICAgICBpcyBodG1sLWVzY2FwZWQsIG5ld2xpbmVzIHJlcGxhY2VkIHdpdGggPGJyPiBhbmQgd3JhcHBlZCBpbiBhIGRpdi4KICAgICAgICAgICAiIiIKICAgICAgICByZXN1bHRfdGFibGUgPSBbcm93WzpdIGZvciByb3cgaW4gc2VsZi50YWJsZV0gICMgQ2xvbmUgdGhlIHJlc3VsdCB0YWJsZQoKICAgICAgICAjIEh0bWxpc2UgYWxsIGNvbHVtbnMgY29udGFpbmluZyBpbWFnZXMKICAgICAgICBmb3IgY29sX251bSBpbiBzZWxmLmltYWdlX2NvbHVtbl9udW1zKCk6CiAgICAgICAgICAgIGZvciByb3dfbnVtIGluIHJhbmdlKDEsIGxlbihyZXN1bHRfdGFibGUpKToKICAgICAgICAgICAgICAgIHJlc3VsdF90YWJsZVtyb3dfbnVtXVtjb2xfbnVtXSA9IHNlbGYuaHRtbGlzZShyZXN1bHRfdGFibGVbcm93X251bV1bY29sX251bV0pCgogICAgICAgICMgQXBwZW5kIGltYWdlcwogICAgICAgIGZvciAoKGNvbCxyb3cpLCBpbWFnZV9saXN0KSBpbiBzZWxmLmltYWdlcy5pdGVtcygpOgogICAgICAgICAgICBmb3IgaW1hZ2UgaW4gaW1hZ2VfbGlzdDoKICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICByZXN1bHRfdGFibGVbcm93XVtjb2xdICs9ICI8YnI+IiArIGltYWdlCiAgICAgICAgICAgICAgICBleGNlcHQgSW5kZXhFcnJvcjoKICAgICAgICAgICAgICAgICAgICBwYXNzICAjIFRlc3RpbmcgbXVzdCBoYXZlIGFib3J0ZWQgc28gZGlzY2FyZCBpbWFnZQoKICAgICAgICByZXR1cm4gcmVzdWx0X3RhYmxlCgogICAgZGVmIHJlc2V0KHNlbGYpOgogICAgICAgIGlmIGxlbihzZWxmLnRhYmxlKSA+IDE6CiAgICAgICAgICAgIGRlbCBzZWxmLnRhYmxlWzE6XQogICAgICAgIHNlbGYuZ2xvYmFsX2Vycm9yID0gJycKICAgICAgICBzZWxmLm51bV9mYWlsZWRfdGVzdHMgPSBzZWxmLm1hcmsgPSAwCiAgICAgICAgc2VsZi5mYWlsZWRfaGlkZGVuID0gc2VsZi5oaWRpbmcgPSBzZWxmLmFib3J0ZWQgPSBGYWxzZQoKICAgIGRlZiB0ZXN0c19taXNzZWQoc2VsZiwgbnVtKToKICAgICAgICAiIiJSZWNvcmQgdGhlIGZhY3QgdGhhdCB3ZSdyZSBtaXNzaW5nIHNvbWUgdGVzdCByZXN1bHRzICh0aW1lb3V0PykiIiIKICAgICAgICBzZWxmLm1pc3NpbmdfdGVzdHMgPSBudW0KCiAgICBkZWYgcmVjb3JkX2dsb2JhbF9lcnJvcihzZWxmLCBlcnJvcl9tZXNzYWdlKToKICAgICAgICAiIiJSZWNvcmQgc29tZSBzb3J0IG9mIGdsb2JhbCBmYWlsdXJlIiIiCiAgICAgICAgc2VsZi5nbG9iYWxfZXJyb3IgPSBlcnJvcl9tZXNzYWdlCgogICAgZGVmIGFkZF9yb3coc2VsZiwgdGVzdGNhc2UsIHJlc3VsdCwgZXJyb3I9JycpOgogICAgICAgICIiIkFkZCBhIHJlc3VsdCByb3cgdG8gdGhlIHRhYmxlIGZvciB0aGUgZ2l2ZW4gdGVzdCBhbmQgcmVzdWx0IiIiCiAgICAgICAgaXNfY29ycmVjdCA9IHNlbGYuY2hlY2tfY29ycmVjdG5lc3MocmVzdWx0ICsgZXJyb3IsIHRlc3RjYXNlLmV4cGVjdGVkKQogICAgICAgIHJvdyA9IFtpc19jb3JyZWN0XQogICAgICAgIGlmIHNlbGYuaGFzX3Rlc3RzOgogICAgICAgICAgICBpZiBnZXRhdHRyKHRlc3RjYXNlLCAndGVzdF9jb2RlX2h0bWwnLCBOb25lKToKICAgICAgICAgICAgICAgIHJvdy5hcHBlbmQodGVzdGNhc2UudGVzdF9jb2RlX2h0bWwpCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICByb3cuYXBwZW5kKHRlc3RjYXNlLnRlc3Rjb2RlKQogICAgICAgIGlmIHNlbGYuaGFzX3N0ZGluczoKICAgICAgICAgICAgcm93LmFwcGVuZCh0ZXN0Y2FzZS5leHRyYSBpZiBzZWxmLnBhcmFtc1snc3RkaW5mcm9tZXh0cmEnXSBlbHNlIHRlc3RjYXNlLnN0ZGluKQogICAgICAgIHJvdy5hcHBlbmQodGVzdGNhc2UuZXhwZWN0ZWQucnN0cmlwKCkpCiAgICAgICAgbWF4X2xlbiA9IHNlbGYucGFyYW1zLmdldCgnbWF4c3RyaW5nbGVuZ3RoJywgTUFYX1NUUklOR19MRU5HVEgpCiAgICAgICAgcmVzdWx0ID0gc2FuaXRpc2UocmVzdWx0LnN0cmlwKCdcbicpLCBtYXhfbGVuKQoKICAgICAgICBpZiBlcnJvcjoKICAgICAgICAgICAgZXJyb3JfbWVzc2FnZSA9ICcqKiogUlVOIFRJTUUgRVJST1IoUykgKioqXG4nICsgc2FuaXRpc2UoZXJyb3IsIG1heF9sZW4pCiAgICAgICAgICAgIGlmIHJlc3VsdDoKICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCArICdcbicgKyBlcnJvcl9tZXNzYWdlCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICByZXN1bHQgPSBlcnJvcl9tZXNzYWdlCiAgICAgICAgcm93LmFwcGVuZChyZXN1bHQpCgogICAgICAgIGlmIGlzX2NvcnJlY3Q6CiAgICAgICAgICAgIHNlbGYubWFyayArPSB0ZXN0Y2FzZS5tYXJrCiAgICAgICAgZWxzZToKICAgICAgICAgICAgc2VsZi5udW1fZmFpbGVkX3Rlc3RzICs9IDEKICAgICAgICByb3cuYXBwZW5kKGlzX2NvcnJlY3QpCiAgICAgICAgZGlzcGxheSA9IHRlc3RjYXNlLmRpc3BsYXkudXBwZXIoKQogICAgICAgIGlzX2hpZGRlbiA9ICgKICAgICAgICAgICAgc2VsZi5oaWRpbmcgb3IKICAgICAgICAgICAgZGlzcGxheSA9PSAnSElERScgb3IKICAgICAgICAgICAgKGRpc3BsYXkgPT0gJ0hJREVfSUZfU1VDQ0VFRCcgYW5kIGlzX2NvcnJlY3QpIG9yCiAgICAgICAgICAgIChkaXNwbGF5ID09ICdISURFX0lGX0ZBSUwnIGFuZCBub3QgaXNfY29ycmVjdCkKICAgICAgICApCiAgICAgICAgcm93LmFwcGVuZChpc19oaWRkZW4pCiAgICAgICAgaWYgbm90IGlzX2NvcnJlY3QgYW5kIGlzX2hpZGRlbjoKICAgICAgICAgICAgc2VsZi5mYWlsZWRfaGlkZGVuID0gVHJ1ZQogICAgICAgIGlmIG5vdCBpc19jb3JyZWN0IGFuZCB0ZXN0Y2FzZS5oaWRlcmVzdGlmZmFpbDoKICAgICAgICAgICAgc2VsZi5oaWRpbmcgPSBUcnVlCiAgICAgICAgc2VsZi50YWJsZS5hcHBlbmQocm93KQogICAgICAgIGlmIGVycm9yOgogICAgICAgICAgICBzZWxmLmFib3J0ZWQgPSBUcnVlCgogICAgZGVmIGdldF9tYXJrKHNlbGYpOgogICAgICAgIHJldHVybiBzZWxmLm1hcmsgaWYgc2VsZi5udW1fZmFpbGVkX3Rlc3RzID09IDAgb3Igbm90IHNlbGYucGFyYW1zWydBTExfT1JfTk9USElORyddIGVsc2UgMAoKICAgIEBzdGF0aWNtZXRob2QKICAgIGRlZiBodG1saXNlKHMpOgogICAgICAgICIiIkNvbnZlcnQgdGhlIGdpdmVuIHN0cmluZyB0byBodG1sIGJ5IGVzY2FwaW5nICc8JyBhbmQgJz4nLgogICAgICAgICAgIFdyYXAgdGhlIHdob2xlIGxvdCBpbiBhIGRpdiB0YWcgc28gdGhlIGRpZmYgY2hlY2tlciBwcm9jZXNzZXMgdGhlIHdob2xlIHRhYmxlIGNlbGwsCiAgICAgICAgICAgYW5kIHdpdGhpbiB0aGF0IGEgcHJlIHRhZyBmb3IgY29ycmVjdCBsYXlsb3V0LgogICAgICAgICIiIgogICAgICAgIHJldHVybiAnPGRpdj48cHJlIGNsYXNzPSJ0YWJsZWNlbGwiPicgKyBodG1sLmVzY2FwZShzKSArICc8L3ByZT48L2Rpdj4nCgogICAgZGVmIGFkZF9pbWFnZShzZWxmLCBpbWFnZV9odG1sLCBjb2x1bW5fbmFtZSwgcm93X251bSk6CiAgICAgICAgIiIiU3RvcmUgdGhlIGdpdmVuIGh0bWxfaW1hZ2UgZm9yIGxhdGVyIGluY2x1c2lvbiBpbiB0aGUgY2VsbCBhdCB0aGUgZ2l2ZW4gcm93IGFuZCBnaXZlbiBjb2x1bW4uCiAgICAgICAgICAgY29sdW1uX25hbWUgaXMgdGhlIG5hbWUgdXNlZCBmb3IgdGhlIGNvbHVtbiBpbiB0aGUgZmlyc3QgKGhlYWRlcikgcm93LgogICAgICAgICAgIHJvd19udW0gaXMgdGhlIHJvdyBudW1iZXIgKDAgb3JpZ2luLCBub3QgaW5jbHVkaW5nIHRoZSBoZWFkZXIgcm93KS4KICAgICAgICAiIiIKICAgICAgICBjb2x1bW5fbnVtID0gc2VsZi50YWJsZVswXS5pbmRleChjb2x1bW5fbmFtZSkKICAgICAgICBzZWxmLmltYWdlc1tjb2x1bW5fbnVtLCByb3dfbnVtICsgMV0uYXBwZW5kKGltYWdlX2h0bWwpCgogICAgZGVmIGVxdWFsX3N0cmluZ3Moc2VsZiwgczEsIHMyKToKICAgICAgICAiIiIgQ29tcGFyZSB0aGUgdHdvIHN0cmluZ3MgczEgYW5kIHMyIChleHBlY3RlZCBhbmQgZ290IHJlc3BlY3RpdmVseSkKICAgICAgICAgICAgZm9yIGVxdWFsaXR5LCB3aXRoIHJlZ2FyZCB0byB0aGUgdGVtcGxhdGUgcGFyYW1ldGVycwogICAgICAgICAgICBzdHJpY3R3aGl0ZXNwYWNlIGFuZCBmbG9hdHRvbGVyYW5jZS4KICAgICAgICAiIiIKICAgICAgICBzMSA9IHMxLnJzdHJpcCgpCiAgICAgICAgczIgPSBzMi5yc3RyaXAoKQogICAgICAgIGlmIG5vdCBzZWxmLnBhcmFtc1snc3RyaWN0d2hpdGVzcGFjZSddOgogICAgICAgICAgICAjIENvbGxhcHNlIHdoaXRlIHNwYWNlIGlmIHN0cmljdCB3aGl0ZXNwYWNlIGlzIG5vdCBlbmZvcmNlZAogICAgICAgICAgICBzMSA9IHJlLnN1YihyJ1xzKycsICcgJywgczEpCiAgICAgICAgICAgIHMyID0gcmUuc3ViKHInXHMrJywgJyAnLCBzMikKICAgICAgICBpZiBzZWxmLnBhcmFtc1snZmxvYXR0b2xlcmFuY2UnXSBpcyBOb25lOgogICAgICAgICAgICByZXR1cm4gczEgPT0gczIKICAgICAgICBlbHNlOgogICAgICAgICAgICAjIE1hdGNoaW5nIHdpdGggYSBmbG9hdGluZyBwb2ludCB0b2xlcmFuY2UuCiAgICAgICAgICAgICMgVXNlIGZsb2F0IHBhdHRlcm4gZnJvbSBNYXJrdXMgU2NobWFzc21hbm4gYXQKICAgICAgICAgICAgIyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMjY0MzAwOS9yZWd1bGFyLWV4cHJlc3Npb24tZm9yLWZsb2F0aW5nLXBvaW50LW51bWJlcnMKICAgICAgICAgICAgIyBleGNlcHQgd2UgZG9uJ3QgbWF0Y2ggaW5mIG9yIG5hbiB3aGljaCBjYW4gYmUgZW1iZWRkZWQgaW4gdGV4dCBzdHJpbmdzLgogICAgICAgICAgICB0b2wgPSBmbG9hdChzZWxmLnBhcmFtc1snZmxvYXR0b2xlcmFuY2UnXSkKICAgICAgICAgICAgZmxvYXRfcGF0ID0gcicoWy0rXT8oPzooPzooPzpbMC05XStbLl0/WzAtOV0qfFsuXVswLTldKykoPzpbZWRdWy0rXT9bMC05XSspPykpKScKICAgICAgICAgICAgczFfYml0cyA9IHJlLnNwbGl0KGZsb2F0X3BhdCwgczEpCiAgICAgICAgICAgIHMyX2JpdHMgPSByZS5zcGxpdChmbG9hdF9wYXQsIHMyKQogICAgICAgICAgICBpZiBsZW4oczFfYml0cykgIT0gbGVuKHMyX2JpdHMpOgogICAgICAgICAgICAgICAgcmV0dXJuIEZhbHNlCiAgICAgICAgICAgIG1hdGNoID0gVHJ1ZQogICAgICAgICAgICBmb3IgYml0MSwgYml0MiBpbiB6aXAoczFfYml0cywgczJfYml0cyk6CiAgICAgICAgICAgICAgICBiaXQxID0gYml0MS5zdHJpcCgpCiAgICAgICAgICAgICAgICBiaXQyID0gYml0Mi5zdHJpcCgpCiAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgZjEgPSBmbG9hdChiaXQxKQogICAgICAgICAgICAgICAgICAgIGYyID0gZmxvYXQoYml0MikKICAgICAgICAgICAgICAgICAgICBpZiBhYnMoZjEgLSBmMikgPiB0b2wgKiAxLjAwMTogIyBBbGxvdyB0b2xlcmFuY2Ugb24gdGhlIGZsb2F0IHRvbGVyYW5jZSEKICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBGYWxzZQogICAgICAgICAgICAgICAgZXhjZXB0IFZhbHVlRXJyb3I6CiAgICAgICAgICAgICAgICAgICAgaWYgYml0MSAhPSBiaXQyOgogICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IEZhbHNlCiAgICAgICAgICAgIHJldHVybiBtYXRjaAoKICAgIGRlZiBjaGVja19jb3JyZWN0bmVzcyhzZWxmLCBleHBlY3RlZCwgZ290KToKICAgICAgICAiIiJUcnVlIGlmZiBleHBlY3RlZCBtYXRjaGVzIGdvdCB3aXRoIHJlbGF4ZWQgd2hpdGUgc3BhY2UgcmVxdWlyZW1lbnRzLgogICAgICAgICAgIEFkZGl0aW9uYWxseSwgaWYgdGhlIHRlbXBsYXRlIHBhcmFtZXRlciBmbG9hdHRvbGVyYW5jZSBpcyBzZXQgYW5kIGlzCiAgICAgICAgICAgbm9uLXplcm8sIHRoZSB0d28gc3RyaW5ncyB3aWxsIGJlIHNwbGl0IGJ5IGEgZmxvYXRpbmctcG9pbnQgbGl0ZXJhbAogICAgICAgICAgIHBhdHRlcm4gYW5kIHRoZSBmbG9hdGluZy1wb2ludCBiaXRzIHdpbGwgYmUgbWF0Y2hlZCB0byB3aXRoaW4gdGhlCiAgICAgICAgICAgZ2l2ZW4gYWJzb2x1dGUgdG9sZXJhbmNlLgogICAgICAgICIiIgogICAgICAgIGV4cGVjdGVkX2xpbmVzID0gZXhwZWN0ZWQuc3RyaXAoKS5zcGxpdGxpbmVzKCkKICAgICAgICBnb3RfbGluZXMgPSBnb3Quc3RyaXAoKS5zcGxpdGxpbmVzKCkKICAgICAgICBpZiBsZW4oZ290X2xpbmVzKSAhPSBsZW4oZXhwZWN0ZWRfbGluZXMpOgogICAgICAgICAgICByZXR1cm4gRmFsc2UKICAgICAgICBlbHNlOgogICAgICAgICAgICBmb3IgZXhwLCBnb3QgaW4gemlwKGV4cGVjdGVkX2xpbmVzLCBnb3RfbGluZXMpOgogICAgICAgICAgICAgICAgaWYgbm90IHNlbGYuZXF1YWxfc3RyaW5ncyhleHAsIGdvdCk6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZhbHNlCiAgICAgICAgcmV0dXJuIFRydWUKCgpkZWYgc2FuaXRpc2UocywgbWF4X2xlbj1NQVhfU1RSSU5HX0xFTkdUSCk6CiAgICAiIiJSZXBsYWNlIG5vbi1wcmludGluZyBjaGFycyB3aXRoIGVzY2FwZSBzZXF1ZW5jZXMsIHJpZ2h0LXN0cmlwLgogICAgICAgTGltaXQgcyB0byBtYXhfbGVuIGJ5IHNuaXBwaW5nIG91dCBiaXRzIGluIHRoZSBtaWRkbGUuCiAgICAiIiIKICAgIHJlc3VsdCA9ICcnCiAgICBpZiBsZW4ocykgPiBtYXhfbGVuOgogICAgICAgIHMgPSBzWzA6IG1heF9sZW4gLy8gMl0gKyAiXG4qKiogPHNuaXA+ICoqKlxuIiArIHNbLW1heF9sZW4gLy8gMjpdCiAgICBsaW5lcyA9IHMucnN0cmlwKCkuc3BsaXRsaW5lcygpCiAgICBmb3IgbGluZSBpbiBsaW5lczoKICAgICAgICBmb3IgYyBpbiBsaW5lLnJzdHJpcCgpICsgJ1xuJzoKICAgICAgICAgICAgaWYgYyA8ICcgJyBhbmQgYyAhPSAnXG4nOgogICAgICAgICAgICAgICAgaWYgYyA9PSAnXHQnOgogICAgICAgICAgICAgICAgICAgIGMgPSByJ1x0JwogICAgICAgICAgICAgICAgZWxpZiBjID09ICdccic6CiAgICAgICAgICAgICAgICAgICAgYyA9IHInXHInCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIGMgPSByJ1x7OjAzb30nLmZvcm1hdChvcmQoYykpCiAgICAgICAgICAgIHJlc3VsdCArPSBjCiAgICByZXR1cm4gcmVzdWx0LnJzdHJpcCgpCg==</file>
<file name="__tester.py" path="/" encoding="base64">IiIiVGhlIGdlbmVyaWMgKG11bHRpLWxhbmd1YWdlKSBtYWluIHRlc3RpbmcgY2xhc3MgdGhhdCBkb2VzIGFsbCB0aGUgd29yayAtIHRyaWFsIGNvbXBpbGUsIHN0eWxlIGNoZWNrcywKICAgcnVuIGFuZCBncmFkZS4KIiIiCmZyb20gX19yZXN1bHR0YWJsZSBpbXBvcnQgUmVzdWx0VGFibGUKaW1wb3J0IGh0bWwKaW1wb3J0IG9zCmltcG9ydCByZQppbXBvcnQgX19sYW5ndWFnZXRhc2sgYXMgbGFuZ3VhZ2V0YXNrCmltcG9ydCBiYXNlNjQKCgojIFZhbHVlcyBvZiBRVUVTVElPTi5wcmVjaGVjayBmaWVsZApQUkVDSEVDS19ESVNBQkxFRCA9IDAKUFJFQ0hFQ0tfRU1QVFkgPSAxClBSRUNIRUNLX0VYQU1QTEVTID0gMgpQUkVDSEVDS19TRUxFQ1RFRCA9IDMKUFJFQ0hFQ0tfQUxMID0gNAoKIyBWYWx1ZXMgb2YgdGVzdHR5cGUKVFlQRV9OT1JNQUwgPSAwClRZUEVfUFJFQ0hFQ0tPTkxZID0gMQpUWVBFX0JPVEggPSAyCgojIEdsb2JhbCBtZXNzYWdlIGZvciB3aGVuIGEgdGVzdC1zdWl0ZSB0aW1lb3V0IG9jY3VycwpUSU1FT1VUX01FU1NBR0UgPSAiIiJBIHRpbWVvdXQgb2NjdXJyZWQgd2hlbiBydW5uaW5nIHRoZSB3aG9sZSB0ZXN0IHN1aXRlIGFzIGEgc2luZ2xlIHByb2dyYW0uClRoaXMgaXMgdXN1YWxseSBkdWUgdG8gYW4gZW5kbGVzcyBsb29wIGluIHlvdXIgY29kZSBidXQgY2FuIGFsc28gYXJpc2UgaWYgeW91ciBjb2RlIGlzIHZlcnkgaW5lZmZpY2llbnQKYW5kIHRoZSBhY2N1bXVsYXRlZCB0aW1lIG92ZXIgYWxsIHRlc3RzIGlzIGV4Y2Vzc2l2ZS4gUGxlYXNlIGFzayBhIHR1dG9yIG9yIHlvdXIgbGVjdHVyZXIgaWYgeW91IG5lZWQgaGVscAp3aXRoIG1ha2luZyB5b3VyIHByb2dyYW0gbW9yZSBlZmZpY2llbnQuIiIiCgoKZGVmIGdldF9qcGVnX2I2NChmaWxlbmFtZSk6CiAgICAiIiJSZXR1cm4gdGhlIGNvbnRlbnRzIG9mIHRoZSBnaXZlbiBmaWxlIChhc3N1bWVkIHRvIGJlIGpwZWcpIGFzIGEgYmFzZTY0CiAgICAgICBlbmNvZGVkIHN0cmluZyBpbiB1dGYtOC4KICAgICIiIgogICAgd2l0aCBvcGVuKGZpbGVuYW1lLCAnYnInKSBhcyBmaW46CiAgICAgICAgY29udGVudHMgPSBmaW4ucmVhZCgpCgogICAgcmV0dXJuIGJhc2U2NC5iNjRlbmNvZGUoY29udGVudHMpLmRlY29kZSgndXRmOCcpCgoKY2xhc3MgVGVzdGVyOgogICAgZGVmIF9faW5pdF9fKHNlbGYsIHBhcmFtcywgdGVzdGNhc2VzKToKICAgICAgICAiIiJJbml0aWFsaXNlIHRoZSBpbnN0YW5jZSwgZ2l2ZW4gdGhlIHRlc3Qgb2YgdGVtcGxhdGUgYW5kIGdsb2JhbCBwYXJhbWV0ZXJzIHBsdXMKICAgICAgICAgICBhbGwgdGhlIHRlc3RjYXNlcy4gUGFyYW1ldGVycyByZXF1aXJlZCBieSB0aGlzIGJhc2UgY2xhc3MgYW5kIGFsbCBzdWJjbGFzc2VzIGFyZToKICAgICAgICAgICAgICAgJ1NUVURFTlRfQU5TV0VSJzogY29kZSBzdWJtaXR0ZWQgYnkgdGhlIHN0dWRlbnQKICAgICAgICAgICAgICAgJ1NFUEFSQVRPUic6IHRoZSBzdHJpbmcgdG8gYmUgdXNlZCB0byBzZXBhcmF0ZSB0ZXN0cyBpbiB0aGUgb3V0cHV0CiAgICAgICAgICAgICAgICdBTExfT1JfTk9USElORzogdHJ1ZSBpZiBncmFkaW5nIGlzIGFsbC1vci1ub3RoaW5nCiAgICAgICAgICAgICAgICdzdGRpbmZyb21leHRyYSc6IHRydWUgaWYgdGhlIHRlc3QtY2FzZSAnZXh0cmEnIGZpZWxkIGlzIHRvIGJlIHVzZWQgZm9yCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YW5kYXJkIGlucHV0IHJhdGhlciB0aGFuIHRoZSB1c3VhbCBzdGRpbiBmaWVsZAogICAgICAgICAgICAgICAncnVudGVzdHNzaW5nbHknOiB0cnVlIHRvIGZvcmNlIGEgc2VwYXJhdGUgcnVuIGZvciBlYWNoIHRlc3QgY2FzZQogICAgICAgICAgICAgICAnc3RkaW5mcm9tZXh0cmEnOiB0cnVlIGlmIHRoZSBleHRyYSBmaWVsZCBpcyB1c2VkIGZvciBzdGFuZGFyZCBpbnB1dCAobGVnYWN5IHVzZSBvbmx5KQogICAgICAgICAgICAgICAndGVzdGlzYmFzaCc6IHRydWUgaWYgdGVzdHMgYXJlIGJhc2ggY29tbWFuZCBsaW5lKHMpIHJhdGhlciB0aGFuIHRoZSBkZWZhdWx0IGRpcmVjdCBleGVjdXRpb24KICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiB0aGUgY29tcGlsZWQgcHJvZ3JhbS4gVGhpcyBjYW4gYmUgdXNlZCB0byBzdXBwbHkgY29tbWFuZCBsaW5lIGFyZ3VtZW50cy4KCiAgICAgICAgIiIiCiAgICAgICAgc2VsZi5zdHVkZW50X2Fuc3dlciA9IHNlbGYuY2xlYW4ocGFyYW1zWydTVFVERU5UX0FOU1dFUiddKQogICAgICAgIHNlbGYuc2VwYXJhdG9yID0gcGFyYW1zWydTRVBBUkFUT1InXQogICAgICAgIHNlbGYuYWxsX29yX25vdGhpbmcgPSBwYXJhbXNbJ0FMTF9PUl9OT1RISU5HJ10KICAgICAgICBzZWxmLnBhcmFtcyA9IHBhcmFtcwogICAgICAgIHNlbGYudGVzdGNhc2VzID0gc2VsZi5maWx0ZXJfdGVzdHModGVzdGNhc2VzKQogICAgICAgIHNlbGYucmVzdWx0X3RhYmxlID0gUmVzdWx0VGFibGUocGFyYW1zKQogICAgICAgIHNlbGYucmVzdWx0X3RhYmxlLnNldF9oZWFkZXIoc2VsZi50ZXN0Y2FzZXMpCgogICAgICAgICMgSXQgaXMgYXNzdW1lZCB0aGF0IGluIGdlbmVyYWwgc3ViY2xhc3NlcyB3aWxsIHByZWZpeCBzdHVkZW50IGNvZGUgYnkgYSBwcmVsdWRlIGFuZAogICAgICAgICMgcG9zdGZpeCBpdCBieSBhIHBvc3RsdWRlLgogICAgICAgIHNlbGYucHJlbHVkZSA9ICcnCiAgICAgICAgc2VsZi5wcmVsdWRlX2xlbmd0aCA9IDAKICAgICAgICBzZWxmLnBvc3RsdWRlID0gJycKCiAgICAgICAgc2VsZi50YXNrID0gTm9uZSAgIyBTVUJDTEFTUyBNVVNUIERFRklORSBUSElTCgogICAgZGVmIGZpbHRlcl90ZXN0cyhzZWxmLCB0ZXN0Y2FzZXMpOgogICAgICAgICIiIlJldHVybiB0aGUgcmVsZXZhbnQgc3Vic2V0IG9mIHRoZSBxdWVzdGlvbidzIHRlc3RjYXNlcy4KICAgICAgICAgICBUaGlzIHdpbGwgYmUgYWxsIHRlc3RjYXNlcyBub3QgbWFya2VkIHByZWNoZWNrLW9ubHkgaWYgaXQncyBub3QgYSBwcmVjaGVjayBvciBhbGwgdGVzdGNhc2VzIGlmIGl0IGlzIGEKICAgICAgICAgICBwcmVjaGVjayBhbmQgdGhlIHF1ZXN0aW9uIHByZWNoZWNrIGlzIHNldCB0byAiQWxsIiwgb3IgdGhlIGFwcHJvcHJpYXRlIHN1YnNldCBpbiBhbGwgb3RoZXIgY2FzZXMuCiAgICAgICAgIiIiCiAgICAgICAgaWYgbm90IHNlbGYucGFyYW1zWydJU19QUkVDSEVDSyddOgogICAgICAgICAgICByZXR1cm4gW3Rlc3QgZm9yIHRlc3QgaW4gdGVzdGNhc2VzIGlmIHRlc3QudGVzdHR5cGUgIT0gVFlQRV9QUkVDSEVDS09OTFldCiAgICAgICAgZWxpZiBzZWxmLnBhcmFtc1snUVVFU1RJT05fUFJFQ0hFQ0snXSA9PSBQUkVDSEVDS19BTEw6CiAgICAgICAgICAgIHJldHVybiB0ZXN0Y2FzZXMKICAgICAgICBlbGlmIHNlbGYucGFyYW1zWydRVUVTVElPTl9QUkVDSEVDSyddID09IFBSRUNIRUNLX0VNUFRZOgogICAgICAgICAgICByZXR1cm4gW10KICAgICAgICBlbGlmIHNlbGYucGFyYW1zWydRVUVTVElPTl9QUkVDSEVDSyddID09IFBSRUNIRUNLX0VYQU1QTEVTOgogICAgICAgICAgICByZXR1cm4gW3Rlc3QgZm9yIHRlc3QgaW4gdGVzdGNhc2VzIGlmIHRlc3QudXNlYXNleGFtcGxlXQogICAgICAgIGVsaWYgc2VsZi5wYXJhbXNbJ1FVRVNUSU9OX1BSRUNIRUNLJ10gPT0gUFJFQ0hFQ0tfU0VMRUNURUQ6CiAgICAgICAgICAgIHJldHVybiBbdGVzdCBmb3IgdGVzdCBpbiB0ZXN0Y2FzZXMgaWYgdGVzdC50ZXN0dHlwZSBpbiBbVFlQRV9QUkVDSEVDS09OTFksIFRZUEVfQk9USF1dCgogICAgZGVmIHN0eWxlX2Vycm9ycyhzZWxmKToKICAgICAgICAiIiJSZXR1cm4gYSBsaXN0IG9mIGFsbCB0aGUgc3R5bGUgZXJyb3JzLiBJbXBsZW1lbnRhdGlvbiBpcyBsYW5ndWFnZSBkZXBlbmRlbnQuCiAgICAgICAgICAgRGVmYXVsdCBpcyBubyBzdHlsZSBjaGVja2luZy4KICAgICAgICAiIiIKICAgICAgICByZXR1cm4gW10KCiAgICBkZWYgc2luZ2xlX3Byb2dyYW1fYnVpbGRfcG9zc2libGUoc2VsZik6CiAgICAgICAgIiIiUmV0dXJuIHRydWUgaWYgYW5kIG9ubHkgaWYgdGhlIGN1cnJlbnQgY29uZmlndXJhdGlvbiBwZXJtaXRzIGEgc2luZ2xlIHByb2dyYW0gdG8gYmUKICAgICAgICAgICBidWlsdCBhbmQgdHJpZWQgY29udGFpbmluZyBhbGwgdGVzdHMuIEl0IHNob3VsZCBiZSB0cnVlIGZvciB3cml0ZS1hLXByb2dyYW0gcXVlc3Rpb25zIGFuZAogICAgICAgICAgIGNvbmRpdGlvbmFsbHkgdHJ1ZSBmb3Igb3RoZXIgdHlwZXMgb2YgcXVlc3Rpb25zIHRoYXQgYWxsb3cgYSAiY29tYmluYXRvciIgYXBwcm9hY2gsCiAgICAgICAgICAgZGVwZW5kZW50IG9uIHRoZSBwcmVzZW5jZSBvZiBzdGRpbnMgaW4gdGVzdHMgYW5kIG90aGVyIHN1Y2ggY29uZGl0aW9ucy4KICAgICAgICAiIiIKICAgICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKCJUZXN0ZXIgbXVzdCBoYXZlIGEgc2luZ2xlX3Byb2dyYW1fYnVpbGRfcG9zc2libGUgbWV0aG9kIikKCiAgICBkZWYgYWRqdXN0X2Vycm9yX2xpbmVfbnVtcyhzZWxmLCBlcnJvcik6CiAgICAgICAgIiIiR2l2ZW4gYSBydW50aW1lIGVycm9yIG1lc3NhZ2UsIGFkanVzdCBpdCBhcyBtYXkgYmUgcmVxdWlyZWQgYnkgdGhlCiAgICAgICAgICAgbGFuZ3VhZ2UsIGUuZy4gYWRqdXN0aW5nIGxpbmUgbnVtYmVycwogICAgICAgICIiIgogICAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoIlRlc3RlciBtdXN0IGhhdmUgYW4gYWRqdXN0X2Vycm9yX2xpbmVfbnVtcyBtZXRob2QiKQoKICAgIGRlZiBzaW5nbGVfcnVuX3Bvc3NpYmxlKHNlbGYpOgogICAgICAgICIiIlJldHVybiB0cnVlIGlmIGEgc2luZ2xlIHByb2dyYW0gaGFzIGJlZW4gYnVpbHQgYW5kIGl0IGlzIHBvc3NpYmxlIHRvIHVzZSB0aGF0IGluIGEgc2luZ2xlIHJ1bgogICAgICAgICAgIHdpdGggYWxsIHRlc3RzLgogICAgICAgICIiIgogICAgICAgIHJldHVybiAoc2VsZi50YXNrLmV4ZWN1dGFibGVfYnVpbHQKICAgICAgICAgICAgICAgIGFuZCBub3Qgc2VsZi5wYXJhbXNbJ3J1bnRlc3Rzc2luZ2x5J10KICAgICAgICAgICAgICAgIGFuZCBub3Qgc2VsZi5yZXN1bHRfdGFibGUuaGFzX3N0ZGlucwogICAgICAgICAgICAgICAgYW5kIG5vdCBzZWxmLnBhcmFtc1sndGVzdGlzYmFzaCddKQoKICAgIGRlZiBtYWtlX3Rlc3RfcG9zdGx1ZGUoc2VsZiwgdGVzdGNhc2VzKToKICAgICAgICAiIiJSZXR1cm4gdGhlIHBvc3RsdWRlIHRlc3RpbmcgY29kZSBjb250YWluaW5nIGFsbCB0aGUgdGVzdGNvZGUgZnJvbQogICAgICAgICAgIHRoZSBnaXZlbiBsaXN0IG9mIHRlc3RjYXNlcyAod2hpY2ggbWF5IGJlIHRoZSBmdWxsIHNldCBvciBhIHNpbmdsZXRvbiBsaXN0KS4KICAgICAgICAgICBBIHNlcGFyYXRvciBtdXN0IGJlIHByaW50ZWQgYmV0d2VlbiB0ZXN0Y2FzZSBvdXRwdXRzLiIiIgogICAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoIlRlc3RlciBtdXN0IGhhdmUgYSBtYWtlX3Rlc3RfcG9zdGx1ZGUgbWV0aG9kIikKCiAgICBkZWYgdHJpYWxfY29tcGlsZShzZWxmKToKICAgICAgICAiIiJUaGlzIGZ1bmN0aW9uIGlzIHRoZSBmaXJzdCBjaGVjayBvbiB0aGUgc3ludGFjdGljIGNvcnJlY3RuZXNzIG9mIHRoZSBzdWJtaXR0ZWQgY29kZS4KICAgICAgICAgICBJdCBpcyBjYWxsZWQgYmVmb3JlIGFueSBzdHlsZSBjaGVja3MgYXJlIGRvbmUuIEZvciBjb21waWxlZCBsYW5ndWFnZXMgaXQgc2hvdWxkIGdlbmVyYWxseQogICAgICAgICAgIGNhbGwgdGhlIHN0YW5kYXJkIGxhbmd1YWdlIGNvbXBpbGVyIG9uIHRoZSBzdHVkZW50IHN1Ym1pdHRlZCBjb2RlIHdpdGggYW55IHJlcXVpcmVkIHByZWx1ZGUKICAgICAgICAgICBhZGRlZCBhbmQsIGlmIHBvc3NpYmxlLCBhbGwgdGVzdHMgaW5jbHVkZWQuIENvbXBpbGVFcnJvciBzaG91bGQgYmUgcmFpc2VkIGlmIHRoZSBjb21waWxlIGZhaWxzLAogICAgICAgICAgIHdoaWNoIHdpbGwgYWJvcnQgYWxsIGZ1cnRoZXIgdGVzdGluZy4KICAgICAgICAgICBJZiBwb3NzaWJsZSBhIGNvbXBsZXRlIHJlYWR5LXRvLXJ1biBleGVjdXRhYmxlIHNob3VsZCBiZSBidWlsdCBhcyB3ZWxsOyBpZiB0aGlzIHN1Y2NlZWRzLCB0aGUKICAgICAgICAgICBMYW5ndWFnZVRhc2tzICdleGVjdXRhYmxlX2J1aWx0JyBhdHRyaWJ1dGUgc2hvdWxkIGJlIHNldC4gVGhpcyBzaG91bGQgYmUgcG9zc2libGUgZm9yIHdyaXRlLWEtcHJvZ3JhbQogICAgICAgICAgIHF1ZXN0aW9ucyBvciBmb3Igd3JpdGUtYS1mdW5jdGlvbiBxdWVzdGlvbnMgd2hlbiB0aGVyZSBpcyBubyBzdGRpbiBkYXRhIGluIGFueSBvZiB0aGUgdGVzdHMuCgogICAgICAgICAgIEludGVycHJldGVkIGxhbmd1YWdlcyBzaG91bGQgcGVyZm9ybSB3aGF0IHN5bnRheCBjaGVja3MgYXJlIHBvc3NpYmxlIHVzaW5nIHRoZSBzdGFuZGFyZCBsYW5ndWFnZSB0b29scy4KICAgICAgICAgICBJZiB0aG9zZSBjaGVja3Mgc3VjY2VlZGVkLCB0aGV5IHNob3VsZCBhbHNvIGF0dGVtcHQgdG8gY29uc3RydWN0IGEgc291cmNlIHByb2dyYW0gdGhhdCBpbmNvcnBvcmF0ZXMgYWxsCiAgICAgICAgICAgdGhlIGRpZmZlcmVudCB0ZXN0cyAodGhlIG9sZCAiY29tYmluYXRvciIgYXBwcm9hY2gpIGFuZCBlbnN1cmUgdGhlIHRhc2sncyAnZXhlY3V0YWJsZV9idWlsdCcgYXR0cmlidXRlCiAgICAgICAgICAgaXMgVHJ1ZS4KCiAgICAgICAgICAgVGhlIGZvbGxvd2luZyBpbXBsZW1lbnRhdGlvbiBpcyBzdWZmaWNpZW50IGZvciBzdGFuZGFyZCBjb21waWxlZCBsYW5ndWFnZXMgbGlrZSBDLCBDKyssIEphdmEuIEl0CiAgICAgICAgICAgbWF5IG5lZWQgb3ZlcnJpZGluZyBmb3Igb3RoZXIgbGFuZ3VhZ2VzLgogICAgICAgICIiIgogICAgICAgIGlmIHNlbGYuc2luZ2xlX3Byb2dyYW1fYnVpbGRfcG9zc2libGUoKToKICAgICAgICAgICAgc2VsZi5zZXR1cF9mb3JfdGVzdF9ydW5zKHNlbGYudGVzdGNhc2VzKQogICAgICAgICAgICBtYWtlX2V4ZWN1dGFibGUgPSBUcnVlCiAgICAgICAgZWxzZToKICAgICAgICAgICAgc2VsZi5wb3N0bHVkZSA9ICcnCiAgICAgICAgICAgIHNlbGYudGFzay5zZXRfY29kZShzZWxmLnByZWx1ZGUgKyBzZWxmLnN0dWRlbnRfYW5zd2VyLCBzZWxmLnByZWx1ZGVfbGVuZ3RoKQogICAgICAgICAgICBtYWtlX2V4ZWN1dGFibGUgPSBGYWxzZQoKICAgICAgICBzZWxmLnRhc2suY29tcGlsZShtYWtlX2V4ZWN1dGFibGUpICAjIENvdWxkIHJhaXNlIENvbXBpbGVFcnJvcgoKICAgIGRlZiBzZXR1cF9mb3JfdGVzdF9ydW5zKHNlbGYsIHRlc3RzKToKICAgICAgICAiIiJTZXQgdGhlIGNvZGUgYW5kIHByZWx1ZGUgbGVuZ3RoIGFzIGFwcHJvcHJpYXRlIGZvciBhIHJ1biB3aXRoIGFsbCB0aGUgZ2l2ZW4gdGVzdHMuIE1heSBiZSBjYWxsZWQgd2l0aAogICAgICAgICAgIGp1c3QgYSBzaW5nbGV0b24gbGlzdCBmb3IgdGVzdHMgaWYgc2luZ2xlX3Byb2dyYW1fYnVpbGRfcG9zc2libGUgaGFzIHJldHVybmVkIGZhbHNlIG9yIGlmIHRlc3Rpbmcgd2l0aAogICAgICAgICAgIG11bHRpcGxlIHRlc3RzIGhhcyBnaXZlbiBleGNlcHRpb25zLgogICAgICAgICAgIFRoaXMgaW1wbGVtZW50YXRpb24gbWF5IG5lZWQgdG8gYmUgb3ZlcnJpZGRlbiwgZS5nLiBpZiB0aGUgc3R1ZGVudCBjb2RlIHNob3VsZCBmb2xsb3cgdGhlIHRlc3QgY29kZSwgYXMKICAgICAgICAgICBzYXkgaW4gTWF0bGFiIHNjcmlwdHMuCiAgICAgICAgIiIiCiAgICAgICAgc2VsZi5wb3N0bHVkZSA9IHNlbGYubWFrZV90ZXN0X3Bvc3RsdWRlKHRlc3RzKQogICAgICAgIHNlbGYudGFzay5zZXRfY29kZShzZWxmLnByZWx1ZGUgKyBzZWxmLnN0dWRlbnRfYW5zd2VyICsgc2VsZi5wb3N0bHVkZSwgc2VsZi5wcmVsdWRlX2xlbmd0aCkKCiAgICBkZWYgcnVuX2FsbF90ZXN0cyhzZWxmKToKICAgICAgICAiIiJSdW4gYWxsIHRoZSB0ZXN0cywgbGVhdmluZyBzZWxmLlJlc3VsdFRhYmxlIG9iamVjdCBjb250YWluaW5nIGFsbCB0ZXN0IHJlc3VsdHMuCiAgICAgICAgICAgQ2FuIHJhaXNlIENvbXBpbGVFcnJvciBvciBSdW5FcnJvciBpZiB0aGluZ3MgYnJlYWsuCiAgICAgICAgICAgSWYgYW55IHJ1bnRpbWUgZXJyb3JzIG9jY3VyIG9uIHRoZSBmdWxsIHRlc3QsIGRyb3AgYmFjayB0byBydW5uaW5nIHRlc3RzIHNpbmdseS4KICAgICAgICAiIiIKICAgICAgICBkb25lID0gRmFsc2UKICAgICAgICBpZiBzZWxmLnNpbmdsZV9ydW5fcG9zc2libGUoKToKICAgICAgICAgICAgIyBXZSBoYXZlIGFuIGV4ZWN1dGFibGUgcmVhZHkgdG8gZ28sIHdpdGggbm8gc3RkaW5zIG9yIG90aGVyIHNob3cgc3RvcHBlcnMKICAgICAgICAgICAgb3V0cHV0LCBlcnJvciA9IHNlbGYudGFzay5ydW5fY29kZSgpCiAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5yc3RyaXAoKSArICdcbicKICAgICAgICAgICAgZXJyb3IgPSBlcnJvci5zdHJpcCgpICsgJ1xuJwoKICAgICAgICAgICAgIyBHZW5lcmF0ZSBhIHJlc3VsdCB0YWJsZSB1c2luZyBhbGwgYXZhaWxhYmxlIHRlc3QgZGF0YS4KICAgICAgICAgICAgcmVzdWx0cyA9IG91dHB1dC5zcGxpdChzZWxmLnNlcGFyYXRvciArICdcbicpCiAgICAgICAgICAgIGVycm9ycyA9IGVycm9yLnNwbGl0KHNlbGYuc2VwYXJhdG9yICsgJ1xuJykKICAgICAgICAgICAgaWYgbGVuKHJlc3VsdHMpID09IGxlbihlcnJvcnMpOgogICAgICAgICAgICAgICAgbWVyZ2VkX3Jlc3VsdHMgPSBbXQogICAgICAgICAgICAgICAgZm9yIHJlc3VsdCwgZXJyb3IgaW4gemlwKHJlc3VsdHMsIGVycm9ycyk6CiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJzdHJpcCgpICsgJ1xuJwogICAgICAgICAgICAgICAgICAgIGlmIGVycm9yLnN0cmlwKCk6CiAgICAgICAgICAgICAgICAgICAgICAgIGFkanVzdGVkX2Vycm9yID0gc2VsZi5hZGp1c3RfZXJyb3JfbGluZV9udW1zKGVycm9yLnJzdHJpcCgpKQogICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xuKioqIFJVTiBFUlJPUiAqKipcbicgKyBhZGp1c3RlZF9lcnJvcgogICAgICAgICAgICAgICAgICAgIG1lcmdlZF9yZXN1bHRzLmFwcGVuZChyZXN1bHQpCgogICAgICAgICAgICAgICAgbWlzc2VkX3Rlc3RzID0gbGVuKHNlbGYudGVzdGNhc2VzKSAtIGxlbihtZXJnZWRfcmVzdWx0cykKCiAgICAgICAgICAgICAgICBmb3IgdGVzdCwgb3V0cHV0IGluIHppcChzZWxmLnRlc3RjYXNlcywgbWVyZ2VkX3Jlc3VsdHMpOgogICAgICAgICAgICAgICAgICAgIHNlbGYucmVzdWx0X3RhYmxlLmFkZF9yb3codGVzdCwgb3V0cHV0KQoKICAgICAgICAgICAgICAgIHNlbGYucmVzdWx0X3RhYmxlLnRlc3RzX21pc3NlZChtaXNzZWRfdGVzdHMpCiAgICAgICAgICAgICAgICBpZiBzZWxmLnRhc2sudGltZWRfb3V0OgogICAgICAgICAgICAgICAgICAgIHNlbGYucmVzdWx0X3RhYmxlLnJlY29yZF9nbG9iYWxfZXJyb3IoVElNRU9VVF9NRVNTQUdFKQogICAgICAgICAgICAgICAgZG9uZSA9IFRydWUKCiAgICAgICAgICAgIGlmIG5vdCBkb25lOgogICAgICAgICAgICAgICAgIyBTb21ldGhpbmcgYnJva2UuIFdlIHdpbGwgbmVlZCB0byBydW4gZWFjaCB0ZXN0IGNhc2Ugc2VwYXJhdGVseQogICAgICAgICAgICAgICAgc2VsZi50YXNrLmV4ZWN1dGFibGVfYnVpbHQgPSBGYWxzZQogICAgICAgICAgICAgICAgc2VsZi5yZXN1bHRfdGFibGUucmVzZXQoKQoKICAgICAgICBpZiBub3QgZG9uZToKICAgICAgICAgICAgIyBJZiBhIHNpbmdsZSBydW4gaXNuJ3QgYXBwcm9wcmlhdGUsIGRvIGEgc2VwYXJhdGUgcnVuIGZvciBlYWNoIHRlc3QgY2FzZS4KICAgICAgICAgICAgYnVpbGRfZWFjaF90ZXN0ID0gbm90IHNlbGYudGFzay5leGVjdXRhYmxlX2J1aWx0CiAgICAgICAgICAgIGZvciBpX3Rlc3QsIHRlc3QgaW4gZW51bWVyYXRlKHNlbGYudGVzdGNhc2VzKToKICAgICAgICAgICAgICAgIGlmIGJ1aWxkX2VhY2hfdGVzdDoKICAgICAgICAgICAgICAgICAgICBzZWxmLnNldHVwX2Zvcl90ZXN0X3J1bnMoW3Rlc3RdKQogICAgICAgICAgICAgICAgICAgIHNlbGYudGFzay5jb21waWxlKFRydWUpCiAgICAgICAgICAgICAgICBzdGFuZGFyZF9pbnB1dCA9IHRlc3QuZXh0cmEgaWYgc2VsZi5wYXJhbXNbJ3N0ZGluZnJvbWV4dHJhJ10gZWxzZSB0ZXN0LnN0ZGluCiAgICAgICAgICAgICAgICBpZiBzZWxmLnBhcmFtc1sndGVzdGlzYmFzaCddOgogICAgICAgICAgICAgICAgICAgIG91dHB1dCwgZXJyb3IgPSBzZWxmLnRhc2sucnVuX2NvZGUoc3RhbmRhcmRfaW5wdXQsIHRlc3QudGVzdGNvZGUpCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIG91dHB1dCwgZXJyb3IgPSBzZWxmLnRhc2sucnVuX2NvZGUoc3RhbmRhcmRfaW5wdXQpCiAgICAgICAgICAgICAgICBhZGp1c3RlZF9lcnJvciA9IHNlbGYuYWRqdXN0X2Vycm9yX2xpbmVfbnVtcyhlcnJvci5yc3RyaXAoKSkKICAgICAgICAgICAgICAgIHNlbGYucmVzdWx0X3RhYmxlLmFkZF9yb3codGVzdCwgb3V0cHV0LCBhZGp1c3RlZF9lcnJvcikKICAgICAgICAgICAgICAgIGlmIGVycm9yIGFuZCBzZWxmLnBhcmFtc1snYWJvcnRvbmVycm9yJ106CiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZXN1bHRfdGFibGUudGVzdHNfbWlzc2VkKGxlbihzZWxmLnRlc3RjYXNlcykgLSBpX3Rlc3QgLSAxKQogICAgICAgICAgICAgICAgICAgIGJyZWFrCgogICAgZGVmIGNvbXBpbGVfYW5kX3J1bihzZWxmKToKICAgICAgICAiIiJQaGFzZSBvbmUgb2YgdGhlIHRlc3Qgb3BlcmF0aW9uOiBkbyBhIHRyaWFsIGNvbXBpbGUgYW5kIHRoZW4sIGlmIGFsbCBpcyB3ZWxsIGFuZCBpdCdzIG5vdCBhIHByZWNoZWNrLAogICAgICAgICAgIGNvbnRpbnVlIG9uIHRvIHJ1biBhbGwgdGVzdHMuCiAgICAgICAgICAgUmV0dXJuIGEgdHVwbGUgbWFyaywgZXJyb3JzIHdoZXJlIG1hcmsgaXMgYSBmcmFjdGlvbiBpbiAwIC0gMSBhbmQgZXJyb3JzIGlzIGEgbGlzdCBvZiBhbGwgdGhlIGVycm9ycy4KICAgICAgICAgICBzZWxmLnRlc3RfcmVzdWx0cyBjb250YWlucyBhbGwgdGhlIHRlc3QgZGV0YWlscy4KICAgICAgICAiIiIKICAgICAgICBtYXJrID0gMAogICAgICAgIGVycm9ycyA9IFtdCgogICAgICAgICMgRG8gYSB0cmlhbCBjb21waWxlLCB0aGVuIGEgc3R5bGUgY2hlY2suIElmIGFsbCBpcyB3ZWxsLCBydW4gdGhlIGNvZGUKICAgICAgICB0cnk6CiAgICAgICAgICAgIHNlbGYudHJpYWxfY29tcGlsZSgpCgogICAgICAgICAgICBpZiBub3Qgc2VsZi5wYXJhbXNbJ25vc3R5bGVjaGVja3MnXToKICAgICAgICAgICAgICAgIGVycm9ycyA9IHNlbGYuc3R5bGVfZXJyb3JzKCkKICAgICAgICAgICAgaWYgbm90IGVycm9yczoKICAgICAgICAgICAgICAgIGlmIHNlbGYucGFyYW1zWydJU19QUkVDSEVDSyddIGFuZCBzZWxmLnBhcmFtc1snUVVFU1RJT05fUFJFQ0hFQ0snXSA8PSAxOgogICAgICAgICAgICAgICAgICAgIG1hcmsgPSAxCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIHNlbGYucnVuX2FsbF90ZXN0cygpCiAgICAgICAgICAgICAgICAgICAgbWF4X21hcmsgPSBzdW0odGVzdC5tYXJrIGZvciB0ZXN0IGluIHNlbGYudGVzdGNhc2VzKQogICAgICAgICAgICAgICAgICAgIG1hcmsgPSBzZWxmLnJlc3VsdF90YWJsZS5nZXRfbWFyaygpIC8gbWF4X21hcmsgICMgRnJhY3Rpb25hbCBtYXJrIDAgLSAxCiAgICAgICAgZXhjZXB0IGxhbmd1YWdldGFzay5Db21waWxlRXJyb3IgYXMgZXJyOgogICAgICAgICAgICBhZGp1c3RlZF9lcnJvciA9IHNlbGYuYWRqdXN0X2Vycm9yX2xpbmVfbnVtcyhzdHIoZXJyKS5yc3RyaXAoKSkKICAgICAgICAgICAgZXJyb3JzLmFwcGVuZCgiQ09NUElMRSBFUlJPUlxuIiArIGFkanVzdGVkX2Vycm9yKQogICAgICAgIGV4Y2VwdCBsYW5ndWFnZXRhc2suUnVuRXJyb3IgYXMgZXJyOgogICAgICAgICAgICBhZGp1c3RlZF9lcnJvciA9IHNlbGYuYWRqdXN0X2Vycm9yX2xpbmVfbnVtcyhzdHIoZXJyKS5yc3RyaXAoKSkKICAgICAgICAgICAgZXJyb3JzLmFwcGVuZCgnUlVOIEVSUk9SXG4nICsgYWRqdXN0ZWRfZXJyb3IpCiAgICAgICAgcmV0dXJuIG1hcmssIGVycm9ycwoKICAgIGRlZiBwcmVydW5faG9vayhzZWxmKToKICAgICAgICAiIiJBIGhvb2sgZm9yIHN1YmNsYXNzZXMgdG8gZG8gaW5pdGlhbCBzZXR1cCBvciBjb2RlIGhhY2tzIGV0YwogICAgICAgICAgIFJldHVybnMgYSBsaXN0IG9mIGVycm9ycywgdG8gd2hpY2ggb3RoZXIgZXJyb3JzIGFyZSBhcHBlbmRlZAogICAgICAgICIiIgogICAgICAgIHJldHVybiBbXQoKICAgIGRlZiBnZXRfYWxsX2ltYWdlc19odG1sKHNlbGYpOgogICAgICAgICIiIlNlYXJjaCB0aGUgY3VycmVudCBkaXJlY3RvcnkgZm9yIGltYWdlcyBuYW1lZCBfaW1hZ2UuKihFeHBlY3RlZHxHb3QpKFxkKykucG5nLgogICAgICAgICAgIEZvciBlYWNoIHN1Y2ggZmlsZSBjb25zdHJ1Y3QgYW4gaHRtbCBpbWcgZWxlbWVudCB3aXRoIHRoZSBkYXRhIGVuY29kZWQKICAgICAgICAgICBpbiBhIGRhdGF1cmwuCiAgICAgICAgICAgSWYgd2UncmUgcnVubmluZyB0aGUgc2FtcGxlIGFuc3dlciwgYWx3YXlzIHJldHVybiBbXSAtIGltYWdlcyB3aWxsIGJlCiAgICAgICAgICAgcGlja2VkIHVwIHdoZW4gd2UgcnVuIHRoZSBhY3R1YWwgYW5zd2VyLgogICAgICAgICAgIFJldHVybnMgYSBsaXN0IG9mIHR1cGxlcyAoaW1nX2VsZW1lbnRzLCBjb2x1bW5fbmFtZSwgcm93X251bWJlcikgd2hlcmUKICAgICAgICAgICBjb2x1bW5fbmFtZSBpcyBlaXRoZXIgJ0V4cGVjdGVkJyBvciAnR290JywgZGVmaW5pbmcgaW4gd2hpY2ggcmVzdWx0IHRhYmxlCiAgICAgICAgICAgY29sdW1uIHRoZSBpbWFnZSBiZWxvbmdzIGFuZCByb3cgbnVtYmVyIGlzIHRoZSByb3cgKDAtb3JpZ2luLCBleGNsdWRpbmcKICAgICAgICAgICB0aGUgaGVhZGVyIHJvdykuCiAgICAgICAgIiIiCiAgICAgICAgaW1hZ2VzID0gW10KICAgICAgICBpZiBzZWxmLnBhcmFtcy5nZXQoJ3J1bm5pbmdfc2FtcGxlX2Fuc3dlcicsIEZhbHNlKToKICAgICAgICAgICAgcmV0dXJuIFtdCiAgICAgICAgaWYgc2VsZi5wYXJhbXNbJ2ltYWdld2lkdGgnXSBpcyBub3QgTm9uZToKICAgICAgICAgICAgd2lkdGhfc3BlYyA9ICIgd2lkdGg9e30iLmZvcm1hdChzZWxmLnBhcmFtc1snaW1hZ2V3aWR0aCddKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHdpZHRoX3NwZWMgPSAiIgogICAgICAgIGZpbGVzID0gc29ydGVkKG9zLmxpc3RkaXIoJy4nKSkKICAgICAgICBmb3IgZmlsZW5hbWUgaW4gZmlsZXM6CiAgICAgICAgICAgIG1hdGNoID0gcmUubWF0Y2gocidfaW1hZ2VbXi5dKlwuKEV4cGVjdGVkfEdvdClcLihcZCspLnBuZycsIGZpbGVuYW1lKQogICAgICAgICAgICBpZiBtYXRjaDoKICAgICAgICAgICAgICAgIGltYWdlX2RhdGEgPSBnZXRfanBlZ19iNjQoZmlsZW5hbWUpCiAgICAgICAgICAgICAgICBpbWdfdGVtcGxhdGUgPSAnPGltZ3t9IHN0eWxlPSJtYXJnaW46M3B4O2JvcmRlcjoxcHggc29saWQgYmxhY2siIHNyYz0iZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCx7fSI+JwogICAgICAgICAgICAgICAgaW1nX2h0bWwgPSBpbWdfdGVtcGxhdGUuZm9ybWF0KHdpZHRoX3NwZWMsIGltYWdlX2RhdGEpCiAgICAgICAgICAgICAgICBjb2x1bW4gPSBtYXRjaC5ncm91cCgxKSAgICMgTmFtZSBvZiBjb2x1bW4KICAgICAgICAgICAgICAgIHJvdyA9IGludChtYXRjaC5ncm91cCgyKSkgIyAwLW9yaWdpbiByb3cgbnVtYmVyCiAgICAgICAgICAgICAgICBpbWFnZXMuYXBwZW5kKChpbWdfaHRtbCwgY29sdW1uLCByb3cpKQogICAgICAgIHJldHVybiBpbWFnZXMKCiAgICBkZWYgdGVzdF9jb2RlKHNlbGYpOgogICAgICAgICIiIlRoZSAibWFpbiBwcm9ncmFtIiBmb3IgdGVzdGluZy4gUmV0dXJucyB0aGUgdGVzdCBvdXRjb21lLCByZWFkeSB0byBiZSBwcmludGVkIGJ5IGpzb24uZHVtcHMiIiIKICAgICAgICBlcnJvcnMgPSBzZWxmLnByZXJ1bl9ob29rKCkKICAgICAgICBpZiBlcnJvcnM6CiAgICAgICAgICAgIG1hcmsgPSAwCiAgICAgICAgZWxzZToKICAgICAgICAgICAgbWFyaywgZXJyb3JzID0gc2VsZi5jb21waWxlX2FuZF9ydW4oKQoKICAgICAgICBvdXRjb21lID0geyJmcmFjdGlvbiI6IG1hcmt9CgogICAgICAgIGVycm9yX3RleHQgPSAnXG4nLmpvaW4oZXJyb3JzKQogICAgICAgICMgVE9ETyAtIGNoZWNrIGlmIGVycm9yIGxpbmUgbnVtYmVycyBhcmUgc3RpbGwgYmVpbmcgY29ycmVjdGVkIGluIEMgYW5kIG1hdGxhYgogICAgICAgIGlmIHNlbGYucGFyYW1zWydJU19QUkVDSEVDSyddOgogICAgICAgICAgICBpZiBtYXJrID09IDE6CiAgICAgICAgICAgICAgICBwcm9sb2d1ZSA9ICI8cCBjbGFzcz0ncHJlY2hlY2tyZXN1bHQnPlBhc3NlZCDwn5mCPC9wPiIKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIHByb2xvZ3VlID0gIjxwIGNsYXNzPSdwcmVjaGVja3Jlc3VsdCc+RmFpbGVkLCBhcyBmb2xsb3dzLjwvcD4iCiAgICAgICAgZWxpZiBlcnJvcnM6CiAgICAgICAgICAgIHByb2xvZ3VlID0gIjxkaXYgY2xhc3M9J2NvZGVydW5uZXItdGVzdC1yZXN1bHRzIGJhZCc+PGgzPlByZS1ydW4gY2hlY2tzIGZhaWxlZDwvaDM+XG4iCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcHJvbG9ndWUgPSAiIgoKICAgICAgICBpZiBwcm9sb2d1ZToKICAgICAgICAgICAgb3V0Y29tZVsncHJvbG9ndWVodG1sJ10gPSBwcm9sb2d1ZSArIHNlbGYuaHRtbGl6ZShlcnJvcl90ZXh0KQoKICAgICAgICBlcGlsb2d1ZSA9ICcnCiAgICAgICAgaW1hZ2VzID0gc2VsZi5nZXRfYWxsX2ltYWdlc19odG1sKCkKICAgICAgICBpZiBpbWFnZXM6CiAgICAgICAgICAgIGZvciAoaW1hZ2UsIGNvbHVtbiwgcm93KSBpbiBpbWFnZXM6CiAgICAgICAgICAgICAgICBzZWxmLnJlc3VsdF90YWJsZS5hZGRfaW1hZ2UoaW1hZ2UsIGNvbHVtbiwgcm93KQogICAgICAgIG91dGNvbWVbJ2NvbHVtbmZvcm1hdHMnXSA9IHNlbGYucmVzdWx0X3RhYmxlLmdldF9jb2x1bW5fZm9ybWF0cygpCgogICAgICAgIGlmIGxlbihzZWxmLnJlc3VsdF90YWJsZS50YWJsZSkgPiAxOgogICAgICAgICAgICBvdXRjb21lWyd0ZXN0cmVzdWx0cyddID0gc2VsZi5yZXN1bHRfdGFibGUuZ2V0X3RhYmxlKCkKICAgICAgICAgICAgb3V0Y29tZVsnc2hvd2RpZmZlcmVuY2VzJ10gPSBUcnVlCgogICAgICAgIGlmIHNlbGYucmVzdWx0X3RhYmxlLmdsb2JhbF9lcnJvcjoKICAgICAgICAgICAgZXBpbG9ndWUgKz0gIjxkaXYgY2xhc3M9J2NvZGVydW5uZXItdGVzdC1yZXN1bHRzIGJhZCc+PGg0PlJ1biBFcnJvcjwvaDQ+PHByZT57fTwvcHJlPjwvZGl2PiIuZm9ybWF0KAogICAgICAgICAgICAgICAgc2VsZi5odG1saXplKHNlbGYucmVzdWx0X3RhYmxlLmdsb2JhbF9lcnJvcikpCgogICAgICAgIGlmIHNlbGYucmVzdWx0X3RhYmxlLmFib3J0ZWQ6CiAgICAgICAgICAgIGVwaWxvZ3VlID0gb3V0Y29tZS5nZXQoJ2VwaWxvZ3VlaHRtbCcsICcnKSArICgKICAgICAgICAgICAgICAgICI8ZGl2IGNsYXNzPSdjb2RlcnVubmVyLXRlc3QtcmVzdWx0cyBiYWQnPlRlc3Rpbmcgd2FzIGFib3J0ZWQgZHVlIHRvIHJ1bnRpbWUgZXJyb3JzLjwvZGl2PiIpCgogICAgICAgIGlmIHNlbGYucmVzdWx0X3RhYmxlLm1pc3NpbmdfdGVzdHMgIT0gMDoKICAgICAgICAgICAgdGVtcGxhdGUgPSAiPGRpdiBjbGFzcz0nY29kZXJ1bm5lci10ZXN0LXJlc3VsdHMgYmFkJz57fSB0ZXN0cyBub3QgcnVuIGR1ZSB0byBwcmV2aW91cyBlcnJvcnMuPC9kaXY+IgogICAgICAgICAgICBlcGlsb2d1ZSArPSB0ZW1wbGF0ZS5mb3JtYXQoc2VsZi5yZXN1bHRfdGFibGUubWlzc2luZ190ZXN0cykKCiAgICAgICAgaWYgc2VsZi5yZXN1bHRfdGFibGUuZmFpbGVkX2hpZGRlbjoKICAgICAgICAgICAgZXBpbG9ndWUgKz0gIjxkaXYgY2xhc3M9J2NvZGVydW5uZXItdGVzdC1yZXN1bHRzIGJhZCc+T25lIG9yIG1vcmUgaGlkZGVuIHRlc3RzIGZhaWxlZC48L2Rpdj4iCgogICAgICAgIGlmIGVwaWxvZ3VlOgogICAgICAgICAgICBvdXRjb21lWydlcGlsb2d1ZWh0bWwnXSA9IGVwaWxvZ3VlCiAgICAgICAgcmV0dXJuIG91dGNvbWUKCiAgICBAc3RhdGljbWV0aG9kCiAgICBkZWYgY2xlYW4oY29kZSk6CiAgICAgICAgIiIiUmV0dXJuIHRoZSBnaXZlbiBjb2RlIHdpdGggdHJhaWxpbmcgd2hpdGUgc3BhY2Ugc3RyaXBwZWQgZnJvbSBlYWNoIGxpbmUiIiIKICAgICAgICByZXR1cm4gJ1xuJy5qb2luKFtsaW5lLnJzdHJpcCgpIGZvciBsaW5lIGluIGNvZGUuc3BsaXQoJ1xuJyldKSArICdcbicKCiAgICBAc3RhdGljbWV0aG9kCiAgICBkZWYgaHRtbGl6ZShtZXNzYWdlKToKICAgICAgICAiIiJBbiBodG1sIHZlcnNpb24gb2YgdGhlIGdpdmVuIGVycm9yIG1lc3NhZ2UiIiIKICAgICAgICByZXR1cm4gJzxwcmU+JyArIGh0bWwuZXNjYXBlKG1lc3NhZ2UpICsgJzwvcHJlPicgaWYgbWVzc2FnZSBlbHNlICcnCg==</file>
<file name="__watchdog.py" path="/" encoding="base64">IyEvdXNyL2Jpbi9weXRob24KIyBmaWxlOiB3YXRjaGRvZy5weQojIGxpY2Vuc2U6IE1JVCBMaWNlbnNlCiMgRnJvbSBodHRwczovL2R6b25lLmNvbS9hcnRpY2xlcy9zaW1wbGUtcHl0aG9uLXdhdGNoZG9nLXRpbWVyCgppbXBvcnQgc2lnbmFsCgpjbGFzcyBXYXRjaGRvZyhFeGNlcHRpb24pOgogICAgZGVmIF9faW5pdF9fKHNlbGYsIHRpbWUpOgogICAgICAgICIiIlNldCB1cCBhIHRpbWVyIGFsYXJtIHRvIGdvIG9mZiBpbiAndGltZScgc2Vjcy4iIiIKICAgICAgICBzZWxmLnRpbWUgPSB0aW1lCgogICAgZGVmIF9fZW50ZXJfXyhzZWxmKToKICAgICAgICAiIiJDYWxsZWQgb24gZW50ZXJpbmcgYSAnd2l0aCcgYmxvY2siIiIKICAgICAgICBzaWduYWwuc2lnbmFsKHNpZ25hbC5TSUdBTFJNLCBzZWxmLmhhbmRsZXIpCiAgICAgICAgc2lnbmFsLmFsYXJtKHNlbGYudGltZSkKCiAgICBkZWYgX19leGl0X18oc2VsZiwgdHlwZSwgdmFsdWUsIHRyYWNlYmFjayk6CiAgICAgICAgIiIiRXhpdGluZyB0aGUgd2l0aCBibG9jay4gQ2FuY2VsIHRoZSB3YXRjaGRvZyIiIgogICAgICAgIHNpZ25hbC5hbGFybSgwKQoKICAgIGRlZiBoYW5kbGVyKHNlbGYsIHNpZ251bSwgZnJhbWUpOgogICAgICAgICIiIkFsYXJtIHdlbnQgb2ZmLiBSYWlzZSBXYXRjaGRvZyBleGNlcHRpb24iIiIKICAgICAgICByYWlzZSBzZWxmCgogICAgZGVmIF9fc3RyX18oc2VsZik6CiAgICAgICAgcmV0dXJuICJXYXRjaGRvZyB0aW1lciBleHBpcmVkIGFmdGVyIHt9IHNlY3MiLmZvcm1hdChzZWxmLnRpbWUpCg==</file>
<file name="pytester.py" path="/" encoding="base64">IiIiVGhlIG1haW4gcHl0aG9uLXByb2dyYW0gdGVzdGluZyBjbGFzcyB0aGF0IGRvZXMgYWxsIHRoZSB3b3JrIC0gc3R5bGUgY2hlY2tzLAogICBydW4gYW5kIGdyYWRlLiBBIHN1YmNsYXNzIG9mIHRoZSBnZW5lcmljIHRlc3Rlci4KICAgU2luY2UgZWFjaCB0ZXN0IGNhbiBieSBydW4gd2l0aGluIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIFB5dGhvbiB1c2luZwogICBhbiBleGVjLCB3ZSBhdm9pZCB0aGUgdXN1YWwgY29tcGxpY2F0aW9uIG9mIGNvbWJpbmF0b3JzIGJ5IHJ1bm5pbmcKICAgZWFjaCB0ZXN0IHNlcGFyYXRlbHkgcmVnYXJkbGVzcyBvZiBwcmVzZW5jZSBvZiBzdGRpbiwgdGVzdGNvZGUsIGV0Yy4KIiIiCmltcG9ydCBfX3B5dGFzayBhcyBweXRhc2sKaW1wb3J0IHJlCmZyb20gX190ZXN0ZXIgaW1wb3J0IFRlc3Rlcgpmcm9tIF9fcHlzdHlsZWNoZWNrZXIgaW1wb3J0IFN0eWxlQ2hlY2tlcgoKCmNsYXNzIFB5VGVzdGVyKFRlc3Rlcik6CiAgICBkZWYgX19pbml0X18oc2VsZiwgcGFyYW1zLCB0ZXN0Y2FzZXMpOgogICAgICAgICIiIkluaXRpYWxpc2UgdGhlIGluc3RhbmNlLCBnaXZlbiB0aGUgdGVzdCBvZiB0ZW1wbGF0ZSBhbmQgZ2xvYmFsIHBhcmFtZXRlcnMgcGx1cwogICAgICAgICAgIGFsbCB0aGUgdGVzdGNhc2VzLiBQYXJhbWV0ZXJzIHJlbGV2YW50IHRvIHRoaXMgY2xhc3MgYXJlIGFsbCB0aG9zZSBsaXN0ZWQgZm9yIHRoZSBUZXN0ZXIgY2xhc3MgcGx1cwogICAgICAgICAgICAgICAnZXh0cmEnIHdoaWNoIHRha2VzIHRoZSB2YWx1ZXMgJ3ByZXRlc3QnIG9yICdwb3N0dGVzdCcgKHRoZSBvdGhlciBwb3NzaWJsZSB2YWx1ZSwgJ3N0ZGluJywgaGFzIGJlZW4KICAgICAgICAgICAgICAgaGFuZGxlZCBieSB0aGUgbWFpbiB0ZW1wbGF0ZSkuCiAgICAgICAgICAgQWRkaXRpb25hbGx5IHRoZSBzdXBwb3J0IGNsYXNzZXMgbGlrZSBzdHlsZWNoZWNrZXIgYW5kIHB5cGFyc2VyIG5lZWQgdGhlaXIKICAgICAgICAgICBvd24gcGFyYW1zIC0gcS52LgogICAgICAgICIiIgogICAgICAgIHN1cGVyKCkuX19pbml0X18ocGFyYW1zLCB0ZXN0Y2FzZXMpICAjIE1vc3Qgb2YgdGhlIHRhc2sgaXMgaGFuZGVkIGJ5IHRoZSBnZW5lcmljIHRlc3RlcgoKICAgICAgICAjIFB5LWRlcGVuZGVudCBhdHRyaWJ1dGVzCiAgICAgICAgc2VsZi50YXNrID0gcHl0YXNrLlB5VGFzayhwYXJhbXMpCiAgICAgICAgc2VsZi5wcmVsdWRlID0gJycKCiAgICAgICAgaWYgcGFyYW1zWydpc2Z1bmN0aW9uJ106CiAgICAgICAgICAgIGlmIG5vdCBzZWxmLmhhc19kb2NzdHJpbmcoKToKICAgICAgICAgICAgICAgIHNlbGYucHJlbHVkZSA9ICciIiJEdW1teSBkb2NzdHJpbmcgZm9yIGEgZnVuY3Rpb24iIiJcbicKCiAgICAgICAgaWYgcGFyYW1zWyd1c2VzbWF0cGxvdGxpYiddOgogICAgICAgICAgICBzZWxmLnByZWx1ZGUgKz0gJ1xuJy5qb2luKFsKICAgICAgICAgICAgICAgICdpbXBvcnQgb3MnLAogICAgICAgICAgICAgICAgJ2ltcG9ydCBtYXRwbG90bGliIGFzIF9tcGwnLAogICAgICAgICAgICAgICAgJ19tcGwudXNlKCJBZ2ciKScsCiAgICAgICAgICAgICAgICAnZnJvbSBfX3Bsb3R0b29scyBpbXBvcnQgcHJpbnRfcGxvdF9pbmZvJywKICAgICAgICAgICAgXSkgKyAnXG4nCiAgICAgICAgICAgIHNlbGYucGFyYW1zWydweWxpbnRvcHRpb25zJ10uYXBwZW5kKCItLWRpc2FibGU9dW5ncm91cGVkLWltcG9ydHMiKQoKICAgICAgICBpZiBwYXJhbXNbJ3VzZXNudW1weSddOgogICAgICAgICAgICBzZWxmLnByZWx1ZGUgKz0gICdpbXBvcnQgbnVtcHkgYXMgbnBcbicKICAgICAgICAgICAgc2VsZi5wYXJhbXNbJ3B5bGludG9wdGlvbnMnXS5hcHBlbmQoIi0tZGlzYWJsZT11bnVzZWQtaW1wb3J0LHVuZ3JvdXBlZC1pbXBvcnRzIikKICAgICAgICAgICAgc2VsZi5wYXJhbXNbJ3B5bGludG9wdGlvbnMnXS5hcHBlbmQoIi0tZXh0ZW5zaW9uLXBrZy13aGl0ZWxpc3Q9bnVtcHkiKQoKICAgICAgICBmb3IgaW1wb3J0X3N0cmluZyBpbiBwYXJhbXNbJ2ltcG9ydHMnXToKICAgICAgICAgICAgaWYgJyAnIG5vdCBpbiBpbXBvcnRfc3RyaW5nOgogICAgICAgICAgICAgICAgc2VsZi5wcmVsdWRlICs9ICdpbXBvcnQgJyArIGltcG9ydF9zdHJpbmcgKyAnXG4nCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBzZWxmLnByZWx1ZGUgKz0gaW1wb3J0X3N0cmluZyArICdcbicKCiAgICAgICAgaWYgcGFyYW1zWydwcmVsdWRlJ10gIT0gJyc6CiAgICAgICAgICAgIHNlbGYucHJlbHVkZSArPSAnXG4nICsgcGFyYW1zWydwcmVsdWRlJ10ucnN0cmlwKCkgKyAnXG4nCgogICAgICAgIHRyeToKICAgICAgICAgICAgd2l0aCBvcGVuKCdfcHJlZml4LnB5JykgYXMgcHJlZml4OgogICAgICAgICAgICAgICAgcHJlZml4X2NvZGUgPSBwcmVmaXgucmVhZCgpCiAgICAgICAgICAgICAgICBzZWxmLnByZWx1ZGUgKz0gcHJlZml4X2NvZGUucnN0cmlwKCkgKyAnXG4nCgogICAgICAgIGV4Y2VwdCBGaWxlTm90Rm91bmRFcnJvcjoKICAgICAgICAgICAgcGFzcwoKICAgICAgICBzZWxmLnByZWx1ZGVfbGVuZ3RoID0gbGVuKHNlbGYucHJlbHVkZS5zcGxpdGxpbmVzKCkpCiAgICAgICAgaWYgc2VsZi5oYXNfZG9jc3RyaW5nKCkgYW5kIHNlbGYucHJlbHVkZV9sZW5ndGggPiAwOgogICAgICAgICAgICAjIElmIHdlIGluc2VydCBwcmVsdWRlIGluIGZyb250IG9mIHRoZSBkb2NzdHJpbmcsIHB5bGludCB3aWxsCiAgICAgICAgICAgICMgZ2l2ZSBhIG1pc3NpbmcgZG9jc3RyaW5nIGVycm9yLiBPdXIgaG9ycmlibGUgaGFjayBzb2x1dGlvbiBpcwogICAgICAgICAgICAjIHRvIGluc2VydCBhbiBleHRyYSBkb2NzdHJpbmcgYXQgdGhlIHN0YXJ0IGFuZCB0dXJuIG9mZiB0aGUKICAgICAgICAgICAgIyByZXN1bHRpbmcgJ3N0cmluZyBzdGF0ZW1lbnQgaGFzIG5vIGVmZmVjdCcgZXJyb3IuCiAgICAgICAgICAgIHNlbGYucHJlbHVkZSA9ICciIiJEdW1teSBkb2NzdHJpbmcgZm9yIGEgZnVuY3Rpb24iIiJcbicgKyBzZWxmLnByZWx1ZGUKICAgICAgICAgICAgc2VsZi5wcmVsdWRlX2xlbmd0aCArPSAxCiAgICAgICAgICAgIHNlbGYucGFyYW1zWydweWxpbnRvcHRpb25zJ10uYXBwZW5kKCItLWRpc2FibGU9VzAxMDUiKQogICAgICAgIHNlbGYuc3R5bGVfY2hlY2tlciA9IFN0eWxlQ2hlY2tlcihzZWxmLnByZWx1ZGUsIHNlbGYucGFyYW1zWydTVFVERU5UX0FOU1dFUiddLCBzZWxmLnBhcmFtcykKCiAgICBkZWYgaGFzX2RvY3N0cmluZyhzZWxmKToKICAgICAgICAiIiJUcnVlIGlmIHRoZSBzdHVkZW50IGFuc3dlciBoYXMgYSBkb2NzdHJpbmcsIHdoaWNoIG1lYW5zIHRoYXQsCiAgICAgICAgICAgd2hlbiBzdHJpcHBlZCwgaXQgc3RhcnRzIHdpdGggYSBzdHJpbmcgbGl0ZXJhbC4KICAgICAgICAiIiIKICAgICAgICBwcm9nID0gc2VsZi5wYXJhbXNbJ1NUVURFTlRfQU5TV0VSJ10ubHN0cmlwKCkKICAgICAgICByZXR1cm4gcHJvZy5zdGFydHN3aXRoKCciJykgb3IgcHJvZy5zdGFydHN3aXRoKCInIikKCiAgICBkZWYgc3R5bGVfZXJyb3JzKHNlbGYpOgogICAgICAgICIiIlJldHVybiBhIGxpc3Qgb2YgYWxsIHRoZSBzdHlsZSBlcnJvcnMuIFN0YXJ0IHdpdGggbG9jYWwgdGVzdHMgYW5kIGNvbnRpbnVlIHdpdGggcHlsaW50CiAgICAgICAgICAgb25seSBpZiB0aGVyZSBhcmUgbm8gbG9jYWwgZXJyb3JzLgogICAgICAgICIiIgogICAgICAgIGVycm9ycyA9IFtdCiAgICAgICAgaWYgc2VsZi5wYXJhbXMuZ2V0KCdsb2NhbHByZWNoZWNrcycsIFRydWUpOgogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICBlcnJvcnMgKz0gc2VsZi5zdHlsZV9jaGVja2VyLmxvY2FsX2Vycm9ycygpICMgTm90ZTogcHJlbHVkZSBub3QgaW5jbHVkZWQgc28gZG9uJ3QgYWRqdXN0IGxpbmUgbnVtcwogICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgICAgICAgICBlcnJvcnMgKz0gW3N0cihlKV0KICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIGNoZWNrX2Zvcl9wYXNzaXZlID0gKHNlbGYucGFyYW1zWyd3YXJuaWZwYXNzaXZlb3V0cHV0J10gYW5kIHNlbGYucGFyYW1zWydpc2Z1bmN0aW9uJ10pCiAgICAgICAgICAgICAgICBpZiBjaGVja19mb3JfcGFzc2l2ZSBhbmQgc2VsZi5wYXNzaXZlX291dHB1dCgpOgogICAgICAgICAgICAgICAgICAgIGVycm9ycy5hcHBlbmQoIllvdXIgY29kZSB3YXMgbm90IGV4cGVjdGVkIHRvIGdlbmVyYXRlIGFueSBvdXRwdXQgIiArCiAgICAgICAgICAgICAgICAgICAgICAgICJ3aGVuIGV4ZWN1dGVkIHN0YW5kLWFsb25lLlxuRGlkIHlvdSBhY2NpZGVudGFsbHkgaW5jbHVkZSAiICsKICAgICAgICAgICAgICAgICAgICAgICAgInlvdXIgdGVzdCBjb2RlPyIpCgogICAgICAgIGlmIGxlbihlcnJvcnMpID09IDAgb3Igc2VsZi5wYXJhbXMuZ2V0KCdmb3JjZXB5bGludCcsIEZhbHNlKToKICAgICAgICAgICAgIyBSdW4gcHJlY2hlY2tlcnMgKHB5bGludCwgbXlweSkKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgIyBTdHlsZS1jaGVjayB0aGUgcHJvZ3JhbSB3aXRob3V0IGFueSB0ZXN0IGNhc2VzIG9yIG90aGVyIHBvc3RsdWRlIGFkZGVkCiAgICAgICAgICAgICAgICBlcnJvcnMgKz0gc2VsZi5zdHlsZV9jaGVja2VyLnN0eWxlX2Vycm9ycygpCiAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICAgICAgICAgIGVycm9yX3RleHQgPSAnKioqIFVuZXhwZWN0ZWQgZXJyb3Igd2hpbGUgcnVubmluZyBwcmVjaGVja2Vycy4gUGxlYXNlIHJlcG9ydCAqKipcbicgKyBzdHIoZSkKICAgICAgICAgICAgICAgIGVycm9ycyArPSBbZXJyb3JfdGV4dF0KICAgICAgICAgICAgZXJyb3JzID0gW3NlbGYuc2ltcGxpZnlfZXJyb3Ioc2VsZi5hZGp1c3RfZXJyb3JfbGluZV9udW1zKGVycm9yKSkgZm9yIGVycm9yIGluIGVycm9yc10KICAgICAgICAgICAgZXJyb3JzID0gW2Vycm9yIGZvciBlcnJvciBpbiBlcnJvcnMgaWYgbm90IGVycm9yLnN0YXJ0c3dpdGgoJyoqKioqKioqKioqKiogTW9kdWxlJyldCgogICAgICAgIGVycm9ycyA9IFtlcnJvci5yZXBsYWNlKCc8dW5rbm93bj4sICcsICcnKSBmb3IgZXJyb3IgaW4gZXJyb3JzXSAgIyBBbm90aGVyIGVycm9yIHRpZHlpbmcgb3BlcmF0aW9uCiAgICAgICAgaWYgZXJyb3JzOgogICAgICAgICAgICBlcnJvcnMuYXBwZW5kKCJcblNvcnJ5LCBidXQgeW91ciBjb2RlIGRvZXNuJ3QgcGFzcyB0aGUgc3R5bGUgY2hlY2tzLiIpCiAgICAgICAgcmV0dXJuIGVycm9ycwoKICAgIGRlZiBwcmVydW5faG9vayhzZWxmKToKICAgICAgICAiIiJBIGhvb2sgZm9yIHN1YmNsYXNzZXMgdG8gZG8gaW5pdGlhbCBzZXR1cCBvciBjb2RlIGhhY2tzIGV0YwogICAgICAgICAgIFJldHVybnMgYSBsaXN0IG9mIGVycm9ycywgdG8gd2hpY2ggb3RoZXIgZXJyb3JzIGFyZSBhcHBlbmRlZC4KICAgICAgICAgICBJbiB0aGlzIGNsYXNzIHdlIHVzZSBpdCB0byBwZXJmb3JtIHJlcXVpcmVkIGhhY2tzIHRvIGRpc2FibGUKICAgICAgICAgICBjYWxscyB0byBtYWluLiBJZiB0aGUgY2FsbCB0byBtYWluX2hhY2tzIGZhaWxzLCBhc3N1bWUgdGhlIGNvZGUKICAgICAgICAgICBpcyBiYWQgYW5kIHdpbGwgZ2V0IGZsYWdnZWQgYnkgcHlsaW50IGluIGR1ZSBjb3Vyc2UuCiAgICAgICAgIiIiCiAgICAgICAgdHJ5OgogICAgICAgICAgICByZXR1cm4gc2VsZi5tYWluX2hhY2tzKCkKICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgIHJldHVybiBbXQoKICAgIGRlZiBwYXNzaXZlX291dHB1dChzZWxmKToKICAgICAgICAiIiIgUmV0dXJuIHRoZSBwYXNzaXZlIG91dHB1dCBmcm9tIHRoZSBzdHVkZW50IGFuc3dlciBjb2RlCiAgICAgICAgICAgIFRoaXMgaXMgZXNzZW50aWFsbHkgYSAiZHJ5IHJ1biIgb2YgdGhlIGNvZGUuCiAgICAgICAgIiIiCiAgICAgICAgY29kZSA9IHNlbGYucHJlbHVkZSArIHNlbGYucGFyYW1zWydTVFVERU5UX0FOU1dFUiddCiAgICAgICAgaWYgc2VsZi5wYXJhbXNbJ3VzZXNtYXRwbG90bGliJ106CiAgICAgICAgICAgIGNvZGUgKz0gJ1xuJy5qb2luKFsKICAgICAgICAgICAgICAgICdmaWdzID0gX21wbC5weXBsb3QuZ2V0X2ZpZ251bXMoKScsCiAgICAgICAgICAgICAgICAnaWYgZmlnczonLAogICAgICAgICAgICAgICAgJyAgICBwcmludChmIntsZW4oZmlncyl9IGZpZ3VyZXMgZm91bmQiKScKICAgICAgICAgICAgXSkgKyAnXG4nCiAgICAgICAgdGFzayA9IHB5dGFzay5QeVRhc2soc2VsZi5wYXJhbXMsIGNvZGUpCiAgICAgICAgdGFzay5jb21waWxlKCkKICAgICAgICBjYXB0dXJlZF9vdXRwdXQsIGNhcHR1cmVkX2Vycm9yID0gdGFzay5ydW5fY29kZSgpCiAgICAgICAgcmV0dXJuIChjYXB0dXJlZF9vdXRwdXQgKyAnXG4nICsgY2FwdHVyZWRfZXJyb3IpLnN0cmlwKCkKCiAgICBkZWYgbWFrZV90ZXN0X3Bvc3RsdWRlKHNlbGYsIHRlc3RjYXNlcyk6CiAgICAgICAgIiIiUmV0dXJuIHRoZSBjb2RlIHRoYXQgZm9sbG93cyB0aGUgc3R1ZGVudCBhbnN3ZXIgY29udGFpbmluZyBhbGwgdGhlIHRlc3Rjb2RlCiAgICAgICAgICAgZnJvbSB0aGUgZ2l2ZW4gbGlzdCBvZiB0ZXN0Y2FzZXMsIHdoaWNoIHNob3VsZCBhbHdheXMgYmUgb2YgbGVuZ3RoIDEKICAgICAgICAgICAoYmVjYXVzZSB3ZSBkb24ndCBib3RoZXIgdHJ5aW5nIHRvIGNvbWJpbmUgYWxsIHRoZSB0ZXN0cyBpbnRvIGEKICAgICAgICAgICBzaW5nbGUgcnVuIGluIFB5dGhvbikKICAgICAgICAiIiIKICAgICAgICBhc3NlcnQgbGVuKHRlc3RjYXNlcykgPT0gMQogICAgICAgIGlmIHNlbGYucGFyYW1zWydub3Rlc3QnXToKICAgICAgICAgICAgcmV0dXJuICcnCiAgICAgICAgdGVzdCA9IHRlc3RjYXNlc1swXQogICAgICAgIHRlc3RlciA9ICcnCiAgICAgICAgaWYgc2VsZi5wYXJhbXNbJ2dsb2JhbGV4dHJhJ10gYW5kIHNlbGYucGFyYW1zWydnbG9iYWxleHRyYSddID09ICdwcmV0ZXN0JzoKICAgICAgICAgICAgdGVzdGVyICs9IHNlbGYucGFyYW1zWydHTE9CQUxfRVhUUkEnXSArICdcbicKICAgICAgICBpZiB0ZXN0LmV4dHJhIGFuZCBzZWxmLnBhcmFtc1snZXh0cmEnXSA9PSAncHJldGVzdCc6CiAgICAgICAgICAgIHRlc3RlciArPSB0ZXN0LmV4dHJhICsgJ1xuJwogICAgICAgIGlmIHRlc3QudGVzdGNvZGU6CiAgICAgICAgICAgIHRlc3RlciArPSB0ZXN0LnRlc3Rjb2RlLnJzdHJpcCgpICsgJ1xuJwogICAgICAgIGlmIHNlbGYucGFyYW1zWydnbG9iYWxleHRyYSddIGFuZCBzZWxmLnBhcmFtc1snZ2xvYmFsZXh0cmEnXSA9PSAncG9zdHRlc3QnOgogICAgICAgICAgICB0ZXN0ZXIgKz0gc2VsZi5wYXJhbXNbJ0dMT0JBTF9FWFRSQSddICsgJ1xuJwogICAgICAgIGlmIHRlc3QuZXh0cmEgYW5kIHNlbGYucGFyYW1zWydleHRyYSddID09ICdwb3N0dGVzdCc6CiAgICAgICAgICAgIHRlc3RlciArPSB0ZXN0LmV4dHJhICsgJ1xuJwoKICAgICAgICBpZiBzZWxmLnBhcmFtc1sndXNlc21hdHBsb3RsaWInXToKICAgICAgICAgICAgaWYgJ2RwaScgaW4gc2VsZi5wYXJhbXMgYW5kIHNlbGYucGFyYW1zWydkcGknXToKICAgICAgICAgICAgICAgIGV4dHJhID0gZiIsIGRwaT17c2VsZi5wYXJhbXNbJ2RwaSddfSIKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIGV4dHJhID0gJycKICAgICAgICAgICAgaWYgc2VsZi5wYXJhbXMuZ2V0KCdydW5uaW5nX3NhbXBsZV9hbnN3ZXInLCBGYWxzZSk6CiAgICAgICAgICAgICAgICBjb2x1bW4gPSAnRXhwZWN0ZWQnCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBjb2x1bW4gPSAnR290JwogICAgICAgICAgICB0ZXN0X251bSA9IGxlbihzZWxmLnJlc3VsdF90YWJsZS50YWJsZSkgLSAxICAjIDAtb3JpZ2luIHRlc3QgbnVtYmVyIGZyb20gcmVzdWx0IHRhYmxlCiAgICAgICAgICAgIHRlc3RlciArPSAnXG4nLmpvaW4oWwogICAgICAgICAgICAgICAgJ2ZpZ3MgPSBfbXBsLnB5cGxvdC5nZXRfZmlnbnVtcygpJywKICAgICAgICAgICAgICAgICdmb3IgZmlnIGluIGZpZ3M6JywKICAgICAgICAgICAgICAgICcgICAgX21wbC5weXBsb3QuZmlndXJlKGZpZyknLAogICAgICAgICAgICAgICAgJyAgICByb3cgPSB7fScuZm9ybWF0KHRlc3RfbnVtKSwKICAgICAgICAgICAgICAgICcgICAgY29sdW1uID0gInt9IicuZm9ybWF0KGNvbHVtbiksCiAgICAgICAgICAgICAgICAnICAgIF9tcGwucHlwbG90LnNhdmVmaWcoIl9pbWFnZXt9Lnt9Lnt9LnBuZyIuZm9ybWF0KGZpZywgY29sdW1uLCByb3cpLCBiYm94X2luY2hlcz0idGlnaHQiJyArICd7fSknLmZvcm1hdChleHRyYSksCiAgICAgICAgICAgICAgICAnICAgIF9tcGwucHlwbG90LmNsb3NlKGZpZyknCiAgICAgICAgICAgIF0pICsgJ1xuJwogICAgICAgIHJldHVybiB0ZXN0ZXIKCiAgICBkZWYgc2luZ2xlX3Byb2dyYW1fYnVpbGRfcG9zc2libGUoc2VsZik6CiAgICAgICAgIiIiV2UgYXZvaWQgYWxsIHRoZSBjb21wbGljYXRpb24gb2YgdHJ5aW5nIHRvIHJ1biBhbGwgdGVzdHMgaW4KICAgICAgICAgICBhIHNpbmdsZSBzdWJwcm9jZXNzIHJ1biBieSB1c2luZyBleGVjIHRvIHJ1biBlYWNoIHRlc3Qgc2luZ2x5LgogICAgICAgICIiIgogICAgICAgIHJldHVybiBGYWxzZQoKICAgIGRlZiBhZGp1c3RfZXJyb3JfbGluZV9udW1zKHNlbGYsIGVycm9yKToKICAgICAgICAiIiJTdWJ0cmFjdCB0aGUgcHJlbHVkZSBsZW5ndGggb2YgYWxsIGxpbmUgbnVtYmVycyBpbiB0aGUgZ2l2ZW4gZXJyb3IgbWVzc2FnZQogICAgICAgICIiIgogICAgICAgIGVycm9yX3BhdHRlcm5zID0gWwogICAgICAgICAgICAgICAgKHInKC4qPGZzdHJpbmc+LiogXChzeW50YXgtZXJyb3JcKS4qKScsIFtdKSwKICAgICAgICAgICAgICAgIChyJyguKkZpbGUgIi4qIiwgbGluZSArKShcZCspKCwgaW4gLiopJywgWzJdKSwKICAgICAgICAgICAgICAgIChyJyguKjogKikoXGQrKSgsICpcZCs6LipcKC4qbGluZSArKShcZCspKFwpLiopJywgWzIsIDRdKSwKICAgICAgICAgICAgICAgIChyJyguKjogKikoXGQrKSgsICpcZCs6LipcKC4qXCkuKiknLCBbMl0pLAogICAgICAgICAgICAgICAgKHInKC4qOikoXGQrKSg6XGQrOiBbQS1aXVxkKzogLipsaW5lICkoXGQrKSguKiknLCBbMiwgNF0pLAogICAgICAgICAgICAgICAgKHInKC4qOikoXGQrKSg6XGQrOiBbQS1aXVxkKzogLiopJywgWzJdKSwKICAgICAgICBdCiAgICAgICAgb3V0cHV0X2xpbmVzID0gW10KICAgICAgICBmb3IgbGluZSBpbiBlcnJvci5zcGxpdGxpbmVzKCk6CiAgICAgICAgICAgIGZvciBwYXR0ZXJuLCBsaW5lX2dyb3VwX251bXMgaW4gZXJyb3JfcGF0dGVybnM6CiAgICAgICAgICAgICAgICBtYXRjaCA9IHJlLm1hdGNoKHBhdHRlcm4sIGxpbmUpCiAgICAgICAgICAgICAgICBpZiBtYXRjaDoKICAgICAgICAgICAgICAgICAgICBsaW5lID0gJycKICAgICAgICAgICAgICAgICAgICBmb3IgaSwgZ3JvdXAgaW4gZW51bWVyYXRlKG1hdGNoLmdyb3VwcygpLCAxKToKICAgICAgICAgICAgICAgICAgICAgICAgaWYgaSBpbiBsaW5lX2dyb3VwX251bXM6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lbnVtID0gaW50KG1hdGNoLmdyb3VwKGkpKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRqdXN0ZWQgPSBsaW5lbnVtIC0gc2VsZi5wcmVsdWRlX2xlbmd0aAogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZSArPSBzdHIoYWRqdXN0ZWQpCiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lICs9IGdyb3VwCiAgICAgICAgICAgICAgICAgICAgYnJlYWsKCiAgICAgICAgICAgIG91dHB1dF9saW5lcy5hcHBlbmQobGluZSkKICAgICAgICByZXR1cm4gJ1xuJy5qb2luKG91dHB1dF9saW5lcykKCiAgICBkZWYgc2ltcGxpZnlfZXJyb3Ioc2VsZiwgZXJyb3IpOgogICAgICAgICIiIlJldHVybiBhIHNpbXBsaWZpZWQgdmVyc2lvbiBvZiBhIHB5bGludCBlcnJvciB3aXRoIExpbmUgPG4+IGluc2VydGVkIGluCiAgICAgICAgICAgbGlldSBvZiBfX3NvdXJjZS5weTo8bj48cD46IFhubm5uCiAgICAgICAgIiIiCiAgICAgICAgcGF0dGVybiA9IGYnX19zb3VyY2UucHk6KFxkKyk6ICpcZCs6ICpbQS1aXVxkKzogKC4qKScKICAgICAgICBtYXRjaCA9IHJlLm1hdGNoKHBhdHRlcm4sIGVycm9yKQogICAgICAgIGlmIG1hdGNoOgogICAgICAgICAgICByZXR1cm4gZiJMaW5lIHttYXRjaC5ncm91cCgxKX06IHttYXRjaC5ncm91cCgyKX0iCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcmV0dXJuIGVycm9yCgogICAgZGVmIG1haW5faGFja3Moc2VsZik6CiAgICAgICAgIiIiTW9kaWZ5IHRoZSBjb2RlIHRvIGJlIHRlc3RlZCBpZiBwYXJhbXMgc3RyaXBtYWluIG9yIHN0cmlwbWFpbmlmcHJlc2VudCcKICAgICAgICAgICBhcmUgc3BlY2lmaWVkLiBSZXR1cm5zIGEgbGlzdCBvZiBlcnJvcnMgZW5jb3VudGVyZWQgd2hpbGUgc28gZG9pbmcuCiAgICAgICAgIiIiCiAgICAgICAgZXJyb3JzID0gW10KICAgICAgICBpZiBzZWxmLnBhcmFtc1snc3RyaXBtYWluJ10gb3Igc2VsZi5wYXJhbXNbJ3N0cmlwbWFpbmlmcHJlc2VudCddOgogICAgICAgICAgICBtYWluX2NhbGxzID0gc2VsZi5zdHlsZV9jaGVja2VyLmZpbmRfZnVuY3Rpb25fY2FsbHMoJ21haW4nKQogICAgICAgICAgICBpZiBzZWxmLnBhcmFtc1snc3RyaXBtYWluJ10gYW5kIG1haW5fY2FsbHMgPT0gW106CiAgICAgICAgICAgICAgICBlcnJvcnMuYXBwZW5kKCJObyBjYWxsIHRvIG1haW4oKSBmb3VuZCIpCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBzdHVkZW50X2xpbmVzID0gc2VsZi5zdHVkZW50X2Fuc3dlci5zcGxpdCgnXG4nKQogICAgICAgICAgICAgICAgZm9yIChsaW5lLCBkZXB0aCkgaW4gbWFpbl9jYWxsczoKICAgICAgICAgICAgICAgICAgICBpZiBkZXB0aCA9PSAwOgogICAgICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGwgPSBzdHVkZW50X2xpbmVzW2xpbmVdCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIG5vdCByZS5tYXRjaCgnICptYWluXChcKScsIG1haW5fY2FsbCk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMuYXBwZW5kKGYiSWxsZWdhbCBjYWxsIHRvIG1haW4oKS5cbiIgKwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJtYWluIHNob3VsZCBub3QgdGFrZSBhbnkgcGFyYW1ldGVycyBhbmQgc2hvdWxkIG5vdCByZXR1cm4gYW55dGhpbmcuIikKICAgICAgICAgICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0dWRlbnRfbGluZXNbbGluZV0gPSBtYWluX2NhbGwucmVwbGFjZSgKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1haW4iLCAicGFzcyAgICMgRGlzYWJsZWQgY2FsbCB0byBtYWluIikKICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICBzdHVkZW50X2xpbmVzW2xpbmVdICs9ICIgICMgV2UndmUgbGV0IHlvdSBjYWxsIG1haW4gaGVyZS4iCiAgICAgICAgICAgICAgICBzZWxmLnBhcmFtc1snU1RVREVOVF9BTlNXRVInXSA9IHNlbGYuc3R1ZGVudF9hbnN3ZXIgPSAnXG4nLmpvaW4oc3R1ZGVudF9saW5lcykgKyAnXG4nCgogICAgICAgIHJldHVybiBlcnJvcnMK</file>
    </testcases>
  </question>

</quiz>