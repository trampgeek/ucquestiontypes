<?xml version="1.0" encoding="UTF-8"?>
<quiz>
<!-- question: 24494  -->
  <question type="coderunner">
    <name>
      <text>UOC_PROTOTYPE_python3_stage1</text>
    </name>
    <questiontext format="html">
      <text><![CDATA[<p><span style="font-size: 0.9375rem;">Prototype for a COSC121 Python3 question that is checked by pylint before being executed. Other style checks are also implemented.</span><br></p>
<p>It can take the following template parameters.</p>
<ul>
    <li>
        <p><strong>abortonerror</strong>: true to abort testing when a runtime error occurs. Default: true</p>
    </li>
    <li>
        <p><strong>allowglobals</strong>: set this to true to allow global variables (i.e. to allow lowercase globals, not just "constants"). Default: false.</p>
    </li>
    <li>
        <p><strong>allownestedfunctions</strong>: set this to true to allow functions to be declared with a non-global scope. Default: false.</p>
    </li>
    <li>
        <p></p>
        <div>
            <div><strong>banglobalcode</strong>: If true, no global assignment (except global constants), for, while and if constructs are allowed. Default: true</div>
        </div>
        <p></p>
    </li>
    <li>
        <p><strong>checktemplateparams</strong>: set this false to bypass the usual check for validity of template params (e.g. when doing randomisation, although prefixing the extra template params with '_' is preferred).</p>
    </li>
    <li>
        <p><strong>echostandardinput</strong>. If false, the standard builtin Python&nbsp;<em>input</em>&nbsp;function will be used. Otherwise, it will be replaced with a version that echoes the prompt to standard output to mimic the behaviour observed when
            standard input comes from the keyboard. Default: True<br></p>
    </li>
    <li>
        <p><strong>extra:&nbsp;</strong>should be a string, one of "", "pretest" or "posttest". If set and not empty, the TEST.extra field is inserted into the program before or after TEST.testcode for the values "pretest" and "posttest" respectively. Default:
            ""</p>
    </li>
    <li>
        <p><strong>floattolerance</strong>: a floating point number which, if defined and non-None, changes the test for correct output as follows. The&nbsp;<em>expected</em>&nbsp;and&nbsp;<em>got</em>&nbsp;outputs are both right-stripped then broken into
            lines. If the number of lines don't match, the answer is deemed wrong. Then (after compressing white space to a single character if&nbsp;<em>strictwhitespace</em>&nbsp;is false) the&nbsp;<em>got</em>&nbsp;and&nbsp;<em>expected</em>&nbsp;outputs
            are compared line for line. Each line is split by a regular expression pattern that matches any floating point number or integer and the two lines are compared token by token. If both tokens are numbers they must be equal to within&nbsp; <em>floattolerance</em>. The actual test is abs(float(f1) - float(f2) &lt;= floattolerance * 1.0001. The factor of 1.0001 is to allow for floating point error in the case where two decimal numbers that appear to satisfy the criterion, such as 0.65 and 0.65 with a float tolerance of 0.01, actually don't quite. If <em>floattolerance</em> is 0.0 the effect is to treat ints as floats, e.g.&nbsp; 1 and 1.0 will be deemed equal. Default: None
            <br></p>
    </li>
    <li>
        <p><strong>globalextra</strong>: should be a string, one of "", "pretest" or "posttest". If set and not empty, the QUESTION.globalextra field is inserted into the program before or after TEST.testcode for the values "pretest" and "posttest" respectively.
            If TEST.extra and QUESTION.globalextra are both being inserted before the test or both are being inserted after the test, the globalextra precedes the TEST.extra. Default: ""</p>
    </li>
</ul>
<ul>
    <li>
        <p><strong>imagewidth</strong>: if this is given it sets the width in pixels of any matplotlib images inserted into the result table. Height is automatically scaled to match. Otherwise the image is inserted unscaled. Ignored unless&nbsp;<em>usesmatplotlib</em>&nbsp;is
            true. Default: None.</p>
    </li>
    <li>
        <p><strong>imports</strong>: this is a list of python import strings. Each string is either just a python module name or a full python import string. If just&nbsp;<em>name</em>&nbsp;is given, the import statement is simply "import name", otherwise
            the import string is used as given. For example:</p>
        <pre>{ "imports": ["math", "from blah import thing as twaddle"] }</pre>
        <p>Imports go at the very start of the generated program. This mechanism can be used to import test support functions, too, and is preferred over the use of a&nbsp;<tt>_prefix.py</tt>&nbsp;file.</p>
    </li>
    <li>
        <p><strong>isfunction</strong>: unless this is explicitly set to false, or the student's code already begins with a docstring, a dummy module docstring will be inserted at the start of the program<strong>.</strong>&nbsp; Also, if&nbsp;<em>isfunction</em>&nbsp;is
            true, the supplied code will be run stand-alone to check if it generates any output and an error message will be generated if it does.&nbsp;Thus, if your question is of the "write a program" variety, you should&nbsp;set this to false. Otherwise
            omit it. Default: true.</p>
    </li>
    <li>
        <p><strong>maxfunctionlength</strong>: this is the maximum number of statements that a function body can contain. Statements within statements are counted. Blank lines and comments aren't statements.&nbsp;&nbsp;This is a more-reliable alternative
            to the pylint max-statements parameter, which behaves strangely at times.&nbsp;</p>
    </li>
    <li>
        <p><strong>maxnumconstants</strong>: the maximum number of constants (i.e. uppercase globals) allowed. An integer, defaulting to 4.</p>
    </li>
    <li>
        <p><strong>maxoutputbytes</strong>: the maximum allowed number of output bytes. Default 10000.<br></p>
    </li>
    <li>
        <p><strong>maxstringlength:&nbsp;</strong>the maximum allowed length of the output string or error string in the result table. Strings longer than this have their inner content snipped out. An integer defaulting to 2000.</p>
    </li>
    <li>
        <p><strong>norun</strong>: if set to true, the normal execution of the student's code will not take place. Any test code provided will however still be run.</p>
    </li>
    <li>
        <p><strong>nostylechecks</strong>: true to suppress all normal style checking, including the checkers listed in "precheckers". Default: false</p>
    </li>
    <li>
        <p><strong>notest</strong>: if present and set to true, the test code will not be inserted into the code to be executed. Its role is then just as documentation for the student (as it still appears in the result table).</p>
    </li>
    <li><p><strong>parsonsproblemthreshold: </strong>if a wrong answer is submitted and the number of submissions (Checks) is greater than or equal to this value (parsonsproblemthreshold) the student is presented with a link that, if clicked, will expose the author's answer with all indentation removed and the order scrambled.</p></li>
    <li>
        <p><strong>precheckers</strong>: a list of the names of programs to be run when prechecking the correctness of the code. Currently only "pylint" and "mypy" are supported. Default: ["pylint"].<br></p>
    </li>
    <li>
        <p><strong>prelude</strong>: a possibly multi-line string that is inserted into the file&nbsp;after any imports and other template-generated code but before the student answer (and before the _prefix.py file, if supplied).</p>
    </li>
    <li>
        <p><strong>proscribedbuiltins</strong>: this is a list of the Python built-in functions that cannot be used. Default: ["exec", "eval"].</p>
    </li>
    <li>
        <p><strong>proscribedconstructs</strong>: this is a list of Python constructs (if, while, def, slice, listcomprehension, etc) that<em>&nbsp;must not</em>&nbsp;appear in the student's program.</p>
    </li>
    <li>
        <p><strong>proscribedfunctions</strong>: this is a list of functions (sum, product, etc) that&nbsp;<em>must not</em>&nbsp;appear in the student's program. Default: []</p>
    </li>
    <li>
        <p><strong>proscribedsubstrings</strong>: this is a list of strings that <em>must not</em>&nbsp;appear anywhere in the student's program (even in comments). Default: []</p>
    </li>
    <li><strong>pylintoptions</strong>. A list of strings to be added to the default list of options to pylint (relevant only if "pylint" is specified as one of the precheckers).&nbsp;For example, the Template parameters string in the question authoring form
        might be set to
        <pre>{"isfunction": false, "pylintoptions":["--max-statements=20","--max-args=3"]}</pre>to suppress the insertion of a dummy module docstring at the start and to set the maximum number of statements and arguments for each function to 20 and 3 respectively. Default options:
        <p></p>
        <ul>
            <li>"--disable=C0303,C0325,C0330,R0903,R0915,star-args,unbalanced-tuple-unpacking,consider-using-enumerate,simplifiable-if-statement,consider-iterating-dictionary,trailing-newlines"</li>
            <li>"--enable=C0326"</li>
            <li>"--good-names=i,j,k,n,s,c,_"<br></li>
        </ul>
    </li>
    <li>
        <p><strong>requiredconstructs</strong>:&nbsp;this is a list of Python constructs (if, while, def, etc) that<strong>&nbsp;must&nbsp;</strong>appear in the student's program. Default: []</p>
    </li>
    <li>
        <p><strong>requiredfunctiondefinitions</strong>: this is a list of the names of the functions that must be defined within the student's program. Default: []</p>
    </li>
    <li>
        <p><strong>requiredfunctioncalls</strong>: this is a list of the names of functions that must be explicitly called within the student's code</p>
    </li>
    <li>
        <p><strong>requiredsubstrings</strong>: this is either a list of strings that <strong>must</strong> appear somewhere in the students code. Or a list of json objects with the keys "string", "pattern" and "errormessage". Only one of "string" or "pattern"
            should be supplies. "String" corresponds to a string that must appear in the students code and "pattern" corresponds to a python regular expression that must match somewhere in the students code. "errormessage" is the feedback that will be
            given to students when they fail this on precheck.<br></p>
    </li>
    <li>
        <p><strong>requiretypehints</strong>: if&nbsp;<em>True</em>&nbsp;all functions must have type hints for all parameters and the return type. Default: False<br></p>
    </li>
    <li>
        <p><strong>restrictedfiles</strong>: this specifies which files the students program is allowed to open. It is dictionary with two optional keys 'onlyallow' and 'disallow'. Each of these should map to a list of files that are allowed to be opened
            and filenames that are not allowed to be opened. The filenames in the lists can be a regex.<br>Default:
        </p>
        <pre>{"disallow": ["__.*", "prog.*", "pytester.py"]</pre>
        <p></p>
    </li>
    <li>
        <p><strong>restrictedmodules</strong>: A dictionary that specifies what modules are to be restricted. Keys are the names of modules and the values are a dictionary with two keys 'onlyallow' and 'disallow'. Each of these is a list of the names of
            objects within the module which are allowed or disallowed. The names of objects in these lists can be a regex.&nbsp; This is a runtime check only, not part of style checker.<br>Default:</p>
        <pre> "restrictedmodules": {
    "builtins": {"onlyallow": []},
    "imp": {"onlyallow": []},
    "importlib": {"onlyallow": []},
    "os": {"disallow": ["system", "_exit", "_.*"]},
    "subprocess": {"onlyallow": []},
    "sys": {"onlyallow": []},
}</pre>
        <p></p>
    </li>
    <li>
        <p><strong>runextra</strong>: if set (to any value) the Extra Template Data is added to the program as test code&nbsp;<em>before</em>&nbsp;the usual testcode. [Deprecated: use the&nbsp;<em>extra</em>&nbsp;parameter instead.]</p>
    </li>
    <li><strong>showfeedbackwhenright</strong>:<strong> </strong>If true then if a student provides a valid solution then the student is presented with an option to see the question authors solution.<br>Default: false<br></li>
    <li>
        <p><strong>strictwhitespace</strong>: by default when checking correctness trailing blank lines and trailing white space on each line are ignored but otherwise white space must match exactly. If this parameter is set to false, white space within
            a line may vary, i.e., multiple spaces are treated as 1 space. Default: true</p>
    </li>
    <li>
        <p><strong>stripmain</strong>: if set to true, the program is expected to contain a global invocation of the main function, which is a line starting "main()". That line is deleted from the program. If the line is not present a "Missing call to main"
            exception is raised.</p>
    </li>
    <li>
        <p><strong>stripmainifpresent</strong>: if set to true and the program contains a global invocation of a main function, which is a line starting "main()", that line is deleted from the program. Otherwise nothing happens (cf stripmain).</p>
    </li>
    <li>
        <p><strong>suppresspassiveoutput</strong>: if set to true, any output generated by the student code even without any CodeRunner tests being run is ignored. This can be used, for example, to ignore output from any test code the student has included&nbsp;<em>and/or</em>&nbsp;to
            ignore the main output from a "write a program question". Only the output generated by CodeRunner tests will be displayed and marked. Default: false.</p>
    </li>
    <li>
        <p><strong>timeout</strong>: number of seconds allowed for each test case. Default: 5 secs. Be careful to ensure that the total time for all test cases can not exceed&nbsp;<strong>totaltimeout</strong>, particularly if&nbsp;<em>abortonerror</em>&nbsp;is
            false.</p>
    </li>
    <li>
        <p><strong>totaltimeout</strong>: total number of seconds allowed for the whole run. Cannot exceed the maximum allowed by Jobe, which is 50 seconds (and which is the default value for this parameter).</p>
    </li>
    <li>
        <p><strong>useanswerfortests</strong>: if true, a run with the sample answer precedes the run with the student answer and the results from the sample answer are used for correctness testing&nbsp;<em>but only if no expected output is supplied</em>.
            However, because this takes place at runtime, this doesn't work for "Use as example" tests, for which the expected output must be supplied by the question author.</p>
    </li>
    <li>
        <p><strong>usesmatplotlib:&nbsp;</strong>if true, header text is inserted at the start of the program to switch matlab graph output to use the non-interactive 'Agg' backend, which writes images to disk an .PNGs. After each test, the current state
            of the pyplot figure is saved to a new file. When all tests have been run and graded, the set of image files is inserted row-by-row into the result table with each figure below any text in the cell. For this to work correctly at least the
            first test must create a figure. The image is not graded - it is provided only for reference, so usually the test code will need to extract and display attributes of the current figure independently. See also the template parameters&nbsp;<em>useanswerfortests</em>,
            which results in the expected images being inserted into the table too and&nbsp;<em>imagewidth&nbsp;</em>which sets the width (and hence height by uniform scaling) to a desired number of pixels. Note that if&nbsp;<em>usesmatplotlib</em>&nbsp;is
            selected, most of the pylint options relating to imports (ordering, reimporting, positioning etc) are disabled. Also, you may need to increase the timeout value for the question.<br><br>Also, if&nbsp;<em>usesmatplotlib</em>&nbsp;is true, a
            function&nbsp;
            <em>print_plot_info(data_type, x_samples=None, show_xlims=False, show_ylims=False, show_colour=False, show_xticklabels=None, show_yticklabels=False, bar_indices=None)</em>&nbsp;is made available for use in the test code or post-test extra. This prints various
            properties of the current plot for grading purposes.&nbsp;<em>data_type</em>&nbsp;should be one of 'points', 'lines' or 'bars'.&nbsp;<span id="qtype-help"><span id="qtype-help">In the case of 'lines', the 'x_samples' can also be supplied, as a set of abscissae at which the plotted line should be read out. The y values are read out using a second-order interpolation, and are printed to 2 decimal digits of accuracy. If x_samples is not supplied, the first 5 and last 5 points only are displayed. For the case of 'bars' an optional list of which bars to display can be given in the parameter <em>bar_indices</em>; by default all bars are listed. The show_[x,y]lims parameters control whether or not the x and y axis limits, respectively, should be printed. If <em>show_xticklabels </em>is None, the x-axis labels are displayed for bar charts not for lines. Setting it <em>True</em> or <em>False</em> forces display on or off. Similarly for <em>show_yticklabels</em> except that the default is False and None is not defined.</span></span><br><br>Default
            (for usesmatplotlib): false.&nbsp;
        </p>
    </li>
    <li>
        <p><strong>usesnumpy:&nbsp;</strong>if true, the line&nbsp;<em>import numpy as np</em>&nbsp;is inserted at the start of the program, and the usual check for unused imports is turned off. Additionally, since&nbsp;<em>numpy&nbsp;</em>is used in a mathematical
            context where it is hard to define what variables name might be legitimate, the checking for valid names by pylint is disabled.</p>
    </li>
    <li>
        <p><strong>warnifpassiveoutput</strong>: if set to true and&nbsp;<em>isfunction</em>&nbsp;is also true, generate a style error&nbsp;if the student's code seems to produce output even without any CodeRunner tests being executed. This is probably the
            result of the student pasting test code as well as requested function(s) into their answer. Default: true</p>
    </li>
</ul>
<p>Also, if a file named '_prefix.py' appears in the working directory (i.e. has been attached to the question), the code in that file is inserted into the executable program after any imports and other template-generated code but before the student answer.
    However, the use of an explicit import statement is preferred.</p>]]></text>
    </questiontext>
    <generalfeedback format="html">
      <text></text>
    </generalfeedback>
    <defaultgrade>1</defaultgrade>
    <penalty>0</penalty>
    <hidden>0</hidden>
    <idnumber></idnumber>
    <coderunnertype>python3_stage1</coderunnertype>
    <prototypetype>2</prototypetype>
    <allornothing>1</allornothing>
    <penaltyregime>0, 10, 20, ...</penaltyregime>
    <precheck>1</precheck>
    <hidecheck>0</hidecheck>
    <showsource>0</showsource>
    <answerboxlines>60</answerboxlines>
    <answerboxcolumns>100</answerboxcolumns>
    <answerpreload></answerpreload>
    <globalextra></globalextra>
    <useace>1</useace>
    <resultcolumns></resultcolumns>
    <template><![CDATA[import locale
import json
import os
import re
import html
import random

from pytester import PyTester

STANDARD_PYLINT_OPTIONS = ['--disable=trailing-whitespace,superfluous-parens,' +
                      'bad-continuation,min-public-methods,too-few-public-methods,star-args,' +
                      'unbalanced-tuple-unpacking,too-many-statements,' +
                      'consider-using-enumerate,simplifiable-if-statement,' +
                      'consider-iterating-dictionary,trailing-newlines,no-else-return,' +
                      'consider-using-dict-comprehension,' +
                      'len-as-condition,inconsistent-return-statements,consider-using-join,' +
                      'singleton-comparison,unused-variable,chained-comparison,no-else-break,' +
	                  'consider-using-in,useless-object-inheritance,unnecessary-pass,' +
	                  'reimported,wrong-import-order,wrong-import-position,ungrouped-imports,' +
                      'consider-using-set-comprehension,no-else-raise,duplicate-string-formatting-argument',
                      '--enable=C0326',
                      '--good-names=i,j,k,n,s,c,_'
                      ]

locale.setlocale(locale.LC_ALL, 'C.UTF-8')

KNOWN_PARAMS = {
    'abortonerror': True,
    'allowglobals': False,
    'banglobalcode': True,
    'allownestedfunctions': False,
    'checktemplateparams': True,
    'echostandardinput': True,
    'extra': 'None',
    'floattolerance': None,
    'globalextra': 'None',
    'imagewidth': None,
    'imports': [],
    'isfunction': True,
    'maxfunctionlength': 30,
    'maxnumconstants': 4,
    'maxoutputbytes': 10000,
    'maxstringlength': 2000,
    'norun': False,
    'nostylechecks': False,
    'notest': False,
    'parsonsproblemthreshold': None, # The number of checks before parsons' problem displayed
    'precheckers': ['pylint'],
    'prelude': '',
    'proscribedbuiltins': ['exec', 'eval'],
    'proscribedfunctions': [],
    'proscribedconstructs': ["goto"],
    'proscribedsubstrings': [],
    'pylintoptions': [],
    'requiredconstructs': [],
    'requiredfunctiondefinitions': [],
    'requiredfunctioncalls': [],
    'requiredsubstrings': [],
    'requiretypehints': False,
    'restrictedfiles': {
        'disallow': ['__.*', 'prog.*', 'pytester.py'],
    },
    'restrictedmodules': {
        'builtins': {
            'onlyallow': []
        },
        'imp': {
            'onlyallow': []  
        },
        'importlib': {
            'onlyallow': []  
        },
        'os': {
            'disallow': ['system', '_exit', '_.*']
        },
        'subprocess': {
            'onlyallow': []
        },
        'sys': {
            'disallow': ['_.*']
        },
    },
    'runextra': False,
    'showfeedbackwhenright': False,
    'stdinfromextra': False,
    'strictwhitespace': True,
    'stripmain': False,
    'stripmainifpresent': False,
    'testisbash': False,
    'timeout': 5,
    'totaltimeout': 50,
    'suppresspassiveoutput': False,
    'useanswerfortests': False,
    'usesmatplotlib': False,
    'usesnumpy': False,
    'usesubprocess': False,
    'warnifpassiveoutput': True,
}

class TestCase:
    def __init__(self, dict_rep):
        """Construct a testcase from a dictionary representation obtained via JSON"""
        self.testcode = dict_rep['testcode']
        self.stdin = dict_rep['stdin']
        self.expected = dict_rep['expected']
        self.extra = dict_rep['extra']
        self.display = dict_rep['display']
        try:
            self.testtype = int(dict_rep['testtype'])
        except:
            self.testtype = 0
        self.hiderestiffail = bool(int(dict_rep['hiderestiffail']))
        self.useasexample = bool(int(dict_rep['useasexample']))
        self.mark = float(dict_rep['mark'])


# ================= CODE TO DO ALL TWIG PARAMETER PROCESSING ===================

def process_template_params():
    """Extract the template params into a global dictionary PARAMS"""
    global PARAMS
    PARAMS = json.loads("""{{ QUESTION.parameters | json_encode | e('py') }}""")
    checktemplateparams = PARAMS.get('checktemplateparams', True)
    if checktemplateparams:
        unknown_params = set(PARAMS.keys()) - set(KNOWN_PARAMS.keys())
        filtered_params = [param for param in unknown_params if not param.startswith('_')]
        if filtered_params:
            print("Unexpected template parameter(s):", list(sorted(filtered_params)))

    for param_name, default in KNOWN_PARAMS.items():
        if param_name in PARAMS:
            param = PARAMS[param_name]
            if type(param) != type(default) and default is not None:
                print("Template parameter {} has wrong type (expected {})".format(param_name, type(default)))
        else:
            PARAMS[param_name] = default;

    if PARAMS['extra'] == 'stdin':
        PARAMS['stdinfromextra'] = True
    if PARAMS['runextra']:
        PARAMS['extra'] = 'pretest'  # Legacy support
    if PARAMS['timeout'] < 2:
        PARAMS['timeout'] = 2  # Allow 1 extra second freeboard 
    PARAMS['pylintoptions'] = STANDARD_PYLINT_OPTIONS + PARAMS['pylintoptions']
    if PARAMS['allowglobals']:
        PARAMS['pylintoptions'].append("--const-rgx='[a-zA-Z_][a-zA-Z0-9_]{2,30}$'")
    if PARAMS['usesmatplotlib']:
        PARAMS['pylintoptions'].append("--disable=reimported,wrong-import-position,wrong-import-order,unused-import")
    if PARAMS['testisbash']:
        print("testisbash is not implemented for Python")


def get_test_cases():
    """Return an array of Test objects from the template parameter TESTCASES"""
    test_cases = [TestCase(test) for test in json.loads("""{{ TESTCASES | json_encode | e('py') }}""")]
    return test_cases


def scrambled(answer):
    """Return a randomly reordered version of the given answer"""
    if answer.strip() == '':
        return ''
    docstrings = re.findall(r'""".*?"""', answer) + re.findall(r"'''.*?'''", answer)
    rest = re.sub(r'""".*?"""', '', answer)
    rest2 = re.sub(r"'''.*?'''", '', rest)
    lines = [line.strip() for line in (rest2.splitlines() + docstrings) if line.strip()]
    original = lines[:]
    while original == lines: # Make sure the order changes!
        random.shuffle(lines)
    return '\n'.join(lines)
    

def process_global_params():
    """Plug into the PARAMS variable all the "global" parameters from
       the question and its answer (as distinct from the template parameters).
    """
    PARAMS['STUDENT_ANSWER'] = """{{ STUDENT_ANSWER | e('py') }}""".strip() + '\n'
    PARAMS['SEPARATOR'] = "#<ab@17943918#@>#"
    PARAMS['IS_PRECHECK'] = "{{ IS_PRECHECK }}" == "1"
    PARAMS['QUESTION_PRECHECK'] = {{ QUESTION.precheck }} # Type of precheck: 0 = None, 1 = Empty etc
    PARAMS['ALL_OR_NOTHING'] = "{{ QUESTION.allornothing }}" == "1" # Whether or not all-or-nothing grading is being used
    PARAMS['GLOBAL_EXTRA'] = """{{ QUESTION.globalextra | e('py') }}\n"""
    PARAMS['STEP_INFO'] = json.loads("""{{ QUESTION.stepinfo | json_encode }}""")
    answer = """{{QUESTION.answer | e('py')}}""".strip()
    if answer:
        if PARAMS['STUDENT_ANSWER'].strip() == answer.strip():
            PARAMS['AUTHOR_ANSWER'] = "<p>Your answer is an <i>exact</i> match with the author's solution.</p>"
        else:
            with open("__author_solution.html") as file:
                PARAMS['AUTHOR_ANSWER'] = (file.read().strip() % html.escape(answer))
        with open("__author_solution_scrambled.html") as file:
            PARAMS['AUTHOR_ANSWER_SCRAMBLED'] = (file.read().strip() % html.escape(scrambled(answer))) + "\n"
    else:
        PARAMS['AUTHOR_ANSWER'] = PARAMS['AUTHOR_ANSWER_SCRAMBLED'] = ''


def update_test_cases(test_cases, outcome):
    """Return the updated testcases after replacing all empty expected fields with those from the
       given outcome's test_results which must have a column header 'Got'. Non-empty existing expected
       fields are left unchanged.
       If any errors occur, the return value will be None and the outcome parameter will have had its prologuehtml
       value updated to include an error message.
    """
    try:
        results = outcome['testresults']
        col_num = results[0].index('Got')
        for i in range(len(test_cases)):
            if test_cases[i].expected.strip() == '':
                test_cases[i].expected = results[i + 1][col_num]
    except ValueError:
        outcome['prologuehtml'] = "No 'Got' column in result table from which to get testcase expecteds"
        test_cases = None
    except Exception as e:
        outcome['prologuehtml'] = "Unexpected error ({}) extracting testcase expecteds from sample answer output".format(e)
        test_cases = None
    return test_cases


def get_expecteds_from_answer(params, test_cases):
    """Run all tests using the sample answer rather than the student answer.
       Fill in the expected field of each test case using the sample answer and return
       the updated test case list.
       Return None if the sample answer gave any sort of runtime error
    """
    new_params = {key: value for key, value in params.items()}
    new_params['IS_PRECHECK'] = False
    new_params['nostylechecks'] = True
    new_params['STUDENT_ANSWER'] = """{{ QUESTION.answer | e('py') }}"""
    new_params['running_sample_answer'] = True
    tester = PyTester(new_params, test_cases)
    outcome = tester.test_code()
    if 'prologuehtml' in outcome:
        outcome['prologuehtml'] = "<h2>ERROR IN QUESTION'S SAMPLE ANSWER. PLEASE REPORT</h2>\n" + outcome['prologuehtml']
        return outcome, None
    else:
        return outcome, update_test_cases(test_cases, outcome)


process_template_params()
test_cases = get_test_cases()
process_global_params()

if PARAMS['useanswerfortests']:
    outcome, test_cases = get_expecteds_from_answer(PARAMS, test_cases)

if test_cases:
    tester = PyTester(PARAMS, test_cases)
    outcome = tester.test_code()
    feedback = ''
    parsons_threshold = float('inf') if PARAMS['parsonsproblemthreshold'] is None else PARAMS['parsonsproblemthreshold']
    if outcome['fraction'] != 1 and not PARAMS['IS_PRECHECK'] and PARAMS['STEP_INFO']['numchecks'] + 1 >= parsons_threshold:
        feedback = PARAMS['AUTHOR_ANSWER_SCRAMBLED']
    elif outcome['fraction'] == 1 and PARAMS['showfeedbackwhenright'] and not (PARAMS['IS_PRECHECK']):
        feedback = PARAMS['AUTHOR_ANSWER']
    if feedback:
        if 'epiloguehtml' in outcome:
            if outcome['epiloguehtml'].strip():
                outcome['epiloguehtml'] += '<br>'
        else:
            outcome['epiloguehtml'] = ''
        outcome['epiloguehtml'] += f'<div style="background-color: #f4f4f4">{feedback}</div>'
print(json.dumps(outcome))
]]></template>
    <iscombinatortemplate>1</iscombinatortemplate>
    <allowmultiplestdins>1</allowmultiplestdins>
    <answer></answer>
    <validateonsave>1</validateonsave>
    <testsplitterre><![CDATA[|#<ab@17943918#@>#\n|ms]]></testsplitterre>
    <language>python3</language>
    <acelang></acelang>
    <sandbox>jobesandbox</sandbox>
    <grader>TemplateGrader</grader>
    <cputimelimitsecs>50</cputimelimitsecs>
    <memlimitmb>1500</memlimitmb>
    <sandboxparams></sandboxparams>
    <templateparams></templateparams>
    <hoisttemplateparams>0</hoisttemplateparams>
    <templateparamslang>twig</templateparamslang>
    <templateparamsevalpertry>0</templateparamsevalpertry>
    <templateparamsevald>{}</templateparamsevald>
    <twigall>0</twigall>
    <uiplugin>ace</uiplugin>
    <uiparameters></uiparameters>
    <attachments>0</attachments>
    <attachmentsrequired>0</attachmentsrequired>
    <maxfilesize>10240</maxfilesize>
    <filenamesregex></filenamesregex>
    <filenamesexplain></filenamesexplain>
    <displayfeedback>1</displayfeedback>
    <testcases>
<file name="__author_solution_scrambled.html" path="/" encoding="base64">PGRpdiBjbGFzcz0iY29kZXJ1bm5lci10ZXN0LXJlc3VsdHMgYmFkIj4KICAgIDxhIGNsYXNzPSJidG4gYnRuLWxpbmsgY29kZXJ1bm5lci1zY3JhbWJsZWQtc29sdXRpb24tbGluayIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6I0ZDQyI+U2hvdyBzY3JhbWJsZWQgYXV0aG9yJ3Mgc29sdXRpb248L2E+CjwvZGl2Pgo8ZGl2IGNsYXNzPSJjb2RlcnVubmVyLXNjcmFtYmxlZC1hdXRob3JzLXNvbHV0aW9uIGNvbGxhcHNlIiBleHBhbmRlZD0iZmFsc2UiIHN0eWxlPSJtYXJnaW4tYm90dG9tOjhweCI+CiAgICA8cHJlIGNsYXNzPSJjb2RlLWhpZ2hsaWdodCI+JXM8L3ByZT4KPC9kaXY+CjxzY3JpcHQ+CiAgICB3aW5kb3cuY29kZXJ1bm5lcl9zb2x1dGlvbl9saW5rX2NsaWNrZWQgPSB3aW5kb3cuY29kZXJ1bm5lcl9zb2x1dGlvbl9saW5rX2NsaWNrZWQgfHwgZnVuY3Rpb24oc3JjKSB7CiAgICAgICAgdmFyIHF1ZXN0aW9uID0gc3JjLnRhcmdldC5jbG9zZXN0KCdkaXYuc3BlY2lmaWNmZWVkYmFjaycpOwogICAgICAgIHZhciBzb2x1dGlvbl9kaXYgPSBxdWVzdGlvbi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjb2RlcnVubmVyLXNjcmFtYmxlZC1hdXRob3JzLXNvbHV0aW9uJylbMF07CiAgICAgICAgdmFyIHNvbHV0aW9uX2xpbmsgPSBxdWVzdGlvbi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjb2RlcnVubmVyLXNjcmFtYmxlZC1zb2x1dGlvbi1saW5rJylbMF07CiAgICAgICAgdmFyIGNvZGUgPSBxdWVzdGlvbi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjb2RlLWhpZ2hsaWdodCcpWzBdOwoKICAgICAgICBpZiAoIWNvZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdoYXMtaGlnaGxpZ2h0JykpIHsKICAgICAgICAgICAgdmFyIGhpZ2hsaWdodCA9IHdpbmRvdy5hY2UucmVxdWlyZSgiYWNlL2V4dC9zdGF0aWNfaGlnaGxpZ2h0Iik7CiAgICAgICAgICAgIGhpZ2hsaWdodChjb2RlLCB7CiAgICAgICAgICAgICAgICBtb2RlOiAiYWNlL21vZGUvcHl0aG9uIiwKICAgICAgICAgICAgICAgIHNob3dHdXR0ZXI6IGZhbHNlCiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGhpZ2hsaWdodGVkKSB7CiAgICAgICAgICAgICAgICBjb2RlLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2FjZV9zdGF0aWNfaGlnaGxpZ2h0JylbMF0uc3R5bGVbJ2ZvbnQtc2l6ZSddID0gIjE0cHgiOwogICAgICAgICAgICB9KTsKICAgICAgICAgICAgY29kZS5jbGFzc0xpc3QuYWRkKCdoYXMtaGlnaGxpZ2h0Jyk7CiAgICAgICAgfQogICAgICAgIAogICAgICAgIGlmICghJChzb2x1dGlvbl9kaXYpLmhhc0NsYXNzKCdjb2xsYXBzaW5nJykpIHsKICAgICAgICAgICAgaWYgKCQoc29sdXRpb25fZGl2KS5hdHRyKCJleHBhbmRlZCIpID09PSAidHJ1ZSIpIHsKICAgICAgICAgICAgICAgIHNvbHV0aW9uX2xpbmsuaW5uZXJIVE1MID0gIlNob3cgc2NyYW1ibGVkIGF1dGhvcidzIHNvbHV0aW9uIjsKICAgICAgICAgICAgICAgICQoc29sdXRpb25fZGl2KS5jb2xsYXBzZSgnaGlkZScpOwogICAgICAgICAgICAgICAgJChzb2x1dGlvbl9kaXYpLmF0dHIoImV4cGFuZGVkIiwgImZhbHNlIik7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBzb2x1dGlvbl9saW5rLmlubmVySFRNTCA9ICJIaWRlIHNjcmFtYmxlZCBhdXRob3IncyBzb2x1dGlvbiI7CiAgICAgICAgICAgICAgICAkKHNvbHV0aW9uX2RpdikuY29sbGFwc2UoJ3Nob3cnKTsKICAgICAgICAgICAgICAgICQoc29sdXRpb25fZGl2KS5hdHRyKCJleHBhbmRlZCIsICJ0cnVlIik7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICB9CiAgICB2YXIgY29kZXJ1bm5lcl9hbGxfbGlua3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjb2RlcnVubmVyLXNjcmFtYmxlZC1zb2x1dGlvbi1saW5rJyk7CiAKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZXJ1bm5lcl9hbGxfbGlua3MubGVuZ3RoOyBpKyspIHsKICAgICAgICB2YXIgZWwgPSBjb2RlcnVubmVyX2FsbF9saW5rc1tpXTsKICAgICAgICBpZiAoIWVsLmNsYXNzTGlzdC5jb250YWlucygnaGFzLWNsaWNrLWhhbmRsZXInKSkgewogICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHdpbmRvdy5jb2RlcnVubmVyX3NvbHV0aW9uX2xpbmtfY2xpY2tlZCk7CiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2hhcy1jbGljay1oYW5kbGVyJyk7CiAgICAgICAgfQogICAgfSAgICAKPC9zY3JpcHQ+Cgo=</file>
<file name="__author_solution.html" path="/" encoding="base64">PGRpdiBjbGFzcz0iY29kZXJ1bm5lci10ZXN0LXJlc3VsdHMgZ29vZCI+CiAgICA8YSBjbGFzcz0iYnRuIGJ0bi1saW5rIGNvZGVydW5uZXItc29sdXRpb24tbGluayIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6I0NGQyI+U2hvdyBhdXRob3IncyBzb2x1dGlvbjwvYT4KPC9kaXY+CjxkaXYgY2xhc3M9ImNvZGVydW5uZXItYXV0aG9ycy1zb2x1dGlvbiBjb2xsYXBzZSIgZXhwYW5kZWQ9ImZhbHNlIiBzdHlsZT0ibWFyZ2luLWJvdHRvbTo4cHgiPgogICAgPHByZSBjbGFzcz0iY29kZS1oaWdobGlnaHQiPiVzPC9wcmU+CjwvZGl2Pgo8c2NyaXB0PgogICAgd2luZG93LmNvZGVydW5uZXJfc29sdXRpb25fbGlua19jbGlja2VkID0gd2luZG93LmNvZGVydW5uZXJfc29sdXRpb25fbGlua19jbGlja2VkIHx8IGZ1bmN0aW9uKHNyYykgewogICAgICAgIHZhciBxdWVzdGlvbiA9IHNyYy50YXJnZXQuY2xvc2VzdCgnZGl2LnNwZWNpZmljZmVlZGJhY2snKTsKICAgICAgICB2YXIgc29sdXRpb25fZGl2ID0gcXVlc3Rpb24uZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnY29kZXJ1bm5lci1hdXRob3JzLXNvbHV0aW9uJylbMF07CiAgICAgICAgdmFyIHNvbHV0aW9uX2xpbmsgPSBxdWVzdGlvbi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjb2RlcnVubmVyLXNvbHV0aW9uLWxpbmsnKVswXTsKICAgICAgICB2YXIgY29kZSA9IHF1ZXN0aW9uLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2NvZGUtaGlnaGxpZ2h0JylbMF07CgogICAgICAgIGlmICghY29kZS5jbGFzc0xpc3QuY29udGFpbnMoJ2hhcy1oaWdobGlnaHQnKSkgewogICAgICAgICAgICB2YXIgaGlnaGxpZ2h0ID0gd2luZG93LmFjZS5yZXF1aXJlKCJhY2UvZXh0L3N0YXRpY19oaWdobGlnaHQiKTsKICAgICAgICAgICAgaGlnaGxpZ2h0KGNvZGUsIHsKICAgICAgICAgICAgICAgIG1vZGU6ICJhY2UvbW9kZS9weXRob24iLAogICAgICAgICAgICAgICAgc2hvd0d1dHRlcjogZmFsc2UKICAgICAgICAgICAgfSwgZnVuY3Rpb24oaGlnaGxpZ2h0ZWQpIHsKICAgICAgICAgICAgICAgIGNvZGUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnYWNlX3N0YXRpY19oaWdobGlnaHQnKVswXS5zdHlsZVsnZm9udC1zaXplJ10gPSAiMTRweCI7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICBjb2RlLmNsYXNzTGlzdC5hZGQoJ2hhcy1oaWdobGlnaHQnKTsKICAgICAgICB9CiAgICAgICAgCiAgICAgICAgaWYgKCEkKHNvbHV0aW9uX2RpdikuaGFzQ2xhc3MoJ2NvbGxhcHNpbmcnKSkgewogICAgICAgICAgICBpZiAoJChzb2x1dGlvbl9kaXYpLmF0dHIoImV4cGFuZGVkIikgPT09ICJ0cnVlIikgewogICAgICAgICAgICAgICAgc29sdXRpb25fbGluay5pbm5lckhUTUwgPSAiU2hvdyBhdXRob3IncyBzb2x1dGlvbiI7CiAgICAgICAgICAgICAgICAkKHNvbHV0aW9uX2RpdikuaGlkZSgzMDApOwogICAgICAgICAgICAgICAgJChzb2x1dGlvbl9kaXYpLmF0dHIoImV4cGFuZGVkIiwgImZhbHNlIik7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBzb2x1dGlvbl9saW5rLmlubmVySFRNTCA9ICJIaWRlIGF1dGhvcidzIHNvbHV0aW9uIjsKICAgICAgICAgICAgICAgICQoc29sdXRpb25fZGl2KS5zaG93KDMwMCk7CiAgICAgICAgICAgICAgICAkKHNvbHV0aW9uX2RpdikuYXR0cigiZXhwYW5kZWQiLCAidHJ1ZSIpOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfQogICAgdmFyIGNvZGVydW5uZXJfYWxsX2xpbmtzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnY29kZXJ1bm5lci1zb2x1dGlvbi1saW5rJyk7CiAKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZXJ1bm5lcl9hbGxfbGlua3MubGVuZ3RoOyBpKyspIHsKICAgICAgICB2YXIgZWwgPSBjb2RlcnVubmVyX2FsbF9saW5rc1tpXTsKICAgICAgICBpZiAoIWVsLmNsYXNzTGlzdC5jb250YWlucygnaGFzLWNsaWNrLWhhbmRsZXInKSkgewogICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHdpbmRvdy5jb2RlcnVubmVyX3NvbHV0aW9uX2xpbmtfY2xpY2tlZCk7CiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2hhcy1jbGljay1oYW5kbGVyJyk7CiAgICAgICAgfQogICAgfSAgICAKPC9zY3JpcHQ+Cgo=</file>
<file name="__languagetask.py" path="/" encoding="base64">IiIiVGhlIGdlbmVyaWMgTGFuZ3VhZ2VUYXNrLCBzdWJjbGFzc2VzIG9mIHdoaWNoIG1hbmFnZSBjb21waWxpbmcgYW5kIGV4ZWN1dGluZwogICBjb2RlIGluIGEgcGFydGljdWxhciBsYW5ndWFnZS4KIiIiCmZyb20gZGF0ZXRpbWUgaW1wb3J0IGRhdGV0aW1lCgpXQVRDSERPR19GUkVFQk9BUkQgPSAxCgpjbGFzcyBDb21waWxlRXJyb3IoRXhjZXB0aW9uKToKICAgIGRlZiBfX2luaXRfXyhzZWxmLCBlcnJvcl9tZXNzYWdlKToKICAgICAgICBFeGNlcHRpb24uX19pbml0X18oc2VsZiwgZXJyb3JfbWVzc2FnZSkKCgpjbGFzcyBSdW5FcnJvcihFeGNlcHRpb24pOgogICAgZGVmIF9faW5pdF9fKHNlbGYsIGVycm9yX21lc3NhZ2U9JycpOgogICAgICAgIEV4Y2VwdGlvbi5fX2luaXRfXyhzZWxmLCBlcnJvcl9tZXNzYWdlKQoKY2xhc3MgTGFuZ3VhZ2VUYXNrOgogICAgZGVmIF9faW5pdF9fKHNlbGYsIHBhcmFtcywgY29kZT1Ob25lKToKICAgICAgICAiIiJJbml0aWFsaXNlIHRoZSBvYmplY3QsIHJlY29yZGluZyB0aGUgcGFyYW1ldGVycyB0aGF0IHdpbGwgY29udHJvbCBjb21waWxhdGlvbiBhbmQKICAgICAgICAgICBydW5uaW5nIHBsdXMgdGhlIGNvZGUgaWYgc3VwcGxpZWQuIENvZGUgbWF5IGJlIGFsdGVybmF0aXZlbHkgYmUgc3VwcGxpZWQgbGF0ZXIgYnkKICAgICAgICAgICBjYWxscyB0byBzZXRfY29kZS4KICAgICAgICAgICBzZWxmLnBhcmFtcyBpcyB0aGUgZGljdGlvbmFyeSBvZiB0ZW1wbGF0ZSAmIGdsb2JhbCBwYXJhbWV0ZXJzIC0gbGFuZ3VhZ2Ugc3BlY2lmaWMuCiAgICAgICAgIiIiCiAgICAgICAgc2VsZi5wYXJhbXMgPSBwYXJhbXMKICAgICAgICBzZWxmLmNvZGUgPSBjb2RlCiAgICAgICAgc2VsZi5leGVjdXRhYmxlX2J1aWx0ID0gRmFsc2UKICAgICAgICBzZWxmLmNvbXBpbGVfZXJyb3JfbWVzc2FnZSA9IE5vbmUKICAgICAgICBzZWxmLmVycm9yX21lc3NhZ2Vfb2Zmc2V0ID0gMAogICAgICAgIHNlbGYuc3RkZXJyID0gJycKICAgICAgICBzZWxmLnN0ZG91dCA9ICcnCiAgICAgICAgc2VsZi5zdGFydF90aW1lID0gZGF0ZXRpbWUubm93KCkKICAgICAgICBzZWxmLnRpbWVkX291dCA9IEZhbHNlCiAgICAgICAgaWYgJ3RvdGFsdGltZW91dCcgbm90IGluIHBhcmFtczoKICAgICAgICAgICAgc2VsZi5wYXJhbXNbJ3RvdGFsdGltZW91dCddID0gMzAgIyBTZWNzCgogICAgZGVmIHNlY29uZHNfcmVtYWluaW5nKHNlbGYpOgogICAgICAgICIiIlRoZSBudW1iZXIgb2Ygc2Vjb25kcyBvZiBleGVjdXRpb24gdGltZSByZW1haW5pbmcgYmVmb3JlIHRoZSB3YXRjaGRvZyB0aW1lciBnb2VzIG9mZi4KICAgICAgICAgICBUaGUgd2F0Y2hkb2cgdGltZXIgZ29lcyBvZmYgMSBzZWNvbmQgYmVmb3JlIHJ1bmd1YXJkIGtpbGxzIHRoZSBqb2IgKGFzIGRldGVybWluZWQgYnkgdGhlICd0aW1lb3V0JyBwYXJhbWV0ZXIpLgogICAgICAgICIiIgogICAgICAgIHRfZWxhcHNlZCA9IChkYXRldGltZS5ub3coKSAtIHNlbGYuc3RhcnRfdGltZSkudG90YWxfc2Vjb25kcygpCiAgICAgICAgcmV0dXJuIHNlbGYucGFyYW1zWyd0b3RhbHRpbWVvdXQnXSAtIHRfZWxhcHNlZCAtIFdBVENIRE9HX0ZSRUVCT0FSRAoKICAgIGRlZiBzZXRfY29kZShzZWxmLCBjb2RlLCBlcnJvcl9tZXNzYWdlX29mZnNldD0wKToKICAgICAgICAiIiJTZXQgdGhlIGNvZGUgdG8gYmUgdXNlZCBmb3Igc3Vic2VxdWVudCBjb21waWxpbmcgYW5kIHJ1bm5pbmcuIFRoZSBvcHRpb25hbCBlcnJvcl9tZXNzYWdlX29mZnNldAogICAgICAgICAgIGlzIGEgbnVtYmVyIHRvIGJlIHN1YnRyYWN0ZWQgZnJvbSBhbnkgZXJyb3IgbWVzc2FnZXMgZ2VuZXJhdGVkIGJ5IGNvbXBpbGUgYW5kIHJ1bl9jb2RlIGNhbGxzLgogICAgICAgICAgIEV4YWN0bHkgaG93IChvciBldmVuICdpZicpIGl0IGlzIHVzZWQgaXMgbGFuZ3VhZ2UgZGVwZW5kZW50LgogICAgICAgICIiIgogICAgICAgIHNlbGYuY29kZSA9IGNvZGUKICAgICAgICBzZWxmLmVycm9yX21lc3NhZ2Vfb2Zmc2V0ID0gZXJyb3JfbWVzc2FnZV9vZmZzZXQKCiAgICBkZWYgY29tcGlsZShzZWxmLCBtYWtlX2V4ZWN1dGFibGU9RmFsc2UpOgogICAgICAgICIiIkNvbXBpbGUgdGhlIGN1cnJlbnRseSBzZXQgY29kZSwgZWl0aGVyIHRvIGFuIG9iamVjdCBmaWxlIG9yCiAgICAgICAgICAgdG8gYW4gZXhlY3V0YWJsZSBmaWxlIGRlcGVuZGluZyBvbiB0aGUgZ2l2ZW4gbWFrZV9leGVjdXRhYmxlIHBhcmFtZXRlci4KICAgICAgICAgICBBZGp1c3QgYW55IGVycm9yIG1lc3NhZ2UgYnkgc3VidHJhY3RpbmcgZXJyb3JfbWVzc2FnZV9vZmZzZXQuCiAgICAgICAgICAgUmFpc2UgQ29tcGlsZUVycm9yIGlmIHRoZSBjb2RlIGRvZXMgbm90CiAgICAgICAgICAgY29tcGlsZSwgd2l0aCB0aGUgY29tcGlsYXRpb24gZXJyb3IgbWVzc2FnZSB3aXRoaW4gdGhlIGV4Y2VwdGlvbgogICAgICAgICAgIGFuZCBhbHNvIHJlY29yZGVkIGluIHNlbGYuY29tcGlsZV9lcnJvcl9tZXNzYWdlLgogICAgICAgICAgIE5vIHJldHVybiB2YWx1ZS4KICAgICAgICAiIiIKICAgICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKCJjb21waWxlIG5vdCBpbXBsZW1lbnRlZCBieSBjb25jcmV0ZSBjbGFzcyIpCgogICAgZGVmIGRpc2NhcmRfZXhlY3V0YWJsZShzZWxmKToKICAgICAgICAiIiJDYWxsZWQgaWYgc29tZXRoaW5nIGJyZWFrcyBpbiB0aGUgZXhlY3V0YWJsZSBhbmQgaXQgd2lsbCBuZWVkIHJlYnVpbGRpbmcKICAgICAgICAgICAod2l0aCBkaWZmZXJlbnQgc291cmNlLCBwcmVzdW1hYmx5KQogICAgICAgICIiIgogICAgICAgIHNlbGYuZXhlY3V0YWJsZV9idWlsdCA9IEZhbHNlCgogICAgZGVmIHJ1bl9jb2RlKHNlbGYsIHN0YW5kYXJkX2lucHV0PU5vbmUsIGJhc2hfY29tbWFuZD1Ob25lKToKICAgICAgICAiIiJSdW4gdGhlIGNvZGUgaW4gdGhlIGV4ZWN1dGFibGUgcHJvZ3JhbSB0aGF0IGEgY2FsbCB0byBjb21waWxlIGlzIGFzc3VtZWQKICAgICAgICAgICB0byBoYXZlIGNyZWF0ZWQsIHVzaW5nIHRoZSBnaXZlbiBzdGFuZGFyZCBpbnB1dC4KICAgICAgICAgICBJZiBhIGJhc2hfY29tbWFuZCBpcyBzdXBwbGllZCBpdCB1c2VkIGFzIGdpdmVuLgogICAgICAgICAgIE90aGVyd2lzZSB0aGUgY29tbWFuZCB0byBiZSBleGVjdXRlZCBpcyB0aGUgY29tcGlsZWQgZXhlY3V0YWJsZS4KICAgICAgICAgICBSZXR1cm5zIGEgdHVwbGUgb2YgdGhlIG91dHB1dCBmcm9tIHRoZQogICAgICAgICAgIHJ1biBhbmQgYSBzdGRlcnIgKG9yIGEgZGVyaXZhdGl2ZSB0aGVyZW9mKSBzdHJpbmcuIFRob3NlIHR3byB2YWx1ZXMKICAgICAgICAgICBhcmUgYWxzbyByZWNvcmRlZCBpbiBzZWxmLnN0ZG91dCBhbmQgc2VsZi5zdGRlcnIgcmVzcGVjdGl2ZWx5LgogICAgICAgICIiIgogICAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoInJ1bl9jb2RlIG5vdCBpbXBsZW1lbnRlZCBieSBjb25jcmV0ZSBjbGFzcyIp</file>
<file name="__plottools.py" path="/" encoding="base64">IiIiRGVmaW5lIHN1cHBvcnQgZnVuY3Rpb25zIGZvciB0ZXN0aW5nIG9mIG1hdHBsb3RsaWIgcXVlc3Rpb25zLgogICBUaGUgbWFpbiBmdW5jdGlvbiBpcyBwcmludF9wbG90X2luZm8sIHdoaWNoIGRpc3BsYXlzIHN1aXRhYmx5IGZvcm1hdHRlZAogICBkYXRhIGFib3V0IHRoZSBjdXJyZW50IG1hdHBsb3RsaWIgcGxvdC4KCiAgIFRoaXMgbW9kdWxlIHdvcmtzIG9ubHkgaWYgaW1wb3J0ZWQgKmFmdGVyKiBhIGNhbGwgdG8gbWF0cGxvdGxpYmcudXNlKCJBZ2ciKSBoYXMKICAgYmVlbiBkb25lLgoiIiIKaW1wb3J0IG51bXB5IGFzIG5wCmltcG9ydCBtYXRwbG90bGliLnB5cGxvdCBhcyBwbHQKZnJvbSBtYXRwbG90bGliIGltcG9ydCBjb2xvcnMgYXMgY29sb3JzCmZyb20gc2NpcHkgaW1wb3J0IGludGVycG9sYXRlCgpNQVhfTEFCRUxfTEVOR1RIID0gNjAgICMgVXNlIG11bHRpbGluZSBkaXNwbGF5IGlmIHRoZSB0aWNrIGxhYmVsIHN0cmluZyBsZW5ndGggZXhjZWVkcyB0aGlzCgpkZWYgbXlfaW50ZXJwb2xhdGUoZGF0YSwgeHMpOgogICAgIiIiUmV0dXJuIHRoZSBzcGxpbmUgaW50ZXJwb2xhdGVkIGxpc3Qgb2YgKHgsIHkpIHZhbHVlcyBhdCBhYnNjaXNzYSB4cywgZ2l2ZW4KICAgICAgIGEgbGlzdCBvZiAoeCwgeSkgcGFpcnMKICAgICIiIgogICAgZGVmIGxpbmVhcih4LCB4MCwgeTAsIHgxLCB5MSk6CiAgICAgICAgcmV0dXJuIHkwICsgKHggLSB4MCkvKHgxIC0geDApICogKHkxIC0geTApCiAgICAKICAgIGlmIGxlbihkYXRhWzosMF0pID09IDI6CiAgICAgICAgeDAsIHkwID0gZGF0YVswXVswXSwgZGF0YVswXVsxXQogICAgICAgIHgxLCB5MSA9IGRhdGFbLTFdWzBdLCBkYXRhWy0xXVsxXQogICAgICAgIHJldHVybiBbKHgsIGxpbmVhcih4LCB4MCwgeTAsIHgxLCB5MSkpIGZvciB4IGluIHhzXQogICAgZWxzZTogIyBjdWJpYwogICAgICAgIHRjayA9IGludGVycG9sYXRlLnNwbHJlcChkYXRhWzosMF0sIGRhdGFbOiwxXSwgcz0wKSAjIEN1YmljIHNwbGluZSBpbnRlcnBvbGF0b3IKICAgICAgICByZXR1cm4gemlwKHhzLCBpbnRlcnBvbGF0ZS5zcGxldih4cywgdGNrKSkgICMgRXZhbHVhdGUgYXQgcmVxdWlyZWQgeCB2YWx1ZXMKCgpkZWYgZm10X2Zsb2F0KHgpOgogICAgIiIiUmV0dXJuIGEgZm9ybWF0dGVkIGZsb2F0aW5nIHBvaW50IG51bWJlciB0byAyIGRpZ2l0cyBhY2N1cmFjeSwKICAgICAgIHJlcGxhY2luZyAtMC4wMCB3aXRoIDAuMDAiIiIKICAgIHMgPSBmInt4OjAuMmZ9IgogICAgaWYgcyA9PSAiLTAuMDAiOgogICAgICAgIHMgPSAiMC4wMCIKICAgIHJldHVybiBzCgoKZGVmIGZtdF9mbG9hdF9wYWlyKHApOgogICAgIiIiQSBmb3JtYXR0ZWQgcG9pbnQgb3Igb3RoZXIgcGFpciBvZiBmbG9hdGluZy1wb2ludCBudW1iZXJzIiIiCiAgICByZXR1cm4gZiIoe2ZtdF9mbG9hdChwWzBdKX0sIHtmbXRfZmxvYXQocFsxXSl9KSIKCgpkZWYgdGlja19mbXQodGljayk6CiAgICAiIiJGb3JtYXQgYSB0aWNrIGxhYmVsLCB3aGljaCBtYXkgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGEgZmxvYXQuIElmIGl0J3MKICAgICAgIGEgZmxvYXQsIHRyeSB0byBmb3JtYXQgaXQgYXMgYW4gaW50LCBvdGhlcndpc2UgZm9ybWF0IGl0IHRvIDIgZGVjaW1hbAogICAgICAgcGxhY2VzLgogICAgIiIiCiAgICBpZiBpc2luc3RhbmNlKHRpY2ssIHN0cik6CiAgICAgICAgcmV0dXJuIHRpY2sKICAgIGVsaWYgZmxvYXQoaW50KHRpY2spKSA9PSB0aWNrOgogICAgICAgIHJldHVybiBzdHIoaW50KHRpY2spKQogICAgZWxzZToKICAgICAgICByZXR1cm4gZiJ7dGljazouMmZ9IgogICAgCiAgICAKZGVmIG5vcm1hbGlzZV9jb2xvdXIoY29sb3VyKToKICAgICIiIkdpdmVuIGEgbWF0cGxvdGxpYiBjb2xvdXIsIGNvbnZlcnQgdG8gYSBzdGFuZGFyaXNlZCBmb3JtYXQiIiIKICAgIHJnYiA9IGNvbG9ycy50b19yZ2IoY29sb3VyKQogICAgcmV0dXJuIGYiUkdCKHtyZ2JbMF06MC4yZn0sIHtyZ2JbMV06MC4yZn0sIHtyZ2JbMl06MC4yZn0pIgoKCmRlZiBwcmludF9saW5lcyhzdWJwbG90LCB4X3NhbXBsZXMsIHNob3dfY29sb3VyLCBoYXNfbGVnZW5kKToKICAgICIiIlByaW50IGFsbCBsaW5lcyBpbiB0aGUgcGxvdCBzaG93aW5nIHkgdmFsdWVzIGludGVycGxvbGF0ZWQgYXQgdGhlIGdpdmVuIHggc2FtcGxlIHBvaW50cywKICAgICAgIGlmIG5vdCBOb25lLiBPdGhlcndpc2UgcHJpbnQganVzdCB0aGUgZmlyc3QgNSBhbmQgbGFzdCA1IHBvaW50cy4gQWxzbwogICAgICAgc2hvdyBsaW5lIGNvbG91cnMgaWYgc2hvd19jb2xvdXIgaXMgVHJ1ZS4KICAgICIiIgogICAgbGluZXMgPSBzdWJwbG90LmdldF9saW5lcygpCiAgICBpZiBsZW4obGluZXMpID09IDA6CiAgICAgICAgcHJpbnQoIk5vIHBsb3R0ZWQgbGluZXMgZm91bmQiKQogICAgICAgIHJldHVybgogICAgbXVsdGlsaW5lcyA9IGxlbihsaW5lcykgPiAxCiAgICBpZiBtdWx0aWxpbmVzOgogICAgICAgIHByaW50KGYie2xlbihsaW5lcyl9IHNlcGFyYXRlIHBsb3RzIGZvdW5kIikKICAgIGZvciBpLCBsaW5lIGluIGVudW1lcmF0ZShsaW5lcywgMSk6CiAgICAgICAgaWYgbXVsdGlsaW5lczoKICAgICAgICAgICAgcHJpbnQoZiJMaW5lIHtpfToiKQogICAgICAgIGlmIHNob3dfY29sb3VyOgogICAgICAgICAgICBwcmludCgiQ29sb3I6Iiwgbm9ybWFsaXNlX2NvbG91cihsaW5lLmdldF9jb2xvcigpKSkKICAgICAgICBwcmludCgiTWFya2VyOiIsIGxpbmUuZ2V0X21hcmtlcigpKQogICAgICAgIHByaW50KCJMaW5lIHN0eWxlOiIsIGxpbmUuZ2V0X2xpbmVzdHlsZSgpKQogICAgICAgIGxhYmVsID0gbGluZS5nZXRfbGFiZWwoKQogICAgICAgIGlmIGhhc19sZWdlbmQgYW5kIGxhYmVsOgogICAgICAgICAgICBwcmludCgiTGFiZWw6IiwgbGFiZWwpCiAgICAgICAgZGF0YSA9IGxpbmUuZ2V0X3h5ZGF0YSgpCiAgICAgICAgaWYgeF9zYW1wbGVzIGlzIG5vdCBOb25lOgogICAgICAgICAgICBwcmludChmIkZpcnN0IHBvaW50OiB7Zm10X2Zsb2F0X3BhaXIoZGF0YVswXSl9IikKICAgICAgICAgICAgcHJpbnQoZiJMYXN0IHBvaW50OiB7Zm10X2Zsb2F0X3BhaXIoZGF0YVstMV0pfSIpCiAgICAgICAgICAgIHByaW50KGYiSW50ZXJwb2xhdGluZyBsaW5lIGF0IHNlbGVjdGVkIHggdmFsdWVzOiIpCiAgICAgICAgICAgIGludGVycG9sYXRlZCA9IG15X2ludGVycG9sYXRlKGRhdGEsIHhfc2FtcGxlcykKICAgICAgICAgICAgZm9yIHAgaW4gaW50ZXJwb2xhdGVkOgogICAgICAgICAgICAgICAgcHJpbnQoZm10X2Zsb2F0X3BhaXIocCkpCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcHJpbnQoZiJOdW0gcG9pbnRzOiB7bGVuKGRhdGEpfSIpCiAgICAgICAgICAgIG4gPSBtaW4obGVuKGRhdGEpLCA1KQogICAgICAgICAgICBwb2ludHMgPSAnXG4gICAgJy5qb2luKGZtdF9mbG9hdF9wYWlyKHApIGZvciBwIGluIGRhdGFbOm5dKQogICAgICAgICAgICBwcmludChmIkZpcnN0IHtufSBwb2ludHM6XG4gICAge3BvaW50c30iKQogICAgICAgICAgICBsYXN0X24gPSBtaW4obGVuKGRhdGEpIC0gbiwgNSkKICAgICAgICAgICAgaWYgbGFzdF9uOgogICAgICAgICAgICAgICAgcG9pbnRzID0gJ1xuICAgICcuam9pbihmbXRfZmxvYXRfcGFpcihwKSBmb3IgcCBpbiBkYXRhWy1sYXN0X246XSkKICAgICAgICAgICAgICAgIHByaW50KGYiTGFzdCB7bGFzdF9ufSBwb2ludHM6XG4gICAge3BvaW50c30iKQogICAgICAgIGlmIG11bHRpbGluZXM6CiAgICAgICAgICAgIHByaW50KCkKCgpkZWYgaW5fcmFuZ2UobGFiZWxzLCBsaW1pdHMpOgogICAgIiIiUmV0dXJuIHRoZSBsaXN0IG9mIGF4aXMgbGFiZWxzLCBmaWx0ZXJlZCB0byBpbmNsdWRlIG9ubHkgdGhvc2Ugd2l0aGluCiAgICAgICB0aGUgZ2l2ZW4gbGltaXRzIChtaW4sIG1heCkuIElmIGFueSBvZiB0aGUgYXhpcyBsYWJlbHMgYXJlIG5vbi1udW1lcmljCiAgICAgICB0aGUgbGlzdCBpcyByZXR1cm5lZCB1bmNoYW5nZWQuCiAgICAiIiIKICAgIHRyeToKICAgICAgICBjbGlwcGVkX2xhYmVscyA9IFtdCiAgICAgICAgZm9yIHMgaW4gbGFiZWxzOgogICAgICAgICAgICBzX29yaWcgPSBzCiAgICAgICAgICAgIGlmIGlzaW5zdGFuY2Uocywgc3RyKToKICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJ+KIkicsICctJykKICAgICAgICAgICAgaWYgbGltaXRzWzBdIDw9IGZsb2F0KHMpIDw9IGxpbWl0c1sxXToKICAgICAgICAgICAgICAgIGNsaXBwZWRfbGFiZWxzLmFwcGVuZChzX29yaWcpCiAgICAgICAgcmV0dXJuIGNsaXBwZWRfbGFiZWxzCiAgICBleGNlcHQgVmFsdWVFcnJvcjoKICAgICAgICByZXR1cm4gbGFiZWxzCgoKZGVmIHByaW50X2JhcnMoc3VicGxvdCwgYmFyX2luZGljZXM9Tm9uZSwgc2hvd19jb2xvdXI9RmFsc2UpOgogICAgIiIiUHJpbnQgYSBsaXN0IG9mIGFsbCBiYXJzIGlmIGJhcl9pbmRpY2VzIGlzIE5vbmUgb3IgYSBsaXN0IG9mIHRoZQogICAgICAgYmFycyB3aXRoIHRoZSBnaXZlbiBpbmRpY2VzLCBvdGhlcndpc2UuCiAgICAiIiIKICAgIHByaW50KCJCYXJzOiIpCiAgICBiYXJzID0gc3VicGxvdC5wYXRjaGVzCiAgICBpZiBiYXJzIGFuZCBzaG93X2NvbG91cjoKICAgICAgICBwcmludChmIkZpcnN0IGJhciBjb2xvdXI6IHtub3JtYWxpc2VfY29sb3VyKGJhcnNbMF0uZ2V0X2ZhY2Vjb2xvcigpKX0iKQogICAgaWYgYmFyX2luZGljZXMgaXMgTm9uZToKICAgICAgICBiYXJfaW5kaWNlcyA9IHJhbmdlKDAsIGxlbihzdWJwbG90LnBhdGNoZXMpKQogICAgZm9yIGkgaW4gYmFyX2luZGljZXM6CiAgICAgICAgdHJ5OgogICAgICAgICAgICBiYXIgPSBzdWJwbG90LnBhdGNoZXNbaV0KICAgICAgICAgICAgcHJpbnQoZiJCYXJ7aX06IGhlaWdodCA9IHtiYXIuZ2V0X2hlaWdodCgpOi4yZn0iKQogICAgICAgIGV4Y2VwdCBJbmRleEVycm9yOgogICAgICAgICAgICBwcmludChmIkJhcntpfSBub3QgZm91bmQuIE51bWJlciBvZiBiYXJzID0ge2xlbihzdWJwbG90LnBhdGNoZXMpfSIpCiAgICAgICAgICAgIGJyZWFrCiAgICAgICAgCiAgICAgICAgCiAgICAgICAgCmRlZiB0aWNrX2xhYmVsX3RleHQobGFiZWxzKToKICAgICIiIlJldHVybiBhIHN0cmluZyBzdWl0YWJsZSBmb3IgZGlzcGxheWluZyB0aWNrIGxhYmVscyIiIgogICAgbGFiZWxfdGV4dCA9ICcsICcuam9pbihsYWJlbHMpCiAgICBpZiBsZW4obGFiZWxfdGV4dCkgPiBNQVhfTEFCRUxfTEVOR1RIOgogICAgICAgIGxhYmVsX3RleHQgPSAnXG4nLmpvaW4obGFiZWxzKQogICAgcmV0dXJuIGxhYmVsX3RleHQgICAKCgpkZWYgcHJpbnRfcGxvdF9pbmZvKGRhdGFfdHlwZSwKICAgICAgICAgICAgICAgICAgICB4X3NhbXBsZXM9Tm9uZSwKICAgICAgICAgICAgICAgICAgICBiYXJfaW5kaWNlcz1Ob25lLAogICAgICAgICAgICAgICAgICAgIHNob3dfeGxpbT1GYWxzZSwgc2hvd195bGltPUZhbHNlLAogICAgICAgICAgICAgICAgICAgIHNob3dfY29sb3VyPUZhbHNlLAogICAgICAgICAgICAgICAgICAgIHNob3dfeHRpY2tsYWJlbHM9Tm9uZSwgICMgRGVmYXVsdCBpcyBUcnVlIGZvciBiYXIgY2hhcnMsIEZhbHNlIG90aGVyd2lzZQogICAgICAgICAgICAgICAgICAgIHNob3dfeXRpY2tsYWJlbHM9RmFsc2UsCiAgICAgICAgICAgICAgICAgICAgKToKICAgICIiIk91dHB1dCBrZXkgYXR0cmlidXRlcyBvZiBjdXJyZW50IHBsb3QsIGFzIGRlZmluZWQgYnkgcGx0LmdjYSgpLgogICAgICAgZGF0YV90eXBlIG11c3QgYmUgb25lIG9mICdwb2ludHMnLCAnbGluZXMnIG9yICdiYXJzJywgdG8gcHJpbnQgdGhlCiAgICAgICBhcHByb3ByaWF0ZSB0eXBlIG9mIGRhdGEuCiAgICAgICB4X3NhbXBsZXMsIG1lYW5pbmdmdWwgb25seSBpZiBkYXRhX3R5cGUgPSAnbGluZXMnLCBpcyBhIGxpc3Qgb2YgeCB2YWx1ZXMKICAgICAgIGF0IHdoaWNoIHRoZSBncmFwaCB5IHZhbHVlcyBzaG91bGQgYmUgcHJpbnRlZAogICAgIiIiCiAgICB0cnk6CiAgICAgICAgYXhlcyA9IHBsdC5nY2YoKS5nZXRfYXhlcygpCiAgICAgICAgdGV4dHMgPSBwbHQuZ2NmKCkudGV4dHMKICAgICAgICBpZiBsZW4oYXhlcykgPiAxOgogICAgICAgICAgICBwcmludChmIkZpZ3VyZSBoYXMge2xlbihheGVzKX0gc3VicGxvdHMiKQogICAgICAgIGlmIGxlbih0ZXh0cykgIT0gMDoKICAgICAgICAgICAgcHJpbnQoZiJTdXB0aXRsZToge3RleHRzWzBdLmdldF90ZXh0KCl9XG4iKQogICAgICAgIGZvciBpLCBjdXJyZW50X2F4ZXMgaW4gZW51bWVyYXRlKGF4ZXMsIDEpOgogICAgICAgICAgICBpZiBsZW4oYXhlcykgPiAxOgogICAgICAgICAgICAgICAgcHJpbnQoZiJTdWJwbG90IHtpfVxuLS0tLS0tLS0tIikKICAgICAgICAgICAgc3VicGxvdCA9IGN1cnJlbnRfYXhlcy5heGVzCiAgICAgICAgICAgIGhhc19sZWdlbmQgPSBzdWJwbG90LmdldF9sZWdlbmQoKSBpcyBub3QgTm9uZQogICAgICAgICAgICBwcmludCgiUGxvdCB0aXRsZTogJ3t9JyIuZm9ybWF0KGN1cnJlbnRfYXhlcy50aXRsZS5nZXRfdGV4dCgpKSkKICAgICAgICAgICAgcHJpbnQoIlgtYXhpcyBsYWJlbDogJ3t9JyIuZm9ybWF0KHN1YnBsb3QuZ2V0X3hsYWJlbCgpKSkKICAgICAgICAgICAgcHJpbnQoIlktYXhpcyBsYWJlbDogJ3t9JyIuZm9ybWF0KHN1YnBsb3QuZ2V0X3lsYWJlbCgpKSkKICAgICAgICAgICAgeGdyaWRsaW5lcyA9IHN1YnBsb3QuZ2V0X3hncmlkbGluZXMoKQogICAgICAgICAgICB5Z3JpZGxpbmVzID0gc3VicGxvdC5nZXRfeWdyaWRsaW5lcygpCiAgICAgICAgICAgIGdyaWR4X29uID0gbGVuKHhncmlkbGluZXMpID4gMCBhbmQgeGdyaWRsaW5lc1swXS5nZXRfdmlzaWJsZSgpCiAgICAgICAgICAgIGdyaWR5X29uID0gbGVuKHlncmlkbGluZXMpID4gMCBhbmQgeWdyaWRsaW5lc1swXS5nZXRfdmlzaWJsZSgpCiAgICAgICAgICAgIHByaW50KGYiKHgsIHkpIGdyaWQgbGluZXMgZW5hYmxlZDogKHtncmlkeF9vbn0sIHtncmlkeV9vbn0pIikKICAgICAgICAgICAgeGxpbSA9IHN1YnBsb3QuZ2V0X3hsaW0oKQogICAgICAgICAgICB5bGltID0gc3VicGxvdC5nZXRfeWxpbSgpCiAgICAgICAgICAgIGlmIHNob3dfeGxpbToKICAgICAgICAgICAgICAgIHByaW50KGYiWC1heGlzIGxpbWl0czoge2ZtdF9mbG9hdF9wYWlyKHhsaW0pfSIpCiAgICAgICAgICAgIGlmIHNob3dfeWxpbToKICAgICAgICAgICAgICAgIHByaW50KGYiWS1heGlzIGxpbWl0czoge2ZtdF9mbG9hdF9wYWlyKHlsaW0pfSIpCiAgICAgICAgICAgIGlmIGRhdGFfdHlwZSA9PSAncG9pbnRzJzoKICAgICAgICAgICAgICAgIHByaW50X2xpbmVzKHN1YnBsb3QsIE5vbmUsIHNob3dfY29sb3VyLCBoYXNfbGVnZW5kKQogICAgICAgICAgICBlbGlmIGRhdGFfdHlwZSA9PSAnbGluZXMnOgogICAgICAgICAgICAgICAgcHJpbnRfbGluZXMoc3VicGxvdCwgeF9zYW1wbGVzLCBzaG93X2NvbG91ciwgaGFzX2xlZ2VuZCkKICAgICAgICAgICAgZWxpZiBkYXRhX3R5cGUgPT0gJ2JhcnMnOgogICAgICAgICAgICAgICAgcHJpbnRfYmFycyhzdWJwbG90LCBiYXJfaW5kaWNlcywgc2hvd19jb2xvdXIpCgogICAgICAgICAgICBpZiBzaG93X3h0aWNrbGFiZWxzIG9yIChzaG93X3h0aWNrbGFiZWxzIGlzIE5vbmUgYW5kIGRhdGFfdHlwZSA9PSAnYmFycycpOgogICAgICAgICAgICAgICAgeF90aWNrX2xhYmVscyA9IFtsYWJlbC5nZXRfdGV4dCgpIGZvciBsYWJlbCBpbiBzdWJwbG90LmdldF94dGlja2xhYmVscygpXQogICAgICAgICAgICAgICAgaWYgYWxsKGxhYmVsLnN0cmlwKCkgPT0gJycgZm9yIGxhYmVsIGluIHhfdGlja19sYWJlbHMpOgogICAgICAgICAgICAgICAgICAgIHhfdGlja19sYWJlbHMgPSBbdGlja19mbXQocG9zKSBmb3IgcG9zIGluIHN1YnBsb3QuZ2V0X3h0aWNrcygpXQogICAgICAgICAgICAgICAgeF90aWNrX2xhYmVscyA9IGluX3JhbmdlKHhfdGlja19sYWJlbHMsIHhsaW0pCiAgICAgICAgICAgICAgICBwcmludCgnXG5YLWF4aXMgdGljayBsYWJlbHM6JykKICAgICAgICAgICAgICAgIHByaW50KHRpY2tfbGFiZWxfdGV4dCh4X3RpY2tfbGFiZWxzKSkKICAgICAgICAgICAgICAgIAogICAgICAgICAgICBpZiBzaG93X3l0aWNrbGFiZWxzOgogICAgICAgICAgICAgICAgeV90aWNrX2xhYmVscyA9IFtsYWJlbC5nZXRfdGV4dCgpIGZvciBsYWJlbCBpbiBzdWJwbG90LmdldF95dGlja2xhYmVscygpXQogICAgICAgICAgICAgICAgaWYgYWxsKGxhYmVsLnN0cmlwKCkgPT0gJycgZm9yIGxhYmVsIGluIHlfdGlja19sYWJlbHMpOgogICAgICAgICAgICAgICAgICAgIHlfdGlja19sYWJlbHMgPSBbdGlja19mbXQocG9zKSBmb3IgcG9zIGluIHN1YnBsb3QuZ2V0X3l0aWNrcygpXQogICAgICAgICAgICAgICAgeV90aWNrX2xhYmVscyA9IGluX3JhbmdlKHlfdGlja19sYWJlbHMsIHlsaW0pCiAgICAgICAgICAgICAgICBwcmludCgiXG5ZLWF4aXMgdGljayBsYWJlbHM6IikKICAgICAgICAgICAgICAgIHByaW50KHRpY2tfbGFiZWxfdGV4dCh5X3RpY2tfbGFiZWxzKSkKICAgICAgICAgICAgICAgIAogICAgICAgICAgICBpZiBoYXNfbGVnZW5kOgogICAgICAgICAgICAgICAgcHJpbnQoZiJMZWdlbmQ6IFRydWUiKQogICAgICAgICAgICAgICAgCiAgICAgICAgICAgIGlmIGxlbihheGVzKSA+IDE6CiAgICAgICAgICAgICAgICBwcmludCg0MCAqICI9IikKICAgICAgICAgICAgICAgIHByaW50KCkKICAgICAgICAgICAgICAgIAoKICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZXhjZXB0aW9uOgogICAgICAgIHByaW50KCJGYWlsZWQgdG8gZ2V0IHBsb3QgaW5mbzoiLCBzdHIoZXhjZXB0aW9uKSkK</file>
<file name="__pystylechecker.py" path="/" encoding="base64">IiIiQWxsIHRoZSBzdHlsZSBjaGVja2luZyBjb2RlIGZvciBQeXRob24zIiIiCgpmcm9tIGlvIGltcG9ydCBCeXRlc0lPCmltcG9ydCBvcwppbXBvcnQgc3VicHJvY2VzcwppbXBvcnQgYXN0CmltcG9ydCB0b2tlbml6ZQppbXBvcnQgdG9rZW4KaW1wb3J0IHJlCmltcG9ydCBzaHV0aWwKZnJvbSBjb2xsZWN0aW9ucyBpbXBvcnQgZGVmYXVsdGRpY3QKCmNsYXNzIFN0eWxlQ2hlY2tlcjoKICAgIGRlZiBfX2luaXRfXyhzZWxmLCBwcmVsdWRlLCBzdHVkZW50X2Fuc3dlciwgcGFyYW1zKToKICAgICAgICBzZWxmLnByZWx1ZGUgPSBwcmVsdWRlCiAgICAgICAgc2VsZi5zdHVkZW50X2Fuc3dlciA9IHN0dWRlbnRfYW5zd2VyCiAgICAgICAgc2VsZi5wYXJhbXMgPSBwYXJhbXMKICAgICAgICBzZWxmLmZ1bmN0aW9uX2NhbGxfbWFwID0gTm9uZQogICAgICAgIHNlbGYuX3RyZWUgPSBOb25lCgogICAgQHByb3BlcnR5CiAgICBkZWYgdHJlZShzZWxmKToKICAgICAgICBpZiBzZWxmLl90cmVlIGlzIE5vbmU6CiAgICAgICAgICAgIHNlbGYuX3RyZWUgPSBhc3QucGFyc2Uoc2VsZi5zdHVkZW50X2Fuc3dlcikKICAgICAgICByZXR1cm4gc2VsZi5fdHJlZQoKICAgIGRlZiBzdHlsZV9lcnJvcnMoc2VsZik6CiAgICAgICAgIiIiUmV0dXJuIGEgbGlzdCBvZiBlcnJvcnMgZnJvbSBsb2NhbCBzdHlsZSBjaGVja3MgcGx1cyBweWxpbnQgYW5kL29yIG15cHkKICAgICAgICAiIiIKICAgICAgICBlcnJvcnMgPSBbXQogICAgICAgIHNvdXJjZSA9IG9wZW4oJ19fc291cmNlLnB5JywgJ3cnLCBlbmNvZGluZz0idXRmLTgiKQogICAgICAgIGNvZGVfdG9fY2hlY2sgPSBzZWxmLnByZWx1ZGUgKyBzZWxmLnN0dWRlbnRfYW5zd2VyCiAgICAgICAgcHJlbHVkZV9sZW4gPSBsZW4oc2VsZi5wcmVsdWRlLnNwbGl0bGluZXMoKSkKICAgICAgICBzb3VyY2Uud3JpdGUoY29kZV90b19jaGVjaykKICAgICAgICBzb3VyY2UuY2xvc2UoKQogICAgICAgIGVudiA9IG9zLmVudmlyb24uY29weSgpCiAgICAgICAgZW52WydIT01FJ10gPSBvcy5nZXRjd2QoKQogICAgICAgIHB5bGludF9vcHRzID0gc2VsZi5wYXJhbXMuZ2V0KCdweWxpbnRvcHRpb25zJyxbXSkKICAgICAgICBwcmVjaGVja2VycyA9IHNlbGYucGFyYW1zLmdldCgncHJlY2hlY2tlcnMnLCBbJ3B5bGludCddKQogICAgICAgIHJlc3VsdCA9ICcnCgogICAgICAgIGlmICdweWxpbnQnIGluIHByZWNoZWNrZXJzOgogICAgICAgICAgICB0cnk6ICAjIFJ1biBweWxpbnQKICAgICAgICAgICAgICAgIGNtZCA9ICdweXRob24zLjkgLW0gcHlsaW50ICcgKyAnICcuam9pbihweWxpbnRfb3B0cykgKyAnIF9fc291cmNlLnB5JwogICAgICAgICAgICAgICAgcmVzdWx0ID0gc3VicHJvY2Vzcy5jaGVja19vdXRwdXQoY21kLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGRlcnI9c3VicHJvY2Vzcy5TVERPVVQsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXZlcnNhbF9uZXdsaW5lcz1UcnVlLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnY9ZW52LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGVsbD1UcnVlKQogICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgICAgICAgICByZXN1bHQgPSBlLm91dHB1dAogICAgICAgICAgICAgICAgCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAjIChtY3Q2MykgQWJvcnQgaWYgdGhlcmUgYXJlIGFueSBjb21tZW50cyBjb250YWluaW5nICdweWxpbnQ6Jy4KICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICB0b2tlbml6ZXIgPSB0b2tlbml6ZS50b2tlbml6ZShCeXRlc0lPKHNlbGYuc3R1ZGVudF9hbnN3ZXIuZW5jb2RlKCd1dGYtOCcpKS5yZWFkbGluZSkKICAgICAgICAgICAgICAgICAgICBmb3IgdG9rZW5fdHlwZSwgdG9rZW5fdGV4dCwgKl8gaW4gdG9rZW5pemVyOgogICAgICAgICAgICAgICAgICAgICAgICBpZiB0b2tlbl90eXBlID09IHRva2VuaXplLkNPTU1FTlQgYW5kICdweWxpbnQ6JyBpbiB0b2tlbl90ZXh0OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLmFwcGVuZCgiQ29tbWVudHMgY2FuIG5vdCBpbmNsdWRlICdweWxpbnQ6JyIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhawogICAgICAgIAogICAgICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgICAgICAgICBlcnJvcnMuYXBwZW5kKCJTb21ldGhpbmcgd2VudCB3cm9uZyB3aGlsZSBwYXJzaW5nIGNvbW1lbnRzLiBSZXBvcnQgdGhpcy4iKQoKICAgICAgICAgICAgaWYgIlVzaW5nIGNvbmZpZyBmaWxlIiBpbiByZXN1bHQ6CiAgICAgICAgICAgICAgICByZXN1bHQgPSAnXG4nLmpvaW4ocmVzdWx0LnNwbGl0bGluZXMoKVsxOl0pLnNwbGl0KCkKCiAgICAgICAgaWYgcmVzdWx0ID09ICcnIGFuZCAnbXlweScgaW4gcHJlY2hlY2tlcnM6CiAgICAgICAgICAgIGNvZGVfdG9fY2hlY2sgPSAnZnJvbSB0eXBpbmcgaW1wb3J0IExpc3QgYXMgbGlzdCwgRGljdCBhcyBkaWN0LCBUdXBsZSBhcyB0dXBsZSwgU2V0IGFzIHNldCwgQW55XG4nICsgY29kZV90b19jaGVjawogICAgICAgICAgICB3aXRoIG9wZW4oJ19fc291cmNlMi5weScsICd3JywgZW5jb2Rpbmc9J3V0Zi04JykgYXMgb3V0ZmlsZToKICAgICAgICAgICAgICAgIG91dGZpbGUud3JpdGUoY29kZV90b19jaGVjaykKICAgICAgICAgICAgY21kID0gJ3B5dGhvbjMuOCAtbSBteXB5IC0tbm8tZXJyb3Itc3VtbWFyeSAtLW5vLXN0cmljdC1vcHRpb25hbCBfX3NvdXJjZTIucHknCiAgICAgICAgICAgIHRyeTogIyBSdW4gbXlweQogICAgICAgICAgICAgICAgc3VicHJvY2Vzcy5jaGVja19vdXRwdXQoY21kLCAgIyBSYWlzZXMgYW4gZXhjZXB0aW9uIGlmIHRoZXJlIGFyZSBlcnJvcnMKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZGVycj1zdWJwcm9jZXNzLlNURE9VVCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXZlcnNhbF9uZXdsaW5lcz1UcnVlLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW52PWVudiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoZWxsPVRydWUpCiAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICAgICAgICAgIHJlc3VsdCA9IGUub3V0cHV0CiAgICAgICAgICAgICAgICBsaW5lX251bV9maXggPSBsYW1iZGEgbWF0Y2g6ICJMaW5lICIgKyBzdHIoaW50KG1hdGNoWzFdKSAtIDEgLSBwcmVsdWRlX2xlbikgKyBtYXRjaFsyXQogICAgICAgICAgICAgICAgcmVzdWx0ID0gcmUuc3ViKHInX19zb3VyY2UyLnB5OihcZCspKC4qKScsIGxpbmVfbnVtX2ZpeCwgcmVzdWx0KQoKICAgICAgICBpZiByZXN1bHQgPT0gJycgYW5kIHNlbGYucGFyYW1zLmdldCgncmVxdWlyZXR5cGVoaW50cycsIEZhbHNlKToKICAgICAgICAgICAgYmFkX2Z1bmNzID0gc2VsZi5jaGVja190eXBlX2hpbnRzKCkKICAgICAgICAgICAgZm9yIGZ1biBpbiBiYWRfZnVuY3M6CiAgICAgICAgICAgICAgICByZXN1bHQgKz0gZiJGdW5jdGlvbiAne2Z1bn0nIGRvZXMgbm90IGhhdmUgY29ycmVjdCB0eXBlIGhpbnRzXG4iCgogICAgICAgIGlmIHJlc3VsdDoKICAgICAgICAgICAgZXJyb3JzID0gcmVzdWx0LnN0cmlwKCkuc3BsaXRsaW5lcygpCiAgICAgICAgICAgIGVycm9ycy5hcHBlbmQoIlNvcnJ5LCBidXQgeW91ciBjb2RlIGRvZXNuJ3QgcGFzcyB0aGUgc3R5bGUgY2hlY2tzLiIpCgogICAgICAgIHJldHVybiBlcnJvcnMKICAgIAogICAgZGVmIHByZXR0aWVkKHNlbGYsIGNvbnN0cnVjdCk6CiAgICAgICAgIiIiRXhwYW5kLCBpZiBwb3NzaWJsZSwgdGhlIG5hbWUgb2YgdGhlIGdpdmVuIFB5dGhvbiBjb25zdHJ1Y3QgdG8gYSBtb3JlCiAgICAgICAgICAgdXNlciBmcmllbmRseSB2ZXJzaW9uLCBlLmcuICdsaXN0Y29tcHJlaGVuc2lvbicgLT4gJ2xpc3QgY29tcHJlaGVuc2lvbicKICAgICAgICAiIiIKICAgICAgICBleHBhbmRlZCA9IHsKICAgICAgICAgICAgJ2xpc3Rjb21wcmVoZW5zaW9uJzogJ2xpc3QgY29tcHJlaGVuc2lvbicsCiAgICAgICAgICAgICd3aGlsZSc6ICd3aGlsZSBsb29wJywKICAgICAgICAgICAgJ2Zvcic6ICdmb3IgbG9vcCcsCiAgICAgICAgICAgICd0cnknOiAndHJ5IC4uLiBleGNlcHQgc3RhdGVtZW50JywKICAgICAgICAgICAgJ2RpY3Rjb21wcmVoZW5zaW9uJzogJ2RpY3Rpb25hcnkgY29tcHJlaGVuc2lvbicsCiAgICAgICAgICAgICdzbGljZSc6ICdzbGljZScKICAgICAgICB9CiAgICAgICAgaWYgY29uc3RydWN0IGluIGV4cGFuZGVkOgogICAgICAgICAgICByZXR1cm4gZXhwYW5kZWRbY29uc3RydWN0XQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHJldHVybiBmIntjb25zdHJ1Y3R9IHN0YXRlbWVudCIKCiAgICBkZWYgbG9jYWxfZXJyb3JzKHNlbGYpOgogICAgICAgICIiIlBlcmZvcm0gdmFyaW91cyBsb2NhbCBjaGVja3MgYXMgc3BlY2lmaWVkIGJ5IHRoZSBjdXJyZW50IHNldCBvZgogICAgICAgICAgIHRlbXBsYXRlIHBhcmFtZXRlcnMuCiAgICAgICAgIiIiCiAgICAgICAgZXJyb3JzID0gW10KCiAgICAgICAgZm9yIGJhbm5lZCBpbiBzZWxmLnBhcmFtcy5nZXQoJ3Byb3NjcmliZWRzdWJzdHJpbmdzJywgW10pOgogICAgICAgICAgICBpZiBiYW5uZWQgaW4gc2VsZi5zdHVkZW50X2Fuc3dlcjoKICAgICAgICAgICAgICAgIGVycm9ycy5hcHBlbmQoZiJUaGUgc3RyaW5nICd7YmFubmVkfScgaXMgbm90IHBlcm1pdHRlZCBhbnl3aGVyZSBpbiB5b3VyIGNvZGUuIikKCiAgICAgICAgZm9yIHJlcXVpcmVkIGluIHNlbGYucGFyYW1zLmdldCgncmVxdWlyZWRzdWJzdHJpbmdzJywgW10pOgogICAgICAgICAgICBpZiBpc2luc3RhbmNlKHJlcXVpcmVkLCBzdHIpIGFuZCByZXF1aXJlZCBub3QgaW4gc2VsZi5zdHVkZW50X2Fuc3dlcjoKICAgICAgICAgICAgICAgIGVycm9ycy5hcHBlbmQoZidUaGUgc3RyaW5nICJ7cmVxdWlyZWR9IiBtdXN0IG9jY3VyIHNvbWV3aGVyZSBpbiB5b3VyIGNvZGUuJykKICAgICAgICAgICAgZWxpZiBpc2luc3RhbmNlKHJlcXVpcmVkLCBkaWN0KTogCiAgICAgICAgICAgICAgICBpZiAncGF0dGVybicgaW4gcmVxdWlyZWQgYW5kIG5vdCByZS5maW5kYWxsKHJlcXVpcmVkWydwYXR0ZXJuJ10sIHNlbGYuc3R1ZGVudF9hbnN3ZXIpOgogICAgICAgICAgICAgICAgICAgIGVycm9ycy5hcHBlbmQocmVxdWlyZWRbJ2Vycm9ybWVzc2FnZSddKQogICAgICAgICAgICAgICAgZWxpZiAnc3RyaW5nJyBpbiByZXF1aXJlZCBhbmQgcmVxdWlyZWRbJ3N0cmluZyddIG5vdCBpbiBzZWxmLnN0dWRlbnRfYW5zd2VyOgogICAgICAgICAgICAgICAgICAgIGVycm9ycy5hcHBlbmQocmVxdWlyZWRbJ2Vycm9ybWVzc2FnZSddKQoKICAgICAgICBpZiBzZWxmLnBhcmFtcy5nZXQoJ2Jhbmdsb2JhbGNvZGUnLCBUcnVlKToKICAgICAgICAgICAgZXJyb3JzICs9IHNlbGYuZmluZF9nbG9iYWxfY29kZSgpCgogICAgICAgIGlmIG5vdCBzZWxmLnBhcmFtcy5nZXQoJ2FsbG93bmVzdGVkZnVuY3Rpb25zJywgVHJ1ZSk6CiAgICAgICAgICAgICMgRXhjZXB0IGZvciBsZWdhY3kgcXVlc3Rpb25zIG9yIHdoZXJlIGV4cGxpY2l0bHkgYWxsb3dlZCwgbmVzdGVkIGZ1bmN0aW9ucyBhcmUgYmFubmVkCiAgICAgICAgICAgIG5lc3RlZF9mdW5jcyA9IHNlbGYuZmluZF9uZXN0ZWRfZnVuY3Rpb25zKCkKICAgICAgICAgICAgZm9yIGZ1bmMgaW4gbmVzdGVkX2Z1bmNzOgogICAgICAgICAgICAgICAgZXJyb3JzLmFwcGVuZCgiRnVuY3Rpb24gJ3t9JyBpcyBkZWZpbmVkIGluc2lkZSBhbm90aGVyIGZ1bmN0aW9uIi5mb3JtYXQoZnVuYykpCgogICAgICAgIG1heF9sZW5ndGggPSBzZWxmLnBhcmFtc1snbWF4ZnVuY3Rpb25sZW5ndGgnXQogICAgICAgIGJhZF9mdW5jcyA9IHNlbGYuZmluZF90b29fbG9uZ19mdW5jcyhtYXhfbGVuZ3RoKQogICAgICAgIGZvciBmdW5jLCBjb3VudCBpbiBiYWRfZnVuY3M6CiAgICAgICAgICAgIGVycm9ycy5hcHBlbmQoIkZ1bmN0aW9uICd7fScgaXMgdG9vIGxvbmdcbih7fSBzdGF0ZW1lbnRzLCBtYXggaXMge30pIgogICAgICAgICAgICAgICAgICAgICAgICAgICIiLmZvcm1hdChmdW5jLCBjb3VudCwgbWF4X2xlbmd0aCkpCgogICAgICAgIGJhZF91c2VkID0gc2VsZi5maW5kX2lsbGVnYWxfZnVuY3Rpb25zKCkKICAgICAgICBmb3IgbmFtZSBpbiBiYWRfdXNlZDoKICAgICAgICAgICAgZXJyb3JzLmFwcGVuZCgiWW91IGNhbGxlZCB0aGUgYmFubmVkIGZ1bmN0aW9uICd7fScuIi5mb3JtYXQobmFtZSkpCgogICAgICAgIG1pc3NpbmdfZnVuY3MgPSBzZWxmLmZpbmRfbWlzc2luZ19yZXF1aXJlZF9mdW5jdGlvbl9jYWxscygpCiAgICAgICAgZm9yIG5hbWUgaW4gbWlzc2luZ19mdW5jczoKICAgICAgICAgICAgZXJyb3JzLmFwcGVuZCgiWW91IGZvcmdvdCB0byB1c2UgdGhlIHJlcXVpcmVkIGZ1bmN0aW9uICd7fScuIi5mb3JtYXQobmFtZSkpCgogICAgICAgIG1pc3NpbmdfZnVuY3MgPSBzZWxmLmZpbmRfbWlzc2luZ19yZXF1aXJlZF9mdW5jdGlvbl9kZWZpbml0aW9ucygpCiAgICAgICAgZm9yIG5hbWUgaW4gbWlzc2luZ19mdW5jczoKICAgICAgICAgICAgZXJyb3JzLmFwcGVuZCgiWW91IGZvcmdvdCB0byBkZWZpbmUgdGhlIHJlcXVpcmVkIGZ1bmN0aW9uICd7fScuIi5mb3JtYXQobmFtZSkpCgogICAgICAgIG1pc3NpbmdfY29uc3RydWN0cyA9IHNlbGYuZmluZF9taXNzaW5nX3JlcXVpcmVkX2NvbnN0cnVjdHMoKQogICAgICAgIGZvciByZXFkIGluIG1pc3NpbmdfY29uc3RydWN0czoKICAgICAgICAgICAgZXhwYW5kZWQgPSBzZWxmLnByZXR0aWVkKHJlcWQpCiAgICAgICAgICAgIGVycm9ycy5hcHBlbmQoZiJZb3VyIHByb2dyYW0gbXVzdCBpbmNsdWRlIGF0IGxlYXN0IG9uZSB7ZXhwYW5kZWR9LiIpCgogICAgICAgIGJhZF9jb25zdHJ1Y3RzID0gc2VsZi5maW5kX2lsbGVnYWxfY29uc3RydWN0cygpCiAgICAgICAgZm9yIG5vdGFsbG93ZWQgaW4gYmFkX2NvbnN0cnVjdHM6CiAgICAgICAgICAgIGV4cGFuZGVkID0gc2VsZi5wcmV0dGllZChub3RhbGxvd2VkKQogICAgICAgICAgICBlcnJvcnMuYXBwZW5kKGYiWW91ciBwcm9ncmFtIG11c3Qgbm90IGluY2x1ZGUgYW55IHtleHBhbmRlZH1zLiIpCgogICAgICAgIG51bV9jb25zdGFudHMgPSBsZW4oW2xpbmUgZm9yIGxpbmUgaW4gc2VsZi5zdHVkZW50X2Fuc3dlci5zcGxpdCgnXG4nKSBpZiByZS5tYXRjaCgnICpbQS1aX11bQS1aXzAtOV0qICo9JywgbGluZSldKQogICAgICAgIGlmIG51bV9jb25zdGFudHMgPiBzZWxmLnBhcmFtc1snbWF4bnVtY29uc3RhbnRzJ106CiAgICAgICAgICAgIGVycm9ycy5hcHBlbmQoIllvdSBtYXkgbm90IHVzZSBtb3JlIHRoYW4gIiArIHN0cihzZWxmLnBhcmFtc1snbWF4bnVtY29uc3RhbnRzJ10pICsgIiBjb25zdGFudHMuIikKCiAgICAgICAgIyAobWN0NjMpIENoZWNrIGlmIGFueXRoaW5nIHJlc3RyaWN0ZWQgaXMgYmVpbmcgaW1wb3J0ZWQuCiAgICAgICAgaWYgJ3Jlc3RyaWN0ZWRtb2R1bGVzJyBpbiBzZWxmLnBhcmFtczoKICAgICAgICAgICAgcmVzdHJpY3RlZCA9IHNlbGYucGFyYW1zWydyZXN0cmljdGVkbW9kdWxlcyddCiAgICAgICAgICAgIGZvciBpbXBvcnRfbmFtZSwgbmFtZXMgaW4gc2VsZi5maW5kX2FsbF9pbXBvcnRzKCkuaXRlbXMoKToKICAgICAgICAgICAgICAgIGlmIGltcG9ydF9uYW1lIGluIHJlc3RyaWN0ZWQ6CiAgICAgICAgICAgICAgICAgICAgaWYgcmVzdHJpY3RlZFtpbXBvcnRfbmFtZV0uZ2V0KCdvbmx5YWxsb3cnLCBOb25lKSA9PSBbXToKICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLmFwcGVuZCgiWW91ciBwcm9ncmFtIHNob3VsZCBub3QgaW1wb3J0IGFueXRoaW5nIGZyb20gJ3t9Jy4iLmZvcm1hdChpbXBvcnRfbmFtZSkpCiAgICAgICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICAgICAgZm9yIG5hbWUgaW4gbmFtZXM6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKCdvbmx5YWxsb3cnIGluIHJlc3RyaWN0ZWRbaW1wb3J0X25hbWVdIGFuZCBuYW1lIG5vdCBpbiByZXN0cmljdGVkW2ltcG9ydF9uYW1lXVsnb25seWFsbG93J10pIG9yCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgaW4gcmVzdHJpY3RlZFtpbXBvcnRfbmFtZV0uZ2V0KCdkaXNhbGxvdycsIFtdKSk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLmFwcGVuZCgiWW91ciBwcm9ncmFtIHNob3VsZCBub3QgaW1wb3J0ICd7fScgZnJvbSAne30nLiIuZm9ybWF0KG5hbWUsIGltcG9ydF9uYW1lKSkKCiAgICAgICAgcmV0dXJuIGVycm9ycwoKICAgIGRlZiBmaW5kX2FsbF9pbXBvcnRzKHNlbGYpOgogICAgICAgICIiIlJldHVybnMgYSBkaWN0aW9uYXJ5IG1hcHBpbmcgaW4gd2hpY2ggdGhlIGtleXMgYXJlIGFsbCBtb2R1bGVzCiAgICAgICAgICAgYmVpbmcgaW1wb3J0ZWQgYW5kIHRoZSB2YWx1ZXMgYXJlIGEgbGlzdCBvZiB3aGF0IHRoaW5ncyB3aXRoaW4KICAgICAgICAgICB0aGUgbW9kdWxlIGFyZSBiZWluZyBtb2R1bGVzLiBBbiBlbXB0eSBsaXN0IGluZGljYXRlcyB0aGUgZW50aXJlCiAgICAgICAgICAgbW9kdWxlIGlzIGltcG9ydGVkLiIiIgogICAgICAgIGZvdW5kX2ltcG9ydHMgPSB7fQogICAgICAgIGNsYXNzIEltcG9ydEZpbmRlcihhc3QuTm9kZVZpc2l0b3IpOgogICAgICAgICAgICBkZWYgdmlzaXRfSW1wb3J0KHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgZm9yIGFsaWFzIGluIG5vZGUubmFtZXM6CiAgICAgICAgICAgICAgICAgICAgaWYgYWxpYXMubmFtZSBub3QgaW4gZm91bmRfaW1wb3J0czoKICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRfaW1wb3J0c1thbGlhcy5uYW1lXSA9IFtdCiAgICAgICAgICAgICAgICBzZWxmLmdlbmVyaWNfdmlzaXQobm9kZSkKICAgICAgICAgICAgZGVmIHZpc2l0X0ltcG9ydEZyb20oc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBpZiBub2RlLm1vZHVsZSBub3QgaW4gZm91bmRfaW1wb3J0czoKICAgICAgICAgICAgICAgICAgICBmb3VuZF9pbXBvcnRzW25vZGUubW9kdWxlXSA9IFtdCiAgICAgICAgICAgICAgICBmb3IgYWxpYXMgaW4gbm9kZS5uYW1lczoKICAgICAgICAgICAgICAgICAgICBmb3VuZF9pbXBvcnRzW25vZGUubW9kdWxlXS5hcHBlbmQoYWxpYXMubmFtZSkKICAgICAgICAgICAgICAgIHNlbGYuZ2VuZXJpY192aXNpdChub2RlKQoKICAgICAgICB2aXNpdG9yID0gSW1wb3J0RmluZGVyKCkKICAgICAgICB2aXNpdG9yLnZpc2l0KHNlbGYudHJlZSkKICAgICAgICByZXR1cm4gZm91bmRfaW1wb3J0cwoKICAgIGRlZiBmaW5kX2FsbF9mdW5jdGlvbl9jYWxscyhzZWxmKToKICAgICAgICAiIiJSZXR1cm4gYSBkaWN0aW9uYXJ5IG1hcHBpbmcgaW4gd2hpY2ggdGhlIGtleXMgYXJlIGFsbCBmdW5jdGlvbnMKICAgICAgICAgICBjYWxsZWQgYnkgdGhlIHNvdXJjZSBjb2RlIGFuZCB2YWx1ZXMgYXJlIGEgbGlzdCBvZgogICAgICAgICAgIChsaW5lX251bWJlciwgbmVzdGluZ19kZXB0aCkgdHVwbGVzLiIiIgogICAgICAgIGNsYXNzIEZ1bmNGaW5kZXIoYXN0Lk5vZGVWaXNpdG9yKToKCiAgICAgICAgICAgIGRlZiBfX2luaXRfXyhzZWxmLCAqYXJncywgKiprd2FyZ3MpOgogICAgICAgICAgICAgICAgc2VsZi5kZXB0aCA9IDAKICAgICAgICAgICAgICAgIHNlbGYuZm91bmRfZnVuY3MgPSBkZWZhdWx0ZGljdChsaXN0KQogICAgICAgICAgICAgICAgc3VwZXIoKS5fX2luaXRfXygqYXJncywgKiprd2FyZ3MpCgogICAgICAgICAgICBkZWYgdmlzaXRfRnVuY3Rpb25EZWYoc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICAiIiIgRXZlcnkgdGltZSB3ZSBlbnRlciBhIGZ1bmN0aW9uLCB3ZSBnZXQgJ2RlZXBlcicgaW50byB0aGUgY29kZS4KICAgICAgICAgICAgICAgICAgICBXZSB3YW50IHRvIG5vdGUgaG93IGRlZXAgYSBmdW5jdGlvbiBpcyB3aGVuIHdlIGZpbmQgaXRzIGNhbGwuIiIiCiAgICAgICAgICAgICAgICBzZWxmLmRlcHRoICs9IDEKICAgICAgICAgICAgICAgIHNlbGYuZ2VuZXJpY192aXNpdChub2RlKQogICAgICAgICAgICAgICAgc2VsZi5kZXB0aCAtPSAxCgogICAgICAgICAgICBkZWYgdmlzaXRfQ2FsbChzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgICIiIkEgZnVuY3Rpb24gaGFzIGJlZW4gY2FsbGVkLCBzbyBjaGVjayBpdHMgbmFtZQogICAgICAgICAgICAgICAgICAgYWdhaW5zdCB0aGUgZ2l2ZW4gb25lLiIiIgogICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgIGlmICdpZCcgaW4gZGlyKG5vZGUuZnVuYyk6CiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBub2RlLmZ1bmMuaWQKICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gbm9kZS5mdW5jLmF0dHIKICAgICAgICAgICAgICAgICAgICAjIExpbmUgbnVtYmVycyBhcmUgMS1pbmRleGVkLCBzbyBkZWNyZW1lbnQgYnkgMQogICAgICAgICAgICAgICAgICAgIHNlbGYuZm91bmRfZnVuY3NbbmFtZV0uYXBwZW5kKChub2RlLmxpbmVubyAtIDEsIHNlbGYuZGVwdGgpKQogICAgICAgICAgICAgICAgZXhjZXB0IEF0dHJpYnV0ZUVycm9yOgogICAgICAgICAgICAgICAgICAgIHBhc3MgICMgZWl0aGVyIG5vdCBjYWxsaW5nIGEgZnVuY3Rpb24gKD8/KSBvciBpdCdzIG5vdCBuYW1lZC4KICAgICAgICAgICAgICAgIHNlbGYuZ2VuZXJpY192aXNpdChub2RlKQoKICAgICAgICBpZiBzZWxmLmZ1bmN0aW9uX2NhbGxfbWFwIGlzIE5vbmU6CiAgICAgICAgICAgIHZpc2l0b3IgPSBGdW5jRmluZGVyKCkKICAgICAgICAgICAgdmlzaXRvci52aXNpdChzZWxmLnRyZWUpCiAgICAgICAgICAgIHNlbGYuZnVuY3Rpb25fY2FsbF9tYXAgPSB2aXNpdG9yLmZvdW5kX2Z1bmNzCiAgICAgICAgcmV0dXJuIHNlbGYuZnVuY3Rpb25fY2FsbF9tYXAKCgogICAgZGVmIGZpbmRfZGVmaW5lZF9mdW5jdGlvbnMoc2VsZik6CiAgICAgICAgIiIiRmluZCBhbGwgdGhlIGZ1bmN0aW9ucyBkZWZpbmVkLiIiIgogICAgICAgIGRlZmluZWQgPSBzZXQoKQogICAgICAgIGNsYXNzIEZ1bmNGaW5kZXIoYXN0Lk5vZGVWaXNpdG9yKToKCiAgICAgICAgICAgIGRlZiBfX2luaXRfXyhzZWxmKToKICAgICAgICAgICAgICAgIHNlbGYucHJlZml4ID0gJycKCiAgICAgICAgICAgIGRlZiB2aXNpdF9DbGFzc0RlZihzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIG9sZF9wcmVmaXggPSBzZWxmLnByZWZpeAogICAgICAgICAgICAgICAgc2VsZi5wcmVmaXggKz0gbm9kZS5uYW1lICsgJy4nCiAgICAgICAgICAgICAgICBzZWxmLmdlbmVyaWNfdmlzaXQobm9kZSkKICAgICAgICAgICAgICAgIHNlbGYucHJlZml4ID0gb2xkX3ByZWZpeAoKICAgICAgICAgICAgZGVmIHZpc2l0X0Z1bmN0aW9uRGVmKHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgZGVmaW5lZC5hZGQoc2VsZi5wcmVmaXggKyBub2RlLm5hbWUpCiAgICAgICAgICAgICAgICBvbGRfcHJlZml4ID0gc2VsZi5wcmVmaXgKICAgICAgICAgICAgICAgIHNlbGYucHJlZml4ICs9IG5vZGUubmFtZSArICcuJwogICAgICAgICAgICAgICAgc2VsZi5nZW5lcmljX3Zpc2l0KG5vZGUpCiAgICAgICAgICAgICAgICBzZWxmLnByZWZpeCA9IG9sZF9wcmVmaXgKCiAgICAgICAgICAgIGRlZiB2aXNpdF9Bc3luY0Z1bmN0aW9uRGVmKHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgc2VsZi52aXNpdF9GdW5jdGlvbkRlZihub2RlKQoKICAgICAgICB2aXNpdG9yID0gRnVuY0ZpbmRlcigpCiAgICAgICAgdmlzaXRvci52aXNpdChzZWxmLnRyZWUpCiAgICAgICAgcmV0dXJuIGRlZmluZWQKCgogICAgZGVmIGNvbnN0cnVjdHNfdXNlZChzZWxmKToKICAgICAgICAiIiJSZXR1cm4gYSBzZXQgb2YgYWxsIGNvbnN0cnVjdHMgZW5jb3VudGVyZWQgaW4gdGhlIHBhcnNlIHRyZWUiIiIKICAgICAgICBjb25zdHJ1Y3RzX3NlZW4gPSBzZXQoKQogICAgICAgIGNsYXNzIENvbnN0cnVjdEZpbmRlcihhc3QuTm9kZVZpc2l0b3IpOgogICAgICAgICAgICBkZWYgdmlzaXRfQXNzZXJ0KHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgY29uc3RydWN0c19zZWVuLmFkZCgnYXNzZXJ0JykKICAgICAgICAgICAgICAgIHNlbGYuZ2VuZXJpY192aXNpdChub2RlKQogICAgICAgICAgICBkZWYgdmlzaXRfUmFpc2Uoc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RzX3NlZW4uYWRkKCdyYWlzZScpCiAgICAgICAgICAgICAgICBzZWxmLmdlbmVyaWNfdmlzaXQobm9kZSkKICAgICAgICAgICAgZGVmIHZpc2l0X0xhbWJkYShzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGNvbnN0cnVjdHNfc2Vlbi5hZGQoJ2xhbWJkYScpCiAgICAgICAgICAgICAgICBzZWxmLmdlbmVyaWNfdmlzaXQobm9kZSkKICAgICAgICAgICAgZGVmIHZpc2l0X0ltcG9ydChzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGNvbnN0cnVjdHNfc2Vlbi5hZGQoJ2ltcG9ydCcpCiAgICAgICAgICAgICAgICBzZWxmLmdlbmVyaWNfdmlzaXQobm9kZSkKICAgICAgICAgICAgZGVmIHZpc2l0X0ltcG9ydEZyb20oc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RzX3NlZW4uYWRkKCdpbXBvcnQnKQogICAgICAgICAgICAgICAgc2VsZi5nZW5lcmljX3Zpc2l0KG5vZGUpCiAgICAgICAgICAgIGRlZiB2aXNpdF9Gb3Ioc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RzX3NlZW4uYWRkKCdmb3InKQogICAgICAgICAgICAgICAgc2VsZi5nZW5lcmljX3Zpc2l0KG5vZGUpCiAgICAgICAgICAgIGRlZiB2aXNpdF9XaGlsZShzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGNvbnN0cnVjdHNfc2Vlbi5hZGQoJ3doaWxlJykKICAgICAgICAgICAgICAgIHNlbGYuZ2VuZXJpY192aXNpdChub2RlKQogICAgICAgICAgICBkZWYgdmlzaXRfQ29tcHJlaGVuc2lvbihzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGNvbnN0cnVjdHNfc2Vlbi5hZGQoJ2NvbXByZWhlbnNpb24nKQogICAgICAgICAgICAgICAgc2VsZi5nZW5lcmljX3Zpc2l0KG5vZGUpCiAgICAgICAgICAgIGRlZiB2aXNpdF9MaXN0Q29tcChzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGNvbnN0cnVjdHNfc2Vlbi5hZGQoJ2xpc3Rjb21wcmVoZW5zaW9uJykKICAgICAgICAgICAgICAgIHNlbGYuZ2VuZXJpY192aXNpdChub2RlKQogICAgICAgICAgICBkZWYgdmlzaXRfU2V0Q29tcChzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGNvbnN0cnVjdHNfc2Vlbi5hZGQoJ3NldGNvbXByZWhlbnNpb24nKQogICAgICAgICAgICAgICAgc2VsZi5nZW5lcmljX3Zpc2l0KG5vZGUpCiAgICAgICAgICAgIGRlZiB2aXNpdF9EaWN0Q29tcChzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGNvbnN0cnVjdHNfc2Vlbi5hZGQoJ2RpY3Rjb21wcmVoZW5zaW9uJykKICAgICAgICAgICAgICAgIHNlbGYuZ2VuZXJpY192aXNpdChub2RlKQogICAgICAgICAgICBkZWYgdmlzaXRfU2xpY2Uoc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RzX3NlZW4uYWRkKCdzbGljZScpCiAgICAgICAgICAgIGRlZiB2aXNpdF9JZihzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGNvbnN0cnVjdHNfc2Vlbi5hZGQoJ2lmJykKICAgICAgICAgICAgICAgIHNlbGYuZ2VuZXJpY192aXNpdChub2RlKQogICAgICAgICAgICBkZWYgdmlzaXRfQnJlYWsoc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RzX3NlZW4uYWRkKCdicmVhaycpCiAgICAgICAgICAgICAgICBzZWxmLmdlbmVyaWNfdmlzaXQobm9kZSkKICAgICAgICAgICAgZGVmIHZpc2l0X0NvbnRpbnVlKHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgY29uc3RydWN0c19zZWVuLmFkZCgnY29udGludWUnKQogICAgICAgICAgICAgICAgc2VsZi5nZW5lcmljX3Zpc2l0KG5vZGUpCiAgICAgICAgICAgIGRlZiB2aXNpdF9Ucnkoc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RzX3NlZW4uYWRkKCd0cnknKQogICAgICAgICAgICAgICAgc2VsZi5nZW5lcmljX3Zpc2l0KG5vZGUpCiAgICAgICAgICAgIGRlZiB2aXNpdF9UcnlFeGNlcHQoc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RzX3NlZW4uYWRkKCd0cnknKQogICAgICAgICAgICAgICAgY29uc3RydWN0c19zZWVuLmFkZCgnZXhjZXB0JykKICAgICAgICAgICAgICAgIHNlbGYuZ2VuZXJpY192aXNpdChub2RlKQogICAgICAgICAgICBkZWYgdmlzaXRfVHJ5RmluYWxseShzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGNvbnN0cnVjdHNfc2Vlbi5hZGQoJ3RyeScpCiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RzX3NlZW4uYWRkKCdmaW5hbGx5JykKICAgICAgICAgICAgICAgIHNlbGYuZ2VuZXJpY192aXNpdChub2RlKQogICAgICAgICAgICBkZWYgdmlzaXRfRXhjZXB0SGFuZGxlcihzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGNvbnN0cnVjdHNfc2Vlbi5hZGQoJ2V4Y2VwdCcpCiAgICAgICAgICAgICAgICBzZWxmLmdlbmVyaWNfdmlzaXQobm9kZSkKICAgICAgICAgICAgZGVmIHZpc2l0X1dpdGgoc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RzX3NlZW4uYWRkKCd3aXRoJykKICAgICAgICAgICAgICAgIHNlbGYuZ2VuZXJpY192aXNpdChub2RlKQogICAgICAgICAgICBkZWYgdmlzaXRfWWllbGQoc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RzX3NlZW4uYWRkKCd5aWVsZCcpCiAgICAgICAgICAgICAgICBzZWxmLmdlbmVyaWNfdmlzaXQobm9kZSkKICAgICAgICAgICAgZGVmIHZpc2l0X1lpZWxkRnJvbShzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGNvbnN0cnVjdHNfc2Vlbi5hZGQoJ3lpZWxkJykKICAgICAgICAgICAgICAgIHNlbGYuZ2VuZXJpY192aXNpdChub2RlKQogICAgICAgICAgICBkZWYgdmlzaXRfUmV0dXJuKHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgY29uc3RydWN0c19zZWVuLmFkZCgncmV0dXJuJykKICAgICAgICAgICAgICAgIHNlbGYuZ2VuZXJpY192aXNpdChub2RlKQoKICAgICAgICB2aXNpdG9yID0gQ29uc3RydWN0RmluZGVyKCkKICAgICAgICB2aXNpdG9yLnZpc2l0KHNlbGYudHJlZSkKICAgICAgICByZXR1cm4gY29uc3RydWN0c19zZWVuCgogICAgZGVmIGNoZWNrX3R5cGVfaGludHMoc2VsZik6CiAgICAgICAgIiIiUmV0dXJuIGEgbGlzdCBvZiB0aGUgbmFtZXMgb2YgZnVuY3Rpb25zIHRoYXQgZG9uJ3QgaGF2ZSBmdWxsIHR5cGUgaGludGluZy4iIiIKICAgICAgICB1bmhpbnRlZCA9IFtdCiAgICAgICAgY2xhc3MgTXlWaXNpdG9yKGFzdC5Ob2RlVmlzaXRvcik6CiAgICAgICAgICAgIGRlZiB2aXNpdF9GdW5jdGlvbkRlZihzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGlmIG5vZGUucmV0dXJucyBpcyBOb25lIG9yIGFueShbYXJnLmFubm90YXRpb24gaXMgTm9uZSBmb3IgYXJnIGluIG5vZGUuYXJncy5hcmdzXSk6CiAgICAgICAgICAgICAgICAgICAgdW5oaW50ZWQuYXBwZW5kKG5vZGUubmFtZSkKCiAgICAgICAgdmlzaXRvciA9IE15VmlzaXRvcigpCiAgICAgICAgdHJlZSA9IHNlbGYudHJlZQogICAgICAgIHZpc2l0b3IudmlzaXQoc2VsZi50cmVlKQogICAgICAgIHJldHVybiB1bmhpbnRlZAoKICAgIGRlZiBmaW5kX2Z1bmN0aW9uX2NhbGxzKHNlbGYsIG5hbWUpOgogICAgICAgICIiIkxvb2sgZm9yIG9jY3VyYW5jZXMgb2YgYSBzcGVjaWZpYyBmdW5jdGlvbiBjYWxsIiIiCiAgICAgICAgcmV0dXJuIHNlbGYuZmluZF9hbGxfZnVuY3Rpb25fY2FsbHMoKS5nZXQobmFtZSwgW10pCgoKICAgIGRlZiBmaW5kX2lsbGVnYWxfZnVuY3Rpb25zKHNlbGYpOgogICAgICAgICIiIkZpbmQgYSBzZXQgb2YgYWxsIHRoZSBmdW5jdGlvbnMgdGhhdCB0aGUgc3R1ZGVudCB1c2VzCiAgICAgICAgICAgdGhhdCB0aGV5IGFyZSBub3QgYWxsb3dlZCB0byB1c2UuICIiIgogICAgICAgIGZ1bmNfY2FsbHMgPSBzZWxmLmZpbmRfYWxsX2Z1bmN0aW9uX2NhbGxzKCkKICAgICAgICByZXR1cm4gZnVuY19jYWxscy5rZXlzKCkgJiBzZXQoc2VsZi5wYXJhbXNbJ3Byb3NjcmliZWRmdW5jdGlvbnMnXSkKCgogICAgZGVmIGZpbmRfbWlzc2luZ19yZXF1aXJlZF9mdW5jdGlvbl9jYWxscyhzZWxmKToKICAgICAgICAiIiJGaW5kIGEgc2V0IG9mIHRoZSByZXF1aXJlZCBmdW5jdGlvbnMgdGhhdCB0aGUgc3R1ZGVudCBmYWlscyB0byB1c2UiIiIKICAgICAgICBmdW5jX2NhbGxzID0gc2VsZi5maW5kX2FsbF9mdW5jdGlvbl9jYWxscygpCiAgICAgICAgcmV0dXJuIHNldChzZWxmLnBhcmFtc1sncmVxdWlyZWRmdW5jdGlvbmNhbGxzJ10pIC0gZnVuY19jYWxscy5rZXlzKCkKCgogICAgZGVmIGZpbmRfbWlzc2luZ19yZXF1aXJlZF9mdW5jdGlvbl9kZWZpbml0aW9ucyhzZWxmKToKICAgICAgICAiIiJGaW5kIGEgc2V0IG9mIHJlcXVpcmVkIGZ1bmN0aW9ucyB0aGF0IHRoZSBzdHVkZW50IGZhaWxzIHRvIGRlZmluZSIiIgogICAgICAgIGZ1bmNfZGVmcyA9IHNlbGYuZmluZF9kZWZpbmVkX2Z1bmN0aW9ucygpCiAgICAgICAgcmV0dXJuIHNldChzZWxmLnBhcmFtc1sncmVxdWlyZWRmdW5jdGlvbmRlZmluaXRpb25zJ10pIC0gZnVuY19kZWZzCgoKICAgIGRlZiBmaW5kX2lsbGVnYWxfY29uc3RydWN0cyhzZWxmKToKICAgICAgICAiIiJGaW5kIGFsbCB0aGUgY29uc3RydWN0cyB0aGF0IHdlcmUgdXNlZCBidXQgbm90IGFsbG93ZWQiIiIKICAgICAgICBjb25zdHJ1Y3RzID0gc2VsZi5jb25zdHJ1Y3RzX3VzZWQoKQogICAgICAgIHJldHVybiBjb25zdHJ1Y3RzICYgc2V0KHNlbGYucGFyYW1zWydwcm9zY3JpYmVkY29uc3RydWN0cyddKQoKCiAgICBkZWYgZmluZF9taXNzaW5nX3JlcXVpcmVkX2NvbnN0cnVjdHMoc2VsZik6CiAgICAgICAgIiIiRmluZCB3aGljaCBvZiB0aGUgcmVxdWlyZWQgY29uc3RydWN0cyB3ZXJlIG5vdCB1c2VkIiIiCiAgICAgICAgY29uc3RydWN0cyA9IHNlbGYuY29uc3RydWN0c191c2VkKCkKICAgICAgICByZXR1cm4gc2V0KHNlbGYucGFyYW1zWydyZXF1aXJlZGNvbnN0cnVjdHMnXSkgLSBjb25zdHJ1Y3RzCgoKICAgIGRlZiBmaW5kX3Rvb19sb25nX2Z1bmNzKHNlbGYsIG1heF9sZW5ndGgpOgogICAgICAgICIiIlJldHVybiBhIGxpc3Qgb2YgdGhlIGZ1bmN0aW9ucyB0aGF0IGV4Y2VlZCB0aGUgZ2l2ZW4gbWF4X2xlbmd0aAogICAgICAgICAgIEVhY2ggbGlzdCBlbGVtZW50IGlzIGEgdHVwbGUgb2YgdGhlIGZ1bmN0aW9uIG5hbWUgYW5kIHRoZSBudW1iZXIgb2Ygc3RhdGVtZW50cwogICAgICAgICAgIGluIGl0cyBib2R5LiIiIgoKICAgICAgICBiYWRfZnVuY3MgPSBbXQoKICAgICAgICBjbGFzcyBNeVZpc2l0b3IoYXN0Lk5vZGVWaXNpdG9yKToKCiAgICAgICAgICAgIGRlZiB2aXNpdF9GdW5jdGlvbkRlZihzZWxmLCBub2RlKToKCiAgICAgICAgICAgICAgICBkZWYgY291bnRfc3RhdGVtZW50cyhub2RlKToKICAgICAgICAgICAgICAgICAgICAiIiJOdW1iZXIgb2Ygc3RhdGVtZW50cyBpbiB0aGUgZ2l2ZW4gbm9kZSBhbmQgaXRzIGNoaWxkcmVuIiIiCiAgICAgICAgICAgICAgICAgICAgY291bnQgPSAxCiAgICAgICAgICAgICAgICAgICAgaWYgaXNpbnN0YW5jZShub2RlLCBhc3QuRXhwcikgYW5kIGlzaW5zdGFuY2Uobm9kZS52YWx1ZSwgYXN0LlN0cik6CiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ID0gMAogICAgICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgICAgIGZvciBhdHRyIGluIFsnYm9keScsICdvcmVsc2UnLCAnZmluYWxib2R5J106CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBoYXNhdHRyKG5vZGUsIGF0dHIpOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gbm9kZS5fX2RpY3RfX1thdHRyXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ICs9IHN1bShjb3VudF9zdGF0ZW1lbnRzKGNoaWxkKSBmb3IgY2hpbGQgaW4gY2hpbGRyZW4pCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvdW50CgogICAgICAgICAgICAgICAgbnVtX3N0YXRlbWVudHMgPSBjb3VudF9zdGF0ZW1lbnRzKG5vZGUpIC0gMSAjIERpc3JlZ2FyZCBkZWYgaXRzZWxmCiAgICAgICAgICAgICAgICBpZiBudW1fc3RhdGVtZW50cyA+IG1heF9sZW5ndGg6CiAgICAgICAgICAgICAgICAgICAgYmFkX2Z1bmNzLmFwcGVuZCgobm9kZS5uYW1lLCBudW1fc3RhdGVtZW50cykpCgogICAgICAgICAgICBkZWYgdmlzaXRfQXN5bmNGdW5jdGlvbkRlZihzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIHNlbGYudmlzaXRfRnVuY3Rpb25EZWYobm9kZSkKCiAgICAgICAgdmlzaXRvciA9IE15VmlzaXRvcigpCiAgICAgICAgdmlzaXRvci52aXNpdChzZWxmLnRyZWUpCiAgICAgICAgcmV0dXJuIGJhZF9mdW5jcwoKCiAgICBkZWYgZmluZF9nbG9iYWxfY29kZShzZWxmKToKICAgICAgICAiIiJSZXR1cm4gYSBsaXN0IG9mIGVycm9yIG1lc3NhZ2VzIHJlbGF0aW5nIHRvIHRoZSBleGlzdGVuY2Ugb2YKICAgICAgICAgICBhbnkgZ2xvYmFsIGFzc2lnbm1lbnQsIGZvciwgd2hpbGUgYW5kIGlmIG5vZGVzLiBJZ25vcmVzCiAgICAgICAgICAgZ2xvYmFsIGFzc2lnbm1lbnQgc3RhdGVtZW50cyB3aXRoIGFuIEFMTF9DQVBTIHRhcmdldC4iIiIKCiAgICAgICAgZ2xvYmFsX2Vycm9ycyA9IFtdCiAgICAgICAgY2xhc3MgTXlWaXNpdG9yKGFzdC5Ob2RlVmlzaXRvcik6CiAgICAgICAgICAgIGRlZiB2aXNpdF9Bc3NpZ24oc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBpZiBub2RlLmNvbF9vZmZzZXQgPT0gMDoKICAgICAgICAgICAgICAgICAgICBpZiBsZW4obm9kZS50YXJnZXRzKSA+IDE6CiAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbF9lcnJvcnMuYXBwZW5kKGYiTXVsdGlwbGUgdGFyZ2V0cyBpbiBnbG9iYWwgYXNzaWdubWVudCBzdGF0ZW1lbnQgYXQgbGluZSB7bm9kZS5saW5lbm99IikKICAgICAgICAgICAgICAgICAgICBlbGlmIG5vdCBub2RlLnRhcmdldHNbMF0uaWQuaXN1cHBlcigpOgogICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxfZXJyb3JzLmFwcGVuZChmIkdsb2JhbCBhc3NpZ25tZW50IHN0YXRlbWVudCBhdCBsaW5lIHtub2RlLmxpbmVub30iKQoKICAgICAgICAgICAgZGVmIHZpc2l0X0ZvcihzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGlmIG5vZGUuY29sX29mZnNldCA9PSAwOgogICAgICAgICAgICAgICAgICAgIGdsb2JhbF9lcnJvcnMuYXBwZW5kKGYiR2xvYmFsIGZvciBsb29wIGF0IGxpbmUge25vZGUubGluZW5vfSIpCgogICAgICAgICAgICBkZWYgdmlzaXRfV2hpbGUoc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBpZiBub2RlLmNvbF9vZmZzZXQgPT0gMDoKICAgICAgICAgICAgICAgICAgICBnbG9iYWxfZXJyb3JzLmFwcGVuZChmIkdsb2JhbCB3aGlsZSBsb29wIGF0IGxpbmUge25vZGUubGluZW5vfSIpCgogICAgICAgICAgICBkZWYgdmlzaXRfSWYoc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBpZiBub2RlLmNvbF9vZmZzZXQgPT0gMDoKICAgICAgICAgICAgICAgICAgICBnbG9iYWxfZXJyb3JzLmFwcGVuZChmIkdsb2JhbCBpZiBzdGF0ZW1lbnQgYXQgbGluZSB7bm9kZS5saW5lbm99IikKCiAgICAgICAgdmlzaXRvciA9IE15VmlzaXRvcigpCiAgICAgICAgdmlzaXRvci52aXNpdChzZWxmLnRyZWUpCiAgICAgICAgcmV0dXJuIGdsb2JhbF9lcnJvcnMKCgogICAgZGVmIGZpbmRfbmVzdGVkX2Z1bmN0aW9ucyhzZWxmKToKICAgICAgICAiIiJSZXR1cm4gYSBsaXN0IG9mIGZ1bmN0aW9ucyB0aGF0IGFyZSBkZWNsYXJlZCB3aXRoIG5vbi1nbG9iYWwgc2NvcGUiIiIKICAgICAgICBiYWRfZnVuY3MgPSBbXQoKICAgICAgICBjbGFzcyBNeVZpc2l0b3IoYXN0Lk5vZGVWaXNpdG9yKToKICAgICAgICAgICAgaXNfdmlzaXRpbmdfZnVuYyA9IEZhbHNlCgogICAgICAgICAgICBkZWYgdmlzaXRfRnVuY3Rpb25EZWYoc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBpZiBzZWxmLmlzX3Zpc2l0aW5nX2Z1bmM6CiAgICAgICAgICAgICAgICAgICAgYmFkX2Z1bmNzLmFwcGVuZChub2RlLm5hbWUpCiAgICAgICAgICAgICAgICBzZWxmLmlzX3Zpc2l0aW5nX2Z1bmMgPSBUcnVlCiAgICAgICAgICAgICAgICBzZWxmLmdlbmVyaWNfdmlzaXQobm9kZSkgIyBWaXNpdCBhbGwgY2hpbGRyZW4gcmVjdXJzaXZlbHkKICAgICAgICAgICAgICAgIHNlbGYuaXNfdmlzaXRpbmdfZnVuYyA9IEZhbHNlCgogICAgICAgICAgICBkZWYgdmlzaXRfQXN5bmNGdW5jdGlvbkRlZihzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIHNlbGYudmlzaXRfRnVuY3Rpb25EZWYobm9kZSkKCiAgICAgICAgdmlzaXRvciA9IE15VmlzaXRvcigpCiAgICAgICAgdmlzaXRvci52aXNpdChzZWxmLnRyZWUpCiAgICAgICAgcmV0dXJuIGJhZF9mdW5jcwo=</file>
<file name="__pytask.py" path="/" encoding="base64">IiIiIENvZGUgZm9yIGNvbXBpbGluZyAoTi9BKSBhbmQgcnVubmluZyBhIFB5dGhvbjMgdGFzay4KIiIiCmltcG9ydCBfX2xhbmd1YWdldGFzayBhcyBsYW5ndWFnZXRhc2sKaW1wb3J0IGlvCmltcG9ydCBzeXMKaW1wb3J0IHRyYWNlYmFjawppbXBvcnQgdHlwZXMKZnJvbSBtYXRoIGltcG9ydCBmbG9vcgppbXBvcnQgb3MKaW1wb3J0IHJlCmZyb20gX193YXRjaGRvZyBpbXBvcnQgV2F0Y2hkb2cKClNPVVJDRV9GSUxFTkFNRSA9ICdzdHVkZW50X2Fuc3dlci5weScKREVGQVVMVF9USU1FT1VUID0gMyAjIHNlY3MKREVGQVVMVF9NQVhPVVRQVVRCWVRFUyA9IDEwMDAwMDAgIyAxIE1CCgpjbGFzcyBPdXRPZklucHV0KEV4Y2VwdGlvbik6CiAgICBwYXNzCgojIChtY3QpIE5ldyBleGNlcHRpb24gZm9yIGhhbmRsaW5nIHNpdHVhdGlvbnMgd2hlcmUgc3VibWl0dGVkIGNvZGUgZG9lcyBzb21ldGhpbmcgaXQgc2hvdWxkIG5vdC4KY2xhc3MgSW52YWxpZEFjdGlvbihFeGNlcHRpb24pOgogICAgZGVmIF9faW5pdF9fKHNlbGYsIGVycm9yX21lc3NhZ2U9JycpOgogICAgICAgIEV4Y2VwdGlvbi5fX2luaXRfXyhzZWxmLCBlcnJvcl9tZXNzYWdlKQoKZGVmIG5hbWVfbWF0Y2hlc19yZXMobmFtZSwgcmVfc3RyaW5ncyk6CiAgICByZXR1cm4gYm9vbChyZS5tYXRjaChmIl57JyR8Xicuam9pbihyZV9zdHJpbmdzKX0kIiwgbmFtZSkpCgpjbGFzcyBDb2RlVHJhcChvYmplY3QpOgogICAgIiIiIEEgc2FmZSBsaXR0bGUgY29udGFpbmVyIHRvIGhvbGQgdGhlIHN0dWRlbnQncyBjb2RlIGFuZCBncmFiCiAgICAgICAgaXRzIG91dHB1dCwgd2hpbGUgYWxzbyByZWZvcm1hdHRpbmcgZXhjZXB0aW9ucyB0byBiZSBuaWNlcm1heG91dHB1dAogICAgIiIiCgogICAgZGVmIF9faW5pdF9fKHNlbGYsIHN0dWRlbnRfY29kZSwgcGFyYW1zLCBzZWNvbmRzX3JlbWFpbmluZz1Ob25lKToKICAgICAgICBzZWxmLnBhcmFtcyA9IHBhcmFtcwogICAgICAgIGlmICd0aW1lb3V0JyBub3QgaW4gcGFyYW1zOgogICAgICAgICAgICBzZWxmLnBhcmFtc1sndGltZW91dCddID0gREVGQVVMVF9USU1FT1VUCiAgICAgICAgaWYgJ21heG91dHB1dGJ5dGVzJyBub3QgaW4gcGFyYW1zOgogICAgICAgICAgICBzZWxmLnBhcmFtc1snbWF4b3V0cHV0Ynl0ZXMnXSA9IERFRkFVTFRfTUFYT1VUUFVUCiAgICAgICAgaWYgJ2VjaG9zdGFuZGFyZGlucHV0JyBub3QgaW4gcGFyYW1zOgogICAgICAgICAgICBzZWxmLnBhcmFtc1snZWNob3N0YW5kYXJkaW5wdXQnXSA9IFRydWUKICAgICAgICBzZWxmLnJ1bl9jb2RlID0gc3R1ZGVudF9jb2RlCiAgICAgICAgc2VsZi5zY29wZWRfZ2xvYmFscyA9IHNlbGYuX2dldF9nbG9iYWxzKCkKCiAgICAgICAgaWYgc2Vjb25kc19yZW1haW5pbmcgaXMgTm9uZToKICAgICAgICAgICAgc2VsZi5zZWNvbmRzX3JlbWFpbmluZyA9IHNlbGYucGFyYW1zWyd0aW1lb3V0J10KICAgICAgICBlbHNlOgogICAgICAgICAgICBzZWxmLnNlY29uZHNfcmVtYWluaW5nID0gbWluKHNlY29uZHNfcmVtYWluaW5nLCBzZWxmLnBhcmFtc1sndGltZW91dCddKQoKICAgIGRlZiBfZ2V0X2dsb2JhbHMoc2VsZik6CiAgICAgICAgIiIiIEhlcmUgd2UgZGVmaW5lIGFueSBnbG9iYWxzIHRoYXQgbXVzdCBiZSBhdmFpbGFibGUgIiIiCiAgICAgICAgIyBjaGFuZ2UgdGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgJ29wZW4nLgogICAgICAgIGdsb2JhbCBucCAgIyBNYXkgbm90IGFjdHVhbGx5IGJlIGRlZmluZWQgYnV0IHdlJ2xsIGNoZWNrIHNvb24KICAgICAgICBkZWYgbmV3X29wZW4oZmlsZSwgbW9kZT0ncicsIGJ1ZmZlcmluZz0tMSwKICAgICAgICAgICAgICAgICAgICAgZW5jb2Rpbmc9J3V0Zi04JywgZXJyb3JzPU5vbmUsCiAgICAgICAgICAgICAgICAgICAgIG5ld2xpbmU9Tm9uZSwgY2xvc2VmZD1UcnVlLCBvcGVuZXI9Tm9uZSk6CiAgICAgICAgICAgIAogICAgICAgICAgICAjIChtY3Q2MykgT25seSBvcGVuIGFsbG93ZWQgZmlsZXMuCiAgICAgICAgICAgIGlmICgncmVzdHJpY3RlZGZpbGVzJyBpbiBzZWxmLnBhcmFtcwogICAgICAgICAgICAgICAgICAgIGFuZCAoJ29ubHlhbGxvdycgbm90IGluIHNlbGYucGFyYW1zWydyZXN0cmljdGVkZmlsZXMnXSBvciBuYW1lX21hdGNoZXNfcmVzKGZpbGUsIHNlbGYucGFyYW1zWydyZXN0cmljdGVkZmlsZXMnXVsnb25seWFsbG93J10pKQogICAgICAgICAgICAgICAgICAgIGFuZCBub3QgbmFtZV9tYXRjaGVzX3JlcyhmaWxlLCBzZWxmLnBhcmFtc1sncmVzdHJpY3RlZGZpbGVzJ10uZ2V0KCdkaXNhbGxvdycsIFtdKSkpOgogICAgICAgICAgICAgICAgcmV0dXJuIG9wZW4oZmlsZSwgbW9kZSwgYnVmZmVyaW5nLCBlbmNvZGluZywgZXJyb3JzLCBuZXdsaW5lLCBjbG9zZWZkLCBvcGVuZXIpCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICByYWlzZSBJbnZhbGlkQWN0aW9uKGYiWW91IGFyZSBub3QgYWxsb3dlZCB0byBvcGVuICd7ZmlsZX0nLiIpCiAgICAgICAgICAgICAgICAKICAgICAgICAjIChtY3Q2MykgRnVuY3Rpb24gdGhhdCBjcmVhdGVzIHN0dWIgaW52YWxpZCBmdW5jdGlvbi4KICAgICAgICBkZWYgY3JlYXRlX2ludmFsaWRfZnVuYyhuYW1lKToKICAgICAgICAgICAgZGVmIGludmFsaWRfZnVuYygqYXJncywgKiprd2FyZ3MpOgogICAgICAgICAgICAgICAgcmFpc2UgSW52YWxpZEFjdGlvbihmIllvdSBhcmUgbm90IGFsbG93ZWQgdG8gdXNlICd7bmFtZX0nISIpCiAgICAgICAgICAgIHJldHVybiBpbnZhbGlkX2Z1bmMKICAgICAgICAKICAgICAgICAjIChtY3Q2MykgQ2hlY2tzIHdoYXQgaXMgYmVpbmcgaW1wb3J0ZWQgYW5kIG1ha2VzIHN1cmUgaXQgaXMgYWxsb3dlZC4gSWYgaXQgaXMgbm90LCB0aGUgdGhpbmcgdGhhdCAKICAgICAgICAjIGlzIG5vdCBhbGxvd2VkIGlzIHJlcGxhY2VkIGJ5IGFuICdpbnZhbGlkIGZ1bmN0aW9uJy4gSWYgaXQgaXMgYW4gYXR0cmlidXRlIHRoZW4gaXQgaXMgCiAgICAgICAgIyBub3QgaW5jbHVkZWQgc2luY2UgSSBjb3VsZCBub3QgdGhpbmsgb2YgYSBiZXR0ZXIgdGhpbmcgdG8gZG8uIENvdWxkIGxldCBpdCByYWlzZQogICAgICAgICMgICdBdHRyaWJ1dGVOb3RGb3VuZCcgZXhjZXB0aW9uIGFuZCB0aGVuIGNoZWNrIGlmIHRoaXMgd2FzIGNhdXNlZCBmcm9tIHJlbW92aW5nIHRoZSAKICAgICAgICAjIGF0dHJpYnV0ZSBmcm9tIHRoZSBtb2R1bGUgYnV0IGdpdmVuIGhvdyB1bmxpa2VseSB0aGlzIGlzIGl0cyBub3Qgd29ydGggaXQgYXQgdGhpcyB0aW1lLgogICAgICAgIGRlZiBuZXdfaW1wb3J0KG5hbWUsICphcmdzLCAqKmt3YXJncyk6CiAgICAgICAgICAgIG1vZHVsZSA9IF9faW1wb3J0X18obmFtZSwgKmFyZ3MsICoqa3dhcmdzKQogICAgICAgICAgICByZXN0cmljdGVkX21vZHVsZSA9IG1vZHVsZQogICAgICAgICAgICBpZiAncmVzdHJpY3RlZG1vZHVsZXMnIGluIHNlbGYucGFyYW1zIGFuZCBuYW1lIGluIHNlbGYucGFyYW1zWydyZXN0cmljdGVkbW9kdWxlcyddOgogICAgICAgICAgICAgICAgTmV3TW9kdWxlVHlwZSA9IHR5cGUoJ21vZHVsZScsICh0eXBlcy5Nb2R1bGVUeXBlLCksIHt9KQogICAgICAgICAgICAgICAgcmVzdHJpY3RlZF9tb2R1bGUgPSBOZXdNb2R1bGVUeXBlKG5hbWUpCiAgICAgICAgICAgICAgICBmb3IgdmFyIGluIGRpcihtb2R1bGUpOgogICAgICAgICAgICAgICAgICAgIGlmICgoJ29ubHlhbGxvdycgbm90IGluIHNlbGYucGFyYW1zWydyZXN0cmljdGVkbW9kdWxlcyddW25hbWVdIG9yCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lX21hdGNoZXNfcmVzKHZhciwgc2VsZi5wYXJhbXNbJ3Jlc3RyaWN0ZWRtb2R1bGVzJ11bbmFtZV1bJ29ubHlhbGxvdyddKSkgYW5kCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3QgbmFtZV9tYXRjaGVzX3Jlcyh2YXIsIHNlbGYucGFyYW1zWydyZXN0cmljdGVkbW9kdWxlcyddW25hbWVdLmdldCgnZGlzYWxsb3cnLCBbXSkpKToKICAgICAgICAgICAgICAgICAgICAgICAgc2V0YXR0cihyZXN0cmljdGVkX21vZHVsZSwgdmFyLCBnZXRhdHRyKG1vZHVsZSwgdmFyKSkKICAgICAgICAgICAgICAgICAgICBlbGlmIGNhbGxhYmxlKGdldGF0dHIobW9kdWxlLCB2YXIpKToKICAgICAgICAgICAgICAgICAgICAgICAgc2V0YXR0cihyZXN0cmljdGVkX21vZHVsZSwgdmFyLCBjcmVhdGVfaW52YWxpZF9mdW5jKGYne25hbWV9Lnt2YXJ9JykpCiAgICAgICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0YXR0cihOZXdNb2R1bGVUeXBlLCB2YXIsIHByb3BlcnR5KGNyZWF0ZV9pbnZhbGlkX2Z1bmMoZid7bmFtZX0ue3Zhcn0nKSkpCiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdCBUeXBlRXJyb3I6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIFNvbWUgYXR0cmlidXRlcyBjYW4gbm90IGJlIHNldCB0byBhIHByb3BlcnR5IHNvIHdlIGlnbm9yZSB0aGVtLgogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUKCiAgICAgICAgICAgIHJldHVybiByZXN0cmljdGVkX21vZHVsZQoKICAgICAgICAjIChtY3Q2MykgSW5zdXJlIHByaW50IGFsd2F5cyBwcmludHMgdG8gdGhlIHJlZGlyZWN0ZWQgc3Rkb3V0IGFuZCBub3QgYWN0dWFsIHN0ZG91dC4KICAgICAgICBkZWYgbmV3X3ByaW50KCp2YWx1ZXMsIHNlcD0nICcsIGVuZD0nXG4nLCBmaWxlPU5vbmUsIGZsdXNoPUZhbHNlKToKICAgICAgICAgICAgcmV0dXJuIHByaW50KCp2YWx1ZXMsIHNlcD1zZXAsIGVuZD1lbmQsIGZpbGU9c3lzLnN0ZG91dCkKICAgICAgICAgICAgCiAgICAgICAgIyBmb3JjZSAnaW5wdXQnIHRvIGVjaG8gdG8gc3RkaW4gdG8gc3Rkb3V0CiAgICAgICAgaWYgc2VsZi5wYXJhbXNbJ2VjaG9zdGFuZGFyZGlucHV0J106CiAgICAgICAgICAgIGRlZiBuZXdfaW5wdXQocHJvbXB0PScnKToKICAgICAgICAgICAgICAgICIiIiBSZXBsYWNlIHRoZSBzdGFuZGFyZCBpbnB1dCBwcm9tcHQgd2l0aCBhIGNsZXZlcmVyIG9uZS4gIiIiCiAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgcyA9IGlucHV0KHByb21wdCkKICAgICAgICAgICAgICAgIGV4Y2VwdCBFT0ZFcnJvcjoKICAgICAgICAgICAgICAgICAgICByYWlzZSBPdXRPZklucHV0KCkKICAgICAgICAgICAgICAgIHByaW50KHMpCiAgICAgICAgICAgICAgICByZXR1cm4gcwogICAgICAgIGVsc2U6CiAgICAgICAgICAgIG5ld19pbnB1dCA9IGlucHV0CiAgICAgICAgCiAgICAgICAgIyAobWN0NjMpIENyZWF0ZSBhIG5ldyBidWlsdGlucyBkaWN0aW9uYXJ5LCByZWRmaW5pbmcgYW55IGZ1bmN0aW9ucyB0aGF0IGFyZSBub3QgYWxsb3dlZC4KICAgICAgICBuZXdfYnVpbHRpbnMgPSB7a2V5OnZhbHVlIGZvciBrZXksIHZhbHVlIGluIF9fYnVpbHRpbnNfXy5pdGVtcygpfQogICAgICAgIG5ld19idWlsdGluc1snb3BlbiddID0gbmV3X29wZW4KICAgICAgICBuZXdfYnVpbHRpbnNbJ2lucHV0J10gPSBuZXdfaW5wdXQKICAgICAgICBuZXdfYnVpbHRpbnNbJ3ByaW50J10gPSBuZXdfcHJpbnQKICAgICAgICBuZXdfYnVpbHRpbnNbJ19faW1wb3J0X18nXSA9IG5ld19pbXBvcnQKCiAgICAgICAgaWYgJ3Byb3NjcmliZWRidWlsdGlucycgaW4gc2VsZi5wYXJhbXM6CiAgICAgICAgICAgIGZvciBmdW5jIGluIHNlbGYucGFyYW1zWydwcm9zY3JpYmVkYnVpbHRpbnMnXToKICAgICAgICAgICAgICAgIG5ld19idWlsdGluc1tmdW5jXSA9IGNyZWF0ZV9pbnZhbGlkX2Z1bmMoZnVuYykKCiAgICAgICAgIyBUaGlzIHdvdWxkIGJlIG5pY2UgYnV0IGl0IGNhbiBtZXNzIHdpdGggdGVzdGluZyBjb2RlLgogICAgICAgICMgZm9yIGZ1bmMgaW4gc2VsZi5wYXJhbXNbJ3Byb3NjcmliZWRmdW5jdGlvbnMnXToKICAgICAgICAjICAgICAgICAgbmV3X2J1aWx0aW5zW2Z1bmNdID0gY3JlYXRlX2ludmFsaWRfZnVuYyhmdW5jKQogICAgICAgIAogICAgICAgIGdsb2JhbF9kaWN0ID0gewogICAgICAgICAgICAnX19idWlsdGluc19fJzogbmV3X2J1aWx0aW5zLAogICAgICAgICAgICAnX19uYW1lX18nOiAnX19tYWluX18nCiAgICAgICAgfQogICAgICAgIGlmICd1c2VzbnVtcHknIGluIHNlbGYucGFyYW1zIGFuZCBzZWxmLnBhcmFtc1sndXNlc251bXB5J106CiAgICAgICAgICAgIGltcG9ydCBudW1weSBhcyBucAogICAgICAgICAgICBnbG9iYWxfZGljdFsnbnAnXSA9IG5wCgogICAgICAgIHJldHVybiBnbG9iYWxfZGljdAoKICAgIGRlZiBfX2VudGVyX18oc2VsZik6CiAgICAgICAgaWYgJ01QTENPTkZJR0RJUicgbm90IGluIG9zLmVudmlyb24gb3Igb3MuZW52aXJvblsnTVBMQ09ORklHRElSJ10uc3RhcnRzd2l0aCgnL2hvbWUnKToKICAgICAgICAgICAgaW1wb3J0IHRlbXBmaWxlCiAgICAgICAgICAgIG9zLmVudmlyb25bJ01QTENPTkZJR0RJUiddID0gdGVtcGZpbGUubWtkdGVtcCgpCiAgICAgICAgc2VsZi5vbGRfc3Rkb3V0ID0gc3lzLnN0ZG91dAogICAgICAgIHNlbGYub2xkX3N0ZGVyciA9IHN5cy5zdGRlcnIKICAgICAgICBzZWxmLm9sZF9wYXRoID0gb3MuZW52aXJvblsiUEFUSCJdCiAgICAgICAgc3lzLnN0ZG91dCA9IGlvLlN0cmluZ0lPKCkKICAgICAgICBzeXMuc3RkZXJyID0gaW8uU3RyaW5nSU8oKQogICAgICAgIG9zLmVudmlyb25bIlBBVEgiXSA9ICcnICAgICAjIChtY3Q2MykgR2V0IHJpZCBvZiBQQVRIIHRvIG1ha2UgaXQgaGFyZGVyIHRvIGV4ZWN1dGUgY29tbWFuZHMuCiAgICAgICAgcmV0dXJuIHNlbGYKCiAgICBkZWYgX19leGl0X18oc2VsZiwgKmFyZ3MpOgogICAgICAgIHN5cy5zdGRvdXQgPSBzZWxmLm9sZF9zdGRvdXQKICAgICAgICBzeXMuc3RkZXJyID0gc2VsZi5vbGRfc3RkZXJyCiAgICAgICAgb3MuZW52aXJvblsiUEFUSCJdID0gc2VsZi5vbGRfcGF0aAoKICAgIGRlZiBleGVjKHNlbGYpOgogICAgICAgICIiIiBSdW4gdGhlIGNvZGUuIE91dHB1dCB0byBzdGRvdXQgYW5kIHN0ZGVyciBpcyBzdG9yZWQgYW5kCiAgICAgICAgICAgIHJldHVybmVkIG9uIGEgY2FsbCB0byByZWFkCiAgICAgICAgIiIiCiAgICAgICAgaWYgc2VsZi5zZWNvbmRzX3JlbWFpbmluZyA8PSAxOgogICAgICAgICAgICBwcmludCgiT3V0IG9mIHRpbWUuIEFib3J0ZWQuIiwgZmlsZT1zeXMuc3RkZXJyKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHdpdGggV2F0Y2hkb2coc2VsZi5zZWNvbmRzX3JlbWFpbmluZyk6CiAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgZXhlYyhzZWxmLnJ1bl9jb2RlLCBzZWxmLnNjb3BlZF9nbG9iYWxzKQogICAgICAgICAgICAgICAgZXhjZXB0IE91dE9mSW5wdXQ6CiAgICAgICAgICAgICAgICAgICAgcHJpbnQoIidpbnB1dCcgZnVuY3Rpb24gY2FsbGVkIHdoZW4gbm8gaW5wdXQgZGF0YSBhdmFpbGFibGUuIiwKICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlPXN5cy5zdGRlcnIpCiAgICAgICAgICAgICAgICBleGNlcHQgV2F0Y2hkb2c6CiAgICAgICAgICAgICAgICAgICAgcHJpbnQoIlRpbWUgbGltaXQgZXhjZWVkZWQiLCBmaWxlPXN5cy5zdGRlcnIpCiAgICAgICAgICAgICAgICAjIChtY3Q2MykgQ2F0Y2ggYW55IGludmFsaWQgYWN0aW9ucy4KICAgICAgICAgICAgICAgIGV4Y2VwdCBJbnZhbGlkQWN0aW9uIGFzIGU6CiAgICAgICAgICAgICAgICAgICAgcHJpbnQoZiJJbnZhbGlkIEFjdGlvbjoge2V9IiwgZmlsZT1zeXMuc3RkZXJyKQogICAgICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgICAgICAgICBldHlwZSwgdmFsdWUsIHRiID0gc3lzLmV4Y19pbmZvKCkKICAgICAgICAgICAgICAgICAgICB0Yl90dXBsZXMgPSB0cmFjZWJhY2suZXh0cmFjdF90Yih0YikKICAgICAgICAgICAgICAgICAgICBuZXdfdGIgPSBbXQogICAgICAgICAgICAgICAgICAgIGZvciBmaWxlbmFtZSwgbGluZW51bWJlciwgc2NvcGUsIHRleHQgaW4gdGJfdHVwbGVzOgogICAgICAgICAgICAgICAgICAgICAgICBpZiBmaWxlbmFtZSA9PSAiPHN0cmluZz4iOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld190Yi5hcHBlbmQoKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX19zb3VyY2UucHkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lbnVtYmVyLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5ydW5fY29kZS5zcGxpdGxpbmVzKClbbGluZW51bWJlciAtIDFdLnN0cmlwKCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApKQogICAgICAgICAgICAgICAgICAgIHByaW50KCJUcmFjZWJhY2sgKG1vc3QgcmVjZW50IGNhbGwgbGFzdCk6IiwgZmlsZT1zeXMuc3RkZXJyKQogICAgICAgICAgICAgICAgICAgIHByaW50KCcnLmpvaW4odHJhY2ViYWNrLmZvcm1hdF9saXN0KG5ld190YikpLCBlbmQ9JycsIGZpbGU9c3lzLnN0ZGVycikKICAgICAgICAgICAgICAgICAgICBwcmludCh0cmFjZWJhY2suZm9ybWF0X2V4Y2VwdGlvbl9vbmx5KGV0eXBlLCB2YWx1ZSlbLTFdLCBlbmQ9JycsIGZpbGU9c3lzLnN0ZGVycikKICAgICAgICAgICAgICAgIGV4Y2VwdCBTeXN0ZW1FeGl0OgogICAgICAgICAgICAgICAgICAgIHByaW50KCJVbmV4cGVjdGVkIHRlcm1pbmF0aW9uOiBQbGVhc2UgZG8gbm90IGNhbGwgZXhpdCgpIG9yIHF1aXQoKS4iLAogICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGU9c3lzLnN0ZGVycikKICAgICAgICAgICAgICAgIGV4Y2VwdCBLZXlib2FyZEludGVycnVwdDoKICAgICAgICAgICAgICAgICAgICBwcmludCgiS2V5Ym9hcmRJbnRlcnJ1cHQiLCBmaWxlPXN5cy5zdGRlcnIpCiAgICAgICAgICAgICAgICBleGNlcHQgR2VuZXJhdG9yRXhpdDoKICAgICAgICAgICAgICAgICAgICBwcmludCgiR2VuZXJhdG9yRXhpdCIsIGZpbGU9c3lzLnN0ZGVycikKCiAgICAgICAgICAgICAgICAjIChtY3Q2MykgTWlnaHQgYXMgd2VsbCBjYXRjaCB0aGUgYmFzZSBleGNlcHRpb24gaW4gY2FzZSBzb21ldGhpbmcgdmVyeSBzdHJhbmdlIGhhcHBlbnMuCiAgICAgICAgICAgICAgICAjIEZvciBleGFtcGxlIGludGVudGlvbmFsbHkgcmFpc2VpbmcgdGhlIEJhc2VFeGNlcHRpb24gdG8gdHJ5IGFuZCBza2lwIGFsbCBvZiB0aGlzLiAKICAgICAgICAgICAgICAgIGV4Y2VwdCBCYXNlRXhjZXB0aW9uOgogICAgICAgICAgICAgICAgICAgIHByaW50KCJDYXVnaHQgQmFzZUV4Y2VwdGlvbi4gWW91IGRpZCBzb21ldGhpbmcgdmVyeSBzdHJhbmdlIHRvIGdldCB0aGlzIG1lc3NhZ2UuIiwKICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlPXN5cy5zdGRlcnIpCgoKCiAgICBkZWYgcmVhZChzZWxmKToKICAgICAgICAiIiIgR2V0IHRoZSBvdXRwdXQgYW5kIGVycm9yIGZyb20gdGhlIGV4ZWMKICAgICAgICAiIiIKICAgICAgICBpZiBzeXMuc3Rkb3V0LnRlbGwoKSArIHN5cy5zdGRlcnIudGVsbCgpICA+IHNlbGYucGFyYW1zWydtYXhvdXRwdXRieXRlcyddOgogICAgICAgICAgICByZXR1cm4gKCcnLCAiPT09IEV4Y2Vzc2l2ZSBPdXRwdXQgPT09XG4gICAgSW5maW5pdGUgbG9vcD8iKQogICAgICAgIHJldHVybiBzeXMuc3Rkb3V0LmdldHZhbHVlKCksIHN5cy5zdGRlcnIuZ2V0dmFsdWUoKQoKCmNsYXNzIFB5VGFzayhsYW5ndWFnZXRhc2suTGFuZ3VhZ2VUYXNrKToKICAgICIiIkEgUHlUYXNrIG1hbmFnZXMgY29tcGlsaW5nIChhbG1vc3QgYSBOT1ApIGFuZCBleGVjdXRpbmcgb2YgYSBQeXRob24zIHByb2dyYW0uCiAgICAiIiIKICAgIGRlZiBfX2luaXRfXyhzZWxmLCBwYXJhbXMsIGNvZGU9Tm9uZSk6CiAgICAgICAgIiIiSW5pdGlhbGlzYXRpb24gaXMgZGVsZWdhdGVkIHRvIHRoZSBzdXBlcmNsYXNzLgogICAgICAgICIiIgogICAgICAgIHN1cGVyKCkuX19pbml0X18ocGFyYW1zLCBjb2RlKQogICAgICAgIHNlbGYuZXhlY3V0YWJsZV9idWlsdCA9IEZhbHNlCgogICAgZGVmIGNvbXBpbGUoc2VsZiwgbWFrZV9leGVjdXRhYmxlPUZhbHNlKToKICAgICAgICAiIiJBIE5vLW9wIGZvciBQeXRob24uCiAgICAgICAgIiIiCiAgICAgICAgcGFzcwoKICAgIGRlZiBkaXNjYXJkX2V4ZWN1dGFibGUoc2VsZik6CiAgICAgICAgIiIiQSBuby1vcCBmb3IgcHl0aG9uIiIiCiAgICAgICAgcGFzcwoKICAgIGRlZiBydW5fY29kZShzZWxmLCBzdGFuZGFyZF9pbnB1dD1Ob25lKToKICAgICAgICAiIiJSdW4gY29kZSB1c2luZyBBYXJvbidzIENvZGVUcmFwCiAgICAgICAgIiIiCiAgICAgICAgc3lzLnN0ZGluID0gaW8uU3RyaW5nSU8oc3RhbmRhcmRfaW5wdXQpCiAgICAgICAgd2l0aCBDb2RlVHJhcChzZWxmLmNvZGUsIHNlbGYucGFyYW1zLCBmbG9vcihzZWxmLnNlY29uZHNfcmVtYWluaW5nKCkpKSBhcyBydW5uZXI6CiAgICAgICAgICAgIHJ1bm5lci5leGVjKCkKICAgICAgICAgICAgb3V0cHV0LCBlcnJvciA9IHJ1bm5lci5yZWFkKCkKICAgICAgICBzZWxmLnN0ZG91dCwgc2VsZi5zdGRlcnIgPSBvdXRwdXQsIGVycm9yCiAgICAgICAgcmV0dXJuIG91dHB1dCwgZXJyb3IKCg==</file>
<file name="__resulttable.py" path="/" encoding="base64">IiIiQ29kZSBmb3IgYnVpbGRpbmcgYW5kIG1hbmFnaW5nIHRoZSByZXN1bHQgdGFibGUgZm9yIHRoZSB0ZXN0cy4KICAgVGhlIHJlc3VsdCB0YWJsZSBpdHNlbGYgKHRoZSAndGFibGUnIGZpZWxkIG9mIGFuIG9iamVjdCBvZiB0aGlzIGNsYXNzKQogICAgaXMgYSBsaXN0IG9mIGxpc3RzIG9mIHN0cmluZ3MuIFRoZSBmaXJzdCByb3cgaXMgdGhlIGhlYWRlciByb3cuCiAgIENvbHVtbnMgYXJlICJUZXN0IiwgIklucHV0IiAob3B0aW9uYWwpLCAiRXhwZWN0ZWQiLCAiR290IiwgImlzY29ycmVjdCIsICJpc2hpZGRlbiIKIiIiCmltcG9ydCBodG1sCmltcG9ydCByZQpmcm9tIGNvbGxlY3Rpb25zIGltcG9ydCBkZWZhdWx0ZGljdAoKTUFYX1NUUklOR19MRU5HVEggPSA0MDAwICAjIDRrIGlzIGRlZmF1bHQgbWF4aW11bSBzdHJpbmcgbGVuZ3RoCgoKY2xhc3MgUmVzdWx0VGFibGU6CiAgICBkZWYgX19pbml0X18oc2VsZiwgcGFyYW1zKToKICAgICAgICBzZWxmLnBhcmFtcyA9IHBhcmFtcwogICAgICAgIHNlbGYubWFyayA9IDAKICAgICAgICBzZWxmLnRhYmxlID0gTm9uZQogICAgICAgIHNlbGYuZmFpbGVkX2hpZGRlbiA9IEZhbHNlCiAgICAgICAgc2VsZi5hYm9ydGVkID0gRmFsc2UKICAgICAgICBzZWxmLmhhc19zdGRpbnMgPSBGYWxzZQogICAgICAgIHNlbGYuaGFzX3Rlc3RzID0gRmFsc2UKICAgICAgICBzZWxmLmhpZGluZyA9IEZhbHNlCiAgICAgICAgc2VsZi5udW1fZmFpbGVkX3Rlc3RzID0gMAogICAgICAgIHNlbGYubWlzc2luZ190ZXN0cyA9IDAKICAgICAgICBzZWxmLmdsb2JhbF9lcnJvciA9ICcnCiAgICAgICAgc2VsZi5jb2x1bW5fZm9ybWF0cyA9IE5vbmUKICAgICAgICBzZWxmLmltYWdlcyA9IGRlZmF1bHRkaWN0KGxpc3QpCiAgICAgICAgZGVmYXVsdF9wYXJhbXMgPSB7CiAgICAgICAgICAgICdzdGRpbmZyb21leHRyYSc6IEZhbHNlLAogICAgICAgICAgICAnc3RyaWN0d2hpdGVzcGFjZSc6IFRydWUsCiAgICAgICAgICAgICdmbG9hdHRvbGVyYW5jZSc6IE5vbmUsCiAgICAgICAgICAgICdBTExfT1JfTk9USElORyc6IFRydWUKICAgICAgICB9CiAgICAgICAgZm9yIHBhcmFtLCB2YWx1ZSBpbiBkZWZhdWx0X3BhcmFtcy5pdGVtcygpOgogICAgICAgICAgICBpZiBwYXJhbSBub3QgaW4gcGFyYW1zOgogICAgICAgICAgICAgICAgc2VsZi5wYXJhbXNbcGFyYW1dID0gdmFsdWUKCgogICAgZGVmIHNldF9oZWFkZXIoc2VsZiwgdGVzdGNhc2VzKToKICAgICAgICAiIiJHaXZlbiB0aGUgc2V0IG9mIHRlc3RjYXNlcywgc2V0IHRoZSBoZWFkZXIgYXMgdGhlIGZpcnN0IHJvdyBvZiB0aGUgcmVzdWx0IHRhYmxlCiAgICAgICAgICAgYW5kIHNldCBmbGFncyB0byBpbmRpY2F0ZSBwcmVzZW5jZSBvciBhYnNlbmNlCiAgICAgICAgICAgb2YgdmFyaW91cyB0YWJsZSBjb2x1bW5zLgogICAgICAgICIiIgogICAgICAgIGhlYWRlciA9IFsnaXNjb3JyZWN0J10KICAgICAgICBzZWxmLmNvbHVtbl9mb3JtYXRzID0gWyclcyddCiAgICAgICAgaWYgYW55KHRlc3QudGVzdGNvZGUuc3RyaXAoKSAhPSAnJyBmb3IgdGVzdCBpbiB0ZXN0Y2FzZXMpOgogICAgICAgICAgICBoZWFkZXIuYXBwZW5kKCJUZXN0IikKICAgICAgICAgICAgc2VsZi5oYXNfdGVzdHMgPSBUcnVlCiAgICAgICAgICAgICMgSWYgdGhlIHRlc3QgY29kZSBzaG91bGQgYmUgcmVuZGVyZWQgaW4gaHRtbCB0aGVuIHNldCB0aGF0IGFzIGNvbHVtbiBmb3JtYXQuCiAgICAgICAgICAgIGlmIGFueShnZXRhdHRyKHRlc3QsICd0ZXN0X2NvZGVfaHRtbCcsIE5vbmUpIGZvciB0ZXN0IGluIHRlc3RjYXNlcyk6CiAgICAgICAgICAgICAgICBzZWxmLmNvbHVtbl9mb3JtYXRzLmFwcGVuZCgnJWgnKQogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgc2VsZi5jb2x1bW5fZm9ybWF0cy5hcHBlbmQoJyVzJykKCiAgICAgICAgc3RkaW5zID0gW3Rlc3QuZXh0cmEgaWYgc2VsZi5wYXJhbXNbJ3N0ZGluZnJvbWV4dHJhJ10gZWxzZSB0ZXN0LnN0ZGluIGZvciB0ZXN0IGluIHRlc3RjYXNlc10KICAgICAgICBpZiBhbnkoc3RkaW4ucnN0cmlwKCkgIT0gJycgZm9yIHN0ZGluIGluIHN0ZGlucyk6CiAgICAgICAgICAgIGhlYWRlci5hcHBlbmQoJ0lucHV0JykKICAgICAgICAgICAgc2VsZi5jb2x1bW5fZm9ybWF0cy5hcHBlbmQoJyVzJykKICAgICAgICAgICAgc2VsZi5oYXNfc3RkaW5zID0gVHJ1ZQogICAgICAgIGhlYWRlciArPSBbJ0V4cGVjdGVkJywgJ0dvdCcsICdpc2NvcnJlY3QnLCAnaXNoaWRkZW4nXQogICAgICAgIHNlbGYuY29sdW1uX2Zvcm1hdHMgKz0gWyclcycsICclcycsICclcycsICclcyddCiAgICAgICAgc2VsZi50YWJsZSA9IFtoZWFkZXJdCgogICAgZGVmIGltYWdlX2NvbHVtbl9udW1zKHNlbGYpOgogICAgICAgICIiIkEgbGlzdCBvZiB0aGUgbnVtYmVycyBvZiBjb2x1bW5zIGNvbnRhaW5pbmcgaW1hZ2VzIiIiCiAgICAgICAgcmV0dXJuIHNvcnRlZChzZXQoW2tleVswXSBmb3Iga2V5IGluIHNlbGYuaW1hZ2VzLmtleXMoKV0pKQoKICAgIGRlZiBnZXRfY29sdW1uX2Zvcm1hdHMoc2VsZik6CiAgICAgICAgIiIiIEFuIG9yZGVyZWQgbGlzdCBvZiB0aGUgY29sdW1uIGZvcm1hdHMuIENvbHVtbnMgY29udGFpbmluZyBpbWFnZXMgYXJlIGZvcmNlZCBpbnRvICVoIGZvcm1hdC4KICAgICAgICAgICAgRG9uJ3QgaGF2ZSBmb3JtYXRzIGZvciBpc2NvcnJlY3QgYW5kIGlzaGlkZGVuIGNvbHVtbnMuCiAgICAgICAgIiIiCiAgICAgICAgaW1hZ2VfY29sdW1ucyA9IHNlbGYuaW1hZ2VfY29sdW1uX251bXMoKQogICAgICAgIGZvcm1hdHMgPSBbc2VsZi5jb2x1bW5fZm9ybWF0c1tpXSBpZiBpIG5vdCBpbiBpbWFnZV9jb2x1bW5zIGVsc2UgJyVoJyBmb3IgaSBpbiByYW5nZShsZW4oc2VsZi5jb2x1bW5fZm9ybWF0cykpXQogICAgICAgIHJldHVybiBmb3JtYXRzWzE6LTJdCgogICAgZGVmIGdldF90YWJsZShzZWxmKToKICAgICAgICAiIiJSZXR1cm4gdGhlIGN1cnJlbnQgcmVzdWx0IHRhYmxlLCB3aXRoIGltYWdlcyBhZGRlZCB0byBhcHByb3ByaWF0ZSBjZWxscy4KICAgICAgICAgICBDb2x1bW5zIHRoYXQgY29udGFpbiBpbWFnZXMgYW55d2hlcmUgYXJlIGNvbnZlcnRlZCB0byAlaCBmb3JtYXQgYW5kIGV4aXN0aW5nIGNvbnRlbnQgaW4gdGhhdCBjb2x1bW4KICAgICAgICAgICBpcyBodG1sLWVzY2FwZWQsIG5ld2xpbmVzIHJlcGxhY2VkIHdpdGggPGJyPiBhbmQgd3JhcHBlZCBpbiBhIGRpdi4KICAgICAgICAgICAiIiIKICAgICAgICByZXN1bHRfdGFibGUgPSBbcm93WzpdIGZvciByb3cgaW4gc2VsZi50YWJsZV0gICMgQ2xvbmUgdGhlIHJlc3VsdCB0YWJsZQoKICAgICAgICAjIEh0bWxpc2UgYWxsIGNvbHVtbnMgY29udGFpbmluZyBpbWFnZXMKICAgICAgICBmb3IgY29sX251bSBpbiBzZWxmLmltYWdlX2NvbHVtbl9udW1zKCk6CiAgICAgICAgICAgIGZvciByb3dfbnVtIGluIHJhbmdlKDEsIGxlbihyZXN1bHRfdGFibGUpKToKICAgICAgICAgICAgICAgIHJlc3VsdF90YWJsZVtyb3dfbnVtXVtjb2xfbnVtXSA9IHNlbGYuaHRtbGlzZShyZXN1bHRfdGFibGVbcm93X251bV1bY29sX251bV0pCgogICAgICAgICMgQXBwZW5kIGltYWdlcwogICAgICAgIGZvciAoKGNvbCxyb3cpLCBpbWFnZV9saXN0KSBpbiBzZWxmLmltYWdlcy5pdGVtcygpOgogICAgICAgICAgICBmb3IgaW1hZ2UgaW4gaW1hZ2VfbGlzdDoKICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICByZXN1bHRfdGFibGVbcm93XVtjb2xdICs9ICI8YnI+IiArIGltYWdlCiAgICAgICAgICAgICAgICBleGNlcHQgSW5kZXhFcnJvcjoKICAgICAgICAgICAgICAgICAgICBwYXNzICAjIFRlc3RpbmcgbXVzdCBoYXZlIGFib3J0ZWQgc28gZGlzY2FyZCBpbWFnZQoKICAgICAgICByZXR1cm4gcmVzdWx0X3RhYmxlCgogICAgZGVmIHJlc2V0KHNlbGYpOgogICAgICAgIGlmIGxlbihzZWxmLnRhYmxlKSA+IDE6CiAgICAgICAgICAgIGRlbCBzZWxmLnRhYmxlWzE6XQogICAgICAgIHNlbGYuZ2xvYmFsX2Vycm9yID0gJycKICAgICAgICBzZWxmLm51bV9mYWlsZWRfdGVzdHMgPSBzZWxmLm1hcmsgPSAwCiAgICAgICAgc2VsZi5mYWlsZWRfaGlkZGVuID0gc2VsZi5oaWRpbmcgPSBzZWxmLmFib3J0ZWQgPSBGYWxzZQoKICAgIGRlZiB0ZXN0c19taXNzZWQoc2VsZiwgbnVtKToKICAgICAgICAiIiJSZWNvcmQgdGhlIGZhY3QgdGhhdCB3ZSdyZSBtaXNzaW5nIHNvbWUgdGVzdCByZXN1bHRzICh0aW1lb3V0PykiIiIKICAgICAgICBzZWxmLm1pc3NpbmdfdGVzdHMgPSBudW0KCiAgICBkZWYgcmVjb3JkX2dsb2JhbF9lcnJvcihzZWxmLCBlcnJvcl9tZXNzYWdlKToKICAgICAgICAiIiJSZWNvcmQgc29tZSBzb3J0IG9mIGdsb2JhbCBmYWlsdXJlIiIiCiAgICAgICAgc2VsZi5nbG9iYWxfZXJyb3IgPSBlcnJvcl9tZXNzYWdlCgogICAgZGVmIGFkZF9yb3coc2VsZiwgdGVzdGNhc2UsIHJlc3VsdCwgZXJyb3I9JycpOgogICAgICAgICIiIkFkZCBhIHJlc3VsdCByb3cgdG8gdGhlIHRhYmxlIGZvciB0aGUgZ2l2ZW4gdGVzdCBhbmQgcmVzdWx0IiIiCiAgICAgICAgaXNfY29ycmVjdCA9IHNlbGYuY2hlY2tfY29ycmVjdG5lc3MocmVzdWx0ICsgZXJyb3IsIHRlc3RjYXNlLmV4cGVjdGVkKQogICAgICAgIHJvdyA9IFtpc19jb3JyZWN0XQogICAgICAgIGlmIHNlbGYuaGFzX3Rlc3RzOgogICAgICAgICAgICBpZiBnZXRhdHRyKHRlc3RjYXNlLCAndGVzdF9jb2RlX2h0bWwnLCBOb25lKToKICAgICAgICAgICAgICAgIHJvdy5hcHBlbmQodGVzdGNhc2UudGVzdF9jb2RlX2h0bWwpCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICByb3cuYXBwZW5kKHRlc3RjYXNlLnRlc3Rjb2RlKQogICAgICAgIGlmIHNlbGYuaGFzX3N0ZGluczoKICAgICAgICAgICAgcm93LmFwcGVuZCh0ZXN0Y2FzZS5leHRyYSBpZiBzZWxmLnBhcmFtc1snc3RkaW5mcm9tZXh0cmEnXSBlbHNlIHRlc3RjYXNlLnN0ZGluKQogICAgICAgIHJvdy5hcHBlbmQodGVzdGNhc2UuZXhwZWN0ZWQucnN0cmlwKCkpCiAgICAgICAgbWF4X2xlbiA9IHNlbGYucGFyYW1zLmdldCgnbWF4c3RyaW5nbGVuZ3RoJywgTUFYX1NUUklOR19MRU5HVEgpCiAgICAgICAgcmVzdWx0ID0gc2FuaXRpc2UocmVzdWx0LnN0cmlwKCdcbicpLCBtYXhfbGVuKQoKICAgICAgICBpZiBlcnJvcjoKICAgICAgICAgICAgZXJyb3JfbWVzc2FnZSA9ICcqKiogUlVOIFRJTUUgRVJST1IoUykgKioqXG4nICsgc2FuaXRpc2UoZXJyb3IsIG1heF9sZW4pCiAgICAgICAgICAgIGlmIHJlc3VsdDoKICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCArICdcbicgKyBlcnJvcl9tZXNzYWdlCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICByZXN1bHQgPSBlcnJvcl9tZXNzYWdlCiAgICAgICAgcm93LmFwcGVuZChyZXN1bHQpCgogICAgICAgIGlmIGlzX2NvcnJlY3Q6CiAgICAgICAgICAgIHNlbGYubWFyayArPSB0ZXN0Y2FzZS5tYXJrCiAgICAgICAgZWxzZToKICAgICAgICAgICAgc2VsZi5udW1fZmFpbGVkX3Rlc3RzICs9IDEKICAgICAgICByb3cuYXBwZW5kKGlzX2NvcnJlY3QpCiAgICAgICAgZGlzcGxheSA9IHRlc3RjYXNlLmRpc3BsYXkudXBwZXIoKQogICAgICAgIGlzX2hpZGRlbiA9ICgKICAgICAgICAgICAgc2VsZi5oaWRpbmcgb3IKICAgICAgICAgICAgZGlzcGxheSA9PSAnSElERScgb3IKICAgICAgICAgICAgKGRpc3BsYXkgPT0gJ0hJREVfSUZfU1VDQ0VFRCcgYW5kIGlzX2NvcnJlY3QpIG9yCiAgICAgICAgICAgIChkaXNwbGF5ID09ICdISURFX0lGX0ZBSUwnIGFuZCBub3QgaXNfY29ycmVjdCkKICAgICAgICApCiAgICAgICAgcm93LmFwcGVuZChpc19oaWRkZW4pCiAgICAgICAgaWYgbm90IGlzX2NvcnJlY3QgYW5kIGlzX2hpZGRlbjoKICAgICAgICAgICAgc2VsZi5mYWlsZWRfaGlkZGVuID0gVHJ1ZQogICAgICAgIGlmIG5vdCBpc19jb3JyZWN0IGFuZCB0ZXN0Y2FzZS5oaWRlcmVzdGlmZmFpbDoKICAgICAgICAgICAgc2VsZi5oaWRpbmcgPSBUcnVlCiAgICAgICAgc2VsZi50YWJsZS5hcHBlbmQocm93KQogICAgICAgIGlmIGVycm9yOgogICAgICAgICAgICBzZWxmLmFib3J0ZWQgPSBUcnVlCgogICAgZGVmIGdldF9tYXJrKHNlbGYpOgogICAgICAgIHJldHVybiBzZWxmLm1hcmsgaWYgc2VsZi5udW1fZmFpbGVkX3Rlc3RzID09IDAgb3Igbm90IHNlbGYucGFyYW1zWydBTExfT1JfTk9USElORyddIGVsc2UgMAoKICAgIEBzdGF0aWNtZXRob2QKICAgIGRlZiBodG1saXNlKHMpOgogICAgICAgICIiIkNvbnZlcnQgdGhlIGdpdmVuIHN0cmluZyB0byBodG1sIGJ5IGVzY2FwaW5nICc8JyBhbmQgJz4nLgogICAgICAgICAgIFdyYXAgdGhlIHdob2xlIGxvdCBpbiBhIGRpdiB0YWcgc28gdGhlIGRpZmYgY2hlY2tlciBwcm9jZXNzZXMgdGhlIHdob2xlIHRhYmxlIGNlbGwsCiAgICAgICAgICAgYW5kIHdpdGhpbiB0aGF0IGEgcHJlIHRhZyBmb3IgY29ycmVjdCBsYXlsb3V0LgogICAgICAgICIiIgogICAgICAgIHJldHVybiAnPGRpdj48cHJlIGNsYXNzPSJ0YWJsZWNlbGwiPicgKyBodG1sLmVzY2FwZShzKSArICc8L3ByZT48L2Rpdj4nCgogICAgZGVmIGFkZF9pbWFnZShzZWxmLCBpbWFnZV9odG1sLCBjb2x1bW5fbmFtZSwgcm93X251bSk6CiAgICAgICAgIiIiU3RvcmUgdGhlIGdpdmVuIGh0bWxfaW1hZ2UgZm9yIGxhdGVyIGluY2x1c2lvbiBpbiB0aGUgY2VsbCBhdCB0aGUgZ2l2ZW4gcm93IGFuZCBnaXZlbiBjb2x1bW4uCiAgICAgICAgICAgY29sdW1uX25hbWUgaXMgdGhlIG5hbWUgdXNlZCBmb3IgdGhlIGNvbHVtbiBpbiB0aGUgZmlyc3QgKGhlYWRlcikgcm93LgogICAgICAgICAgIHJvd19udW0gaXMgdGhlIHJvdyBudW1iZXIgKDAgb3JpZ2luLCBub3QgaW5jbHVkaW5nIHRoZSBoZWFkZXIgcm93KS4KICAgICAgICAiIiIKICAgICAgICBjb2x1bW5fbnVtID0gc2VsZi50YWJsZVswXS5pbmRleChjb2x1bW5fbmFtZSkKICAgICAgICBzZWxmLmltYWdlc1tjb2x1bW5fbnVtLCByb3dfbnVtICsgMV0uYXBwZW5kKGltYWdlX2h0bWwpCgogICAgZGVmIGVxdWFsX3N0cmluZ3Moc2VsZiwgczEsIHMyKToKICAgICAgICAiIiIgQ29tcGFyZSB0aGUgdHdvIHN0cmluZ3MgczEgYW5kIHMyIChleHBlY3RlZCBhbmQgZ290IHJlc3BlY3RpdmVseSkKICAgICAgICAgICAgZm9yIGVxdWFsaXR5LCB3aXRoIHJlZ2FyZCB0byB0aGUgdGVtcGxhdGUgcGFyYW1ldGVycwogICAgICAgICAgICBzdHJpY3R3aGl0ZXNwYWNlIGFuZCBmbG9hdHRvbGVyYW5jZS4KICAgICAgICAiIiIKICAgICAgICBzMSA9IHMxLnJzdHJpcCgpCiAgICAgICAgczIgPSBzMi5yc3RyaXAoKQogICAgICAgIGlmIG5vdCBzZWxmLnBhcmFtc1snc3RyaWN0d2hpdGVzcGFjZSddOgogICAgICAgICAgICAjIENvbGxhcHNlIHdoaXRlIHNwYWNlIGlmIHN0cmljdCB3aGl0ZXNwYWNlIGlzIG5vdCBlbmZvcmNlZAogICAgICAgICAgICBzMSA9IHJlLnN1YihyJ1xzKycsICcgJywgczEpCiAgICAgICAgICAgIHMyID0gcmUuc3ViKHInXHMrJywgJyAnLCBzMikKICAgICAgICBpZiBzZWxmLnBhcmFtc1snZmxvYXR0b2xlcmFuY2UnXSBpcyBOb25lOgogICAgICAgICAgICByZXR1cm4gczEgPT0gczIKICAgICAgICBlbHNlOgogICAgICAgICAgICAjIE1hdGNoaW5nIHdpdGggYSBmbG9hdGluZyBwb2ludCB0b2xlcmFuY2UuCiAgICAgICAgICAgICMgVXNlIGZsb2F0IHBhdHRlcm4gZnJvbSBNYXJrdXMgU2NobWFzc21hbm4gYXQKICAgICAgICAgICAgIyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMjY0MzAwOS9yZWd1bGFyLWV4cHJlc3Npb24tZm9yLWZsb2F0aW5nLXBvaW50LW51bWJlcnMKICAgICAgICAgICAgIyBleGNlcHQgd2UgZG9uJ3QgbWF0Y2ggaW5mIG9yIG5hbiB3aGljaCBjYW4gYmUgZW1iZWRkZWQgaW4gdGV4dCBzdHJpbmdzLgogICAgICAgICAgICB0b2wgPSBmbG9hdChzZWxmLnBhcmFtc1snZmxvYXR0b2xlcmFuY2UnXSkKICAgICAgICAgICAgZmxvYXRfcGF0ID0gcicoWy0rXT8oPzooPzooPzpbMC05XStbLl0/WzAtOV0qfFsuXVswLTldKykoPzpbZWRdWy0rXT9bMC05XSspPykpKScKICAgICAgICAgICAgczFfYml0cyA9IHJlLnNwbGl0KGZsb2F0X3BhdCwgczEpCiAgICAgICAgICAgIHMyX2JpdHMgPSByZS5zcGxpdChmbG9hdF9wYXQsIHMyKQogICAgICAgICAgICBpZiBsZW4oczFfYml0cykgIT0gbGVuKHMyX2JpdHMpOgogICAgICAgICAgICAgICAgcmV0dXJuIEZhbHNlCiAgICAgICAgICAgIG1hdGNoID0gVHJ1ZQogICAgICAgICAgICBmb3IgYml0MSwgYml0MiBpbiB6aXAoczFfYml0cywgczJfYml0cyk6CiAgICAgICAgICAgICAgICBiaXQxID0gYml0MS5zdHJpcCgpCiAgICAgICAgICAgICAgICBiaXQyID0gYml0Mi5zdHJpcCgpCiAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgZjEgPSBmbG9hdChiaXQxKQogICAgICAgICAgICAgICAgICAgIGYyID0gZmxvYXQoYml0MikKICAgICAgICAgICAgICAgICAgICBpZiBhYnMoZjEgLSBmMikgPiB0b2wgKiAxLjAwMTogIyBBbGxvdyB0b2xlcmFuY2Ugb24gdGhlIGZsb2F0IHRvbGVyYW5jZSEKICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBGYWxzZQogICAgICAgICAgICAgICAgZXhjZXB0IFZhbHVlRXJyb3I6CiAgICAgICAgICAgICAgICAgICAgaWYgYml0MSAhPSBiaXQyOgogICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IEZhbHNlCiAgICAgICAgICAgIHJldHVybiBtYXRjaAoKICAgIGRlZiBjaGVja19jb3JyZWN0bmVzcyhzZWxmLCBleHBlY3RlZCwgZ290KToKICAgICAgICAiIiJUcnVlIGlmZiBleHBlY3RlZCBtYXRjaGVzIGdvdCB3aXRoIHJlbGF4ZWQgd2hpdGUgc3BhY2UgcmVxdWlyZW1lbnRzLgogICAgICAgICAgIEFkZGl0aW9uYWxseSwgaWYgdGhlIHRlbXBsYXRlIHBhcmFtZXRlciBmbG9hdHRvbGVyYW5jZSBpcyBzZXQgYW5kIGlzCiAgICAgICAgICAgbm9uLXplcm8sIHRoZSB0d28gc3RyaW5ncyB3aWxsIGJlIHNwbGl0IGJ5IGEgZmxvYXRpbmctcG9pbnQgbGl0ZXJhbAogICAgICAgICAgIHBhdHRlcm4gYW5kIHRoZSBmbG9hdGluZy1wb2ludCBiaXRzIHdpbGwgYmUgbWF0Y2hlZCB0byB3aXRoaW4gdGhlCiAgICAgICAgICAgZ2l2ZW4gYWJzb2x1dGUgdG9sZXJhbmNlLgogICAgICAgICIiIgogICAgICAgIGV4cGVjdGVkX2xpbmVzID0gZXhwZWN0ZWQuc3RyaXAoKS5zcGxpdGxpbmVzKCkKICAgICAgICBnb3RfbGluZXMgPSBnb3Quc3RyaXAoKS5zcGxpdGxpbmVzKCkKICAgICAgICBpZiBsZW4oZ290X2xpbmVzKSAhPSBsZW4oZXhwZWN0ZWRfbGluZXMpOgogICAgICAgICAgICByZXR1cm4gRmFsc2UKICAgICAgICBlbHNlOgogICAgICAgICAgICBmb3IgZXhwLCBnb3QgaW4gemlwKGV4cGVjdGVkX2xpbmVzLCBnb3RfbGluZXMpOgogICAgICAgICAgICAgICAgaWYgbm90IHNlbGYuZXF1YWxfc3RyaW5ncyhleHAsIGdvdCk6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZhbHNlCiAgICAgICAgcmV0dXJuIFRydWUKCgpkZWYgc2FuaXRpc2UocywgbWF4X2xlbj1NQVhfU1RSSU5HX0xFTkdUSCk6CiAgICAiIiJSZXBsYWNlIG5vbi1wcmludGluZyBjaGFycyB3aXRoIGVzY2FwZSBzZXF1ZW5jZXMsIHJpZ2h0LXN0cmlwLgogICAgICAgTGltaXQgcyB0byBtYXhfbGVuIGJ5IHNuaXBwaW5nIG91dCBiaXRzIGluIHRoZSBtaWRkbGUuCiAgICAiIiIKICAgIHJlc3VsdCA9ICcnCiAgICBpZiBsZW4ocykgPiBtYXhfbGVuOgogICAgICAgIHMgPSBzWzA6IG1heF9sZW4gLy8gMl0gKyAiXG4qKiogPHNuaXA+ICoqKlxuIiArIHNbLW1heF9sZW4gLy8gMjpdCiAgICBsaW5lcyA9IHMucnN0cmlwKCkuc3BsaXRsaW5lcygpCiAgICBmb3IgbGluZSBpbiBsaW5lczoKICAgICAgICBmb3IgYyBpbiBsaW5lLnJzdHJpcCgpICsgJ1xuJzoKICAgICAgICAgICAgaWYgYyA8ICcgJyBhbmQgYyAhPSAnXG4nOgogICAgICAgICAgICAgICAgaWYgYyA9PSAnXHQnOgogICAgICAgICAgICAgICAgICAgIGMgPSByJ1x0JwogICAgICAgICAgICAgICAgZWxpZiBjID09ICdccic6CiAgICAgICAgICAgICAgICAgICAgYyA9IHInXHInCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIGMgPSByJ1x7OjAzb30nLmZvcm1hdChvcmQoYykpCiAgICAgICAgICAgIHJlc3VsdCArPSBjCiAgICByZXR1cm4gcmVzdWx0LnJzdHJpcCgpCg==</file>
<file name="__tester.py" path="/" encoding="base64">IiIiVGhlIGdlbmVyaWMgKG11bHRpLWxhbmd1YWdlKSBtYWluIHRlc3RpbmcgY2xhc3MgdGhhdCBkb2VzIGFsbCB0aGUgd29yayAtIHRyaWFsIGNvbXBpbGUsIHN0eWxlIGNoZWNrcywKICAgcnVuIGFuZCBncmFkZS4KIiIiCmZyb20gX19yZXN1bHR0YWJsZSBpbXBvcnQgUmVzdWx0VGFibGUKaW1wb3J0IGh0bWwKaW1wb3J0IG9zCmltcG9ydCByZQppbXBvcnQgX19sYW5ndWFnZXRhc2sgYXMgbGFuZ3VhZ2V0YXNrCmltcG9ydCBiYXNlNjQKCgojIFZhbHVlcyBvZiBRVUVTVElPTi5wcmVjaGVjayBmaWVsZApQUkVDSEVDS19ESVNBQkxFRCA9IDAKUFJFQ0hFQ0tfRU1QVFkgPSAxClBSRUNIRUNLX0VYQU1QTEVTID0gMgpQUkVDSEVDS19TRUxFQ1RFRCA9IDMKUFJFQ0hFQ0tfQUxMID0gNAoKIyBWYWx1ZXMgb2YgdGVzdHR5cGUKVFlQRV9OT1JNQUwgPSAwClRZUEVfUFJFQ0hFQ0tPTkxZID0gMQpUWVBFX0JPVEggPSAyCgojIEdsb2JhbCBtZXNzYWdlIGZvciB3aGVuIGEgdGVzdC1zdWl0ZSB0aW1lb3V0IG9jY3VycwpUSU1FT1VUX01FU1NBR0UgPSAiIiJBIHRpbWVvdXQgb2NjdXJyZWQgd2hlbiBydW5uaW5nIHRoZSB3aG9sZSB0ZXN0IHN1aXRlIGFzIGEgc2luZ2xlIHByb2dyYW0uClRoaXMgaXMgdXN1YWxseSBkdWUgdG8gYW4gZW5kbGVzcyBsb29wIGluIHlvdXIgY29kZSBidXQgY2FuIGFsc28gYXJpc2UgaWYgeW91ciBjb2RlIGlzIHZlcnkgaW5lZmZpY2llbnQKYW5kIHRoZSBhY2N1bXVsYXRlZCB0aW1lIG92ZXIgYWxsIHRlc3RzIGlzIGV4Y2Vzc2l2ZS4gUGxlYXNlIGFzayBhIHR1dG9yIG9yIHlvdXIgbGVjdHVyZXIgaWYgeW91IG5lZWQgaGVscAp3aXRoIG1ha2luZyB5b3VyIHByb2dyYW0gbW9yZSBlZmZpY2llbnQuIiIiCgoKZGVmIGdldF9qcGVnX2I2NChmaWxlbmFtZSk6CiAgICAiIiJSZXR1cm4gdGhlIGNvbnRlbnRzIG9mIHRoZSBnaXZlbiBmaWxlIChhc3N1bWVkIHRvIGJlIGpwZWcpIGFzIGEgYmFzZTY0CiAgICAgICBlbmNvZGVkIHN0cmluZyBpbiB1dGYtOC4KICAgICIiIgogICAgd2l0aCBvcGVuKGZpbGVuYW1lLCAnYnInKSBhcyBmaW46CiAgICAgICAgY29udGVudHMgPSBmaW4ucmVhZCgpCgogICAgcmV0dXJuIGJhc2U2NC5iNjRlbmNvZGUoY29udGVudHMpLmRlY29kZSgndXRmOCcpCgoKY2xhc3MgVGVzdGVyOgogICAgZGVmIF9faW5pdF9fKHNlbGYsIHBhcmFtcywgdGVzdGNhc2VzKToKICAgICAgICAiIiJJbml0aWFsaXNlIHRoZSBpbnN0YW5jZSwgZ2l2ZW4gdGhlIHRlc3Qgb2YgdGVtcGxhdGUgYW5kIGdsb2JhbCBwYXJhbWV0ZXJzIHBsdXMKICAgICAgICAgICBhbGwgdGhlIHRlc3RjYXNlcy4gUGFyYW1ldGVycyByZXF1aXJlZCBieSB0aGlzIGJhc2UgY2xhc3MgYW5kIGFsbCBzdWJjbGFzc2VzIGFyZToKICAgICAgICAgICAgICAgJ1NUVURFTlRfQU5TV0VSJzogY29kZSBzdWJtaXR0ZWQgYnkgdGhlIHN0dWRlbnQKICAgICAgICAgICAgICAgJ1NFUEFSQVRPUic6IHRoZSBzdHJpbmcgdG8gYmUgdXNlZCB0byBzZXBhcmF0ZSB0ZXN0cyBpbiB0aGUgb3V0cHV0CiAgICAgICAgICAgICAgICdBTExfT1JfTk9USElORzogdHJ1ZSBpZiBncmFkaW5nIGlzIGFsbC1vci1ub3RoaW5nCiAgICAgICAgICAgICAgICdzdGRpbmZyb21leHRyYSc6IHRydWUgaWYgdGhlIHRlc3QtY2FzZSAnZXh0cmEnIGZpZWxkIGlzIHRvIGJlIHVzZWQgZm9yCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YW5kYXJkIGlucHV0IHJhdGhlciB0aGFuIHRoZSB1c3VhbCBzdGRpbiBmaWVsZAogICAgICAgICAgICAgICAncnVudGVzdHNzaW5nbHknOiB0cnVlIHRvIGZvcmNlIGEgc2VwYXJhdGUgcnVuIGZvciBlYWNoIHRlc3QgY2FzZQogICAgICAgICAgICAgICAnc3RkaW5mcm9tZXh0cmEnOiB0cnVlIGlmIHRoZSBleHRyYSBmaWVsZCBpcyB1c2VkIGZvciBzdGFuZGFyZCBpbnB1dCAobGVnYWN5IHVzZSBvbmx5KQogICAgICAgICAgICAgICAndGVzdGlzYmFzaCc6IHRydWUgaWYgdGVzdHMgYXJlIGJhc2ggY29tbWFuZCBsaW5lKHMpIHJhdGhlciB0aGFuIHRoZSBkZWZhdWx0IGRpcmVjdCBleGVjdXRpb24KICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiB0aGUgY29tcGlsZWQgcHJvZ3JhbS4gVGhpcyBjYW4gYmUgdXNlZCB0byBzdXBwbHkgY29tbWFuZCBsaW5lIGFyZ3VtZW50cy4KCiAgICAgICAgIiIiCiAgICAgICAgc2VsZi5zdHVkZW50X2Fuc3dlciA9IHNlbGYuY2xlYW4ocGFyYW1zWydTVFVERU5UX0FOU1dFUiddKQogICAgICAgIHNlbGYuc2VwYXJhdG9yID0gcGFyYW1zWydTRVBBUkFUT1InXQogICAgICAgIHNlbGYuYWxsX29yX25vdGhpbmcgPSBwYXJhbXNbJ0FMTF9PUl9OT1RISU5HJ10KICAgICAgICBzZWxmLnBhcmFtcyA9IHBhcmFtcwogICAgICAgIHNlbGYudGVzdGNhc2VzID0gc2VsZi5maWx0ZXJfdGVzdHModGVzdGNhc2VzKQogICAgICAgIHNlbGYucmVzdWx0X3RhYmxlID0gUmVzdWx0VGFibGUocGFyYW1zKQogICAgICAgIHNlbGYucmVzdWx0X3RhYmxlLnNldF9oZWFkZXIoc2VsZi50ZXN0Y2FzZXMpCgogICAgICAgICMgSXQgaXMgYXNzdW1lZCB0aGF0IGluIGdlbmVyYWwgc3ViY2xhc3NlcyB3aWxsIHByZWZpeCBzdHVkZW50IGNvZGUgYnkgYSBwcmVsdWRlIGFuZAogICAgICAgICMgcG9zdGZpeCBpdCBieSBhIHBvc3RsdWRlLgogICAgICAgIHNlbGYucHJlbHVkZSA9ICcnCiAgICAgICAgc2VsZi5wcmVsdWRlX2xlbmd0aCA9IDAKICAgICAgICBzZWxmLnBvc3RsdWRlID0gJycKCiAgICAgICAgc2VsZi50YXNrID0gTm9uZSAgIyBTVUJDTEFTUyBNVVNUIERFRklORSBUSElTCgogICAgZGVmIGZpbHRlcl90ZXN0cyhzZWxmLCB0ZXN0Y2FzZXMpOgogICAgICAgICIiIlJldHVybiB0aGUgcmVsZXZhbnQgc3Vic2V0IG9mIHRoZSBxdWVzdGlvbidzIHRlc3RjYXNlcy4KICAgICAgICAgICBUaGlzIHdpbGwgYmUgYWxsIHRlc3RjYXNlcyBub3QgbWFya2VkIHByZWNoZWNrLW9ubHkgaWYgaXQncyBub3QgYSBwcmVjaGVjayBvciBhbGwgdGVzdGNhc2VzIGlmIGl0IGlzIGEKICAgICAgICAgICBwcmVjaGVjayBhbmQgdGhlIHF1ZXN0aW9uIHByZWNoZWNrIGlzIHNldCB0byAiQWxsIiwgb3IgdGhlIGFwcHJvcHJpYXRlIHN1YnNldCBpbiBhbGwgb3RoZXIgY2FzZXMuCiAgICAgICAgIiIiCiAgICAgICAgaWYgbm90IHNlbGYucGFyYW1zWydJU19QUkVDSEVDSyddOgogICAgICAgICAgICByZXR1cm4gW3Rlc3QgZm9yIHRlc3QgaW4gdGVzdGNhc2VzIGlmIHRlc3QudGVzdHR5cGUgIT0gVFlQRV9QUkVDSEVDS09OTFldCiAgICAgICAgZWxpZiBzZWxmLnBhcmFtc1snUVVFU1RJT05fUFJFQ0hFQ0snXSA9PSBQUkVDSEVDS19BTEw6CiAgICAgICAgICAgIHJldHVybiB0ZXN0Y2FzZXMKICAgICAgICBlbGlmIHNlbGYucGFyYW1zWydRVUVTVElPTl9QUkVDSEVDSyddID09IFBSRUNIRUNLX0VNUFRZOgogICAgICAgICAgICByZXR1cm4gW10KICAgICAgICBlbGlmIHNlbGYucGFyYW1zWydRVUVTVElPTl9QUkVDSEVDSyddID09IFBSRUNIRUNLX0VYQU1QTEVTOgogICAgICAgICAgICByZXR1cm4gW3Rlc3QgZm9yIHRlc3QgaW4gdGVzdGNhc2VzIGlmIHRlc3QudXNlYXNleGFtcGxlXQogICAgICAgIGVsaWYgc2VsZi5wYXJhbXNbJ1FVRVNUSU9OX1BSRUNIRUNLJ10gPT0gUFJFQ0hFQ0tfU0VMRUNURUQ6CiAgICAgICAgICAgIHJldHVybiBbdGVzdCBmb3IgdGVzdCBpbiB0ZXN0Y2FzZXMgaWYgdGVzdC50ZXN0dHlwZSBpbiBbVFlQRV9QUkVDSEVDS09OTFksIFRZUEVfQk9USF1dCgogICAgZGVmIHN0eWxlX2Vycm9ycyhzZWxmKToKICAgICAgICAiIiJSZXR1cm4gYSBsaXN0IG9mIGFsbCB0aGUgc3R5bGUgZXJyb3JzLiBJbXBsZW1lbnRhdGlvbiBpcyBsYW5ndWFnZSBkZXBlbmRlbnQuCiAgICAgICAgICAgRGVmYXVsdCBpcyBubyBzdHlsZSBjaGVja2luZy4KICAgICAgICAiIiIKICAgICAgICByZXR1cm4gW10KCiAgICBkZWYgc2luZ2xlX3Byb2dyYW1fYnVpbGRfcG9zc2libGUoc2VsZik6CiAgICAgICAgIiIiUmV0dXJuIHRydWUgaWYgYW5kIG9ubHkgaWYgdGhlIGN1cnJlbnQgY29uZmlndXJhdGlvbiBwZXJtaXRzIGEgc2luZ2xlIHByb2dyYW0gdG8gYmUKICAgICAgICAgICBidWlsdCBhbmQgdHJpZWQgY29udGFpbmluZyBhbGwgdGVzdHMuIEl0IHNob3VsZCBiZSB0cnVlIGZvciB3cml0ZS1hLXByb2dyYW0gcXVlc3Rpb25zIGFuZAogICAgICAgICAgIGNvbmRpdGlvbmFsbHkgdHJ1ZSBmb3Igb3RoZXIgdHlwZXMgb2YgcXVlc3Rpb25zIHRoYXQgYWxsb3cgYSAiY29tYmluYXRvciIgYXBwcm9hY2gsCiAgICAgICAgICAgZGVwZW5kZW50IG9uIHRoZSBwcmVzZW5jZSBvZiBzdGRpbnMgaW4gdGVzdHMgYW5kIG90aGVyIHN1Y2ggY29uZGl0aW9ucy4KICAgICAgICAiIiIKICAgICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKCJUZXN0ZXIgbXVzdCBoYXZlIGEgc2luZ2xlX3Byb2dyYW1fYnVpbGRfcG9zc2libGUgbWV0aG9kIikKCiAgICBkZWYgYWRqdXN0X2Vycm9yX2xpbmVfbnVtcyhzZWxmLCBlcnJvcik6CiAgICAgICAgIiIiR2l2ZW4gYSBydW50aW1lIGVycm9yIG1lc3NhZ2UsIGFkanVzdCBpdCBhcyBtYXkgYmUgcmVxdWlyZWQgYnkgdGhlCiAgICAgICAgICAgbGFuZ3VhZ2UsIGUuZy4gYWRqdXN0aW5nIGxpbmUgbnVtYmVycwogICAgICAgICIiIgogICAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoIlRlc3RlciBtdXN0IGhhdmUgYW4gYWRqdXN0X2Vycm9yX2xpbmVfbnVtcyBtZXRob2QiKQoKICAgIGRlZiBzaW5nbGVfcnVuX3Bvc3NpYmxlKHNlbGYpOgogICAgICAgICIiIlJldHVybiB0cnVlIGlmIGEgc2luZ2xlIHByb2dyYW0gaGFzIGJlZW4gYnVpbHQgYW5kIGl0IGlzIHBvc3NpYmxlIHRvIHVzZSB0aGF0IGluIGEgc2luZ2xlIHJ1bgogICAgICAgICAgIHdpdGggYWxsIHRlc3RzLgogICAgICAgICIiIgogICAgICAgIHJldHVybiAoc2VsZi50YXNrLmV4ZWN1dGFibGVfYnVpbHQKICAgICAgICAgICAgICAgIGFuZCBub3Qgc2VsZi5wYXJhbXNbJ3J1bnRlc3Rzc2luZ2x5J10KICAgICAgICAgICAgICAgIGFuZCBub3Qgc2VsZi5yZXN1bHRfdGFibGUuaGFzX3N0ZGlucwogICAgICAgICAgICAgICAgYW5kIG5vdCBzZWxmLnBhcmFtc1sndGVzdGlzYmFzaCddKQoKICAgIGRlZiBtYWtlX3Rlc3RfcG9zdGx1ZGUoc2VsZiwgdGVzdGNhc2VzKToKICAgICAgICAiIiJSZXR1cm4gdGhlIHBvc3RsdWRlIHRlc3RpbmcgY29kZSBjb250YWluaW5nIGFsbCB0aGUgdGVzdGNvZGUgZnJvbQogICAgICAgICAgIHRoZSBnaXZlbiBsaXN0IG9mIHRlc3RjYXNlcyAod2hpY2ggbWF5IGJlIHRoZSBmdWxsIHNldCBvciBhIHNpbmdsZXRvbiBsaXN0KS4KICAgICAgICAgICBBIHNlcGFyYXRvciBtdXN0IGJlIHByaW50ZWQgYmV0d2VlbiB0ZXN0Y2FzZSBvdXRwdXRzLiIiIgogICAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoIlRlc3RlciBtdXN0IGhhdmUgYSBtYWtlX3Rlc3RfcG9zdGx1ZGUgbWV0aG9kIikKCiAgICBkZWYgdHJpYWxfY29tcGlsZShzZWxmKToKICAgICAgICAiIiJUaGlzIGZ1bmN0aW9uIGlzIHRoZSBmaXJzdCBjaGVjayBvbiB0aGUgc3ludGFjdGljIGNvcnJlY3RuZXNzIG9mIHRoZSBzdWJtaXR0ZWQgY29kZS4KICAgICAgICAgICBJdCBpcyBjYWxsZWQgYmVmb3JlIGFueSBzdHlsZSBjaGVja3MgYXJlIGRvbmUuIEZvciBjb21waWxlZCBsYW5ndWFnZXMgaXQgc2hvdWxkIGdlbmVyYWxseQogICAgICAgICAgIGNhbGwgdGhlIHN0YW5kYXJkIGxhbmd1YWdlIGNvbXBpbGVyIG9uIHRoZSBzdHVkZW50IHN1Ym1pdHRlZCBjb2RlIHdpdGggYW55IHJlcXVpcmVkIHByZWx1ZGUKICAgICAgICAgICBhZGRlZCBhbmQsIGlmIHBvc3NpYmxlLCBhbGwgdGVzdHMgaW5jbHVkZWQuIENvbXBpbGVFcnJvciBzaG91bGQgYmUgcmFpc2VkIGlmIHRoZSBjb21waWxlIGZhaWxzLAogICAgICAgICAgIHdoaWNoIHdpbGwgYWJvcnQgYWxsIGZ1cnRoZXIgdGVzdGluZy4KICAgICAgICAgICBJZiBwb3NzaWJsZSBhIGNvbXBsZXRlIHJlYWR5LXRvLXJ1biBleGVjdXRhYmxlIHNob3VsZCBiZSBidWlsdCBhcyB3ZWxsOyBpZiB0aGlzIHN1Y2NlZWRzLCB0aGUKICAgICAgICAgICBMYW5ndWFnZVRhc2tzICdleGVjdXRhYmxlX2J1aWx0JyBhdHRyaWJ1dGUgc2hvdWxkIGJlIHNldC4gVGhpcyBzaG91bGQgYmUgcG9zc2libGUgZm9yIHdyaXRlLWEtcHJvZ3JhbQogICAgICAgICAgIHF1ZXN0aW9ucyBvciBmb3Igd3JpdGUtYS1mdW5jdGlvbiBxdWVzdGlvbnMgd2hlbiB0aGVyZSBpcyBubyBzdGRpbiBkYXRhIGluIGFueSBvZiB0aGUgdGVzdHMuCgogICAgICAgICAgIEludGVycHJldGVkIGxhbmd1YWdlcyBzaG91bGQgcGVyZm9ybSB3aGF0IHN5bnRheCBjaGVja3MgYXJlIHBvc3NpYmxlIHVzaW5nIHRoZSBzdGFuZGFyZCBsYW5ndWFnZSB0b29scy4KICAgICAgICAgICBJZiB0aG9zZSBjaGVja3Mgc3VjY2VlZGVkLCB0aGV5IHNob3VsZCBhbHNvIGF0dGVtcHQgdG8gY29uc3RydWN0IGEgc291cmNlIHByb2dyYW0gdGhhdCBpbmNvcnBvcmF0ZXMgYWxsCiAgICAgICAgICAgdGhlIGRpZmZlcmVudCB0ZXN0cyAodGhlIG9sZCAiY29tYmluYXRvciIgYXBwcm9hY2gpIGFuZCBlbnN1cmUgdGhlIHRhc2sncyAnZXhlY3V0YWJsZV9idWlsdCcgYXR0cmlidXRlCiAgICAgICAgICAgaXMgVHJ1ZS4KCiAgICAgICAgICAgVGhlIGZvbGxvd2luZyBpbXBsZW1lbnRhdGlvbiBpcyBzdWZmaWNpZW50IGZvciBzdGFuZGFyZCBjb21waWxlZCBsYW5ndWFnZXMgbGlrZSBDLCBDKyssIEphdmEuIEl0CiAgICAgICAgICAgbWF5IG5lZWQgb3ZlcnJpZGluZyBmb3Igb3RoZXIgbGFuZ3VhZ2VzLgogICAgICAgICIiIgogICAgICAgIGlmIHNlbGYuc2luZ2xlX3Byb2dyYW1fYnVpbGRfcG9zc2libGUoKToKICAgICAgICAgICAgc2VsZi5zZXR1cF9mb3JfdGVzdF9ydW5zKHNlbGYudGVzdGNhc2VzKQogICAgICAgICAgICBtYWtlX2V4ZWN1dGFibGUgPSBUcnVlCiAgICAgICAgZWxzZToKICAgICAgICAgICAgc2VsZi5wb3N0bHVkZSA9ICcnCiAgICAgICAgICAgIHNlbGYudGFzay5zZXRfY29kZShzZWxmLnByZWx1ZGUgKyBzZWxmLnN0dWRlbnRfYW5zd2VyLCBzZWxmLnByZWx1ZGVfbGVuZ3RoKQogICAgICAgICAgICBtYWtlX2V4ZWN1dGFibGUgPSBGYWxzZQoKICAgICAgICBzZWxmLnRhc2suY29tcGlsZShtYWtlX2V4ZWN1dGFibGUpICAjIENvdWxkIHJhaXNlIENvbXBpbGVFcnJvcgoKICAgIGRlZiBzZXR1cF9mb3JfdGVzdF9ydW5zKHNlbGYsIHRlc3RzKToKICAgICAgICAiIiJTZXQgdGhlIGNvZGUgYW5kIHByZWx1ZGUgbGVuZ3RoIGFzIGFwcHJvcHJpYXRlIGZvciBhIHJ1biB3aXRoIGFsbCB0aGUgZ2l2ZW4gdGVzdHMuIE1heSBiZSBjYWxsZWQgd2l0aAogICAgICAgICAgIGp1c3QgYSBzaW5nbGV0b24gbGlzdCBmb3IgdGVzdHMgaWYgc2luZ2xlX3Byb2dyYW1fYnVpbGRfcG9zc2libGUgaGFzIHJldHVybmVkIGZhbHNlIG9yIGlmIHRlc3Rpbmcgd2l0aAogICAgICAgICAgIG11bHRpcGxlIHRlc3RzIGhhcyBnaXZlbiBleGNlcHRpb25zLgogICAgICAgICAgIFRoaXMgaW1wbGVtZW50YXRpb24gbWF5IG5lZWQgdG8gYmUgb3ZlcnJpZGRlbiwgZS5nLiBpZiB0aGUgc3R1ZGVudCBjb2RlIHNob3VsZCBmb2xsb3cgdGhlIHRlc3QgY29kZSwgYXMKICAgICAgICAgICBzYXkgaW4gTWF0bGFiIHNjcmlwdHMuCiAgICAgICAgIiIiCiAgICAgICAgc2VsZi5wb3N0bHVkZSA9IHNlbGYubWFrZV90ZXN0X3Bvc3RsdWRlKHRlc3RzKQogICAgICAgIHNlbGYudGFzay5zZXRfY29kZShzZWxmLnByZWx1ZGUgKyBzZWxmLnN0dWRlbnRfYW5zd2VyICsgc2VsZi5wb3N0bHVkZSwgc2VsZi5wcmVsdWRlX2xlbmd0aCkKCiAgICBkZWYgcnVuX2FsbF90ZXN0cyhzZWxmKToKICAgICAgICAiIiJSdW4gYWxsIHRoZSB0ZXN0cywgbGVhdmluZyBzZWxmLlJlc3VsdFRhYmxlIG9iamVjdCBjb250YWluaW5nIGFsbCB0ZXN0IHJlc3VsdHMuCiAgICAgICAgICAgQ2FuIHJhaXNlIENvbXBpbGVFcnJvciBvciBSdW5FcnJvciBpZiB0aGluZ3MgYnJlYWsuCiAgICAgICAgICAgSWYgYW55IHJ1bnRpbWUgZXJyb3JzIG9jY3VyIG9uIHRoZSBmdWxsIHRlc3QsIGRyb3AgYmFjayB0byBydW5uaW5nIHRlc3RzIHNpbmdseS4KICAgICAgICAiIiIKICAgICAgICBkb25lID0gRmFsc2UKICAgICAgICBpZiBzZWxmLnNpbmdsZV9ydW5fcG9zc2libGUoKToKICAgICAgICAgICAgIyBXZSBoYXZlIGFuIGV4ZWN1dGFibGUgcmVhZHkgdG8gZ28sIHdpdGggbm8gc3RkaW5zIG9yIG90aGVyIHNob3cgc3RvcHBlcnMKICAgICAgICAgICAgb3V0cHV0LCBlcnJvciA9IHNlbGYudGFzay5ydW5fY29kZSgpCiAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5yc3RyaXAoKSArICdcbicKICAgICAgICAgICAgZXJyb3IgPSBlcnJvci5zdHJpcCgpICsgJ1xuJwoKICAgICAgICAgICAgIyBHZW5lcmF0ZSBhIHJlc3VsdCB0YWJsZSB1c2luZyBhbGwgYXZhaWxhYmxlIHRlc3QgZGF0YS4KICAgICAgICAgICAgcmVzdWx0cyA9IG91dHB1dC5zcGxpdChzZWxmLnNlcGFyYXRvciArICdcbicpCiAgICAgICAgICAgIGVycm9ycyA9IGVycm9yLnNwbGl0KHNlbGYuc2VwYXJhdG9yICsgJ1xuJykKICAgICAgICAgICAgaWYgbGVuKHJlc3VsdHMpID09IGxlbihlcnJvcnMpOgogICAgICAgICAgICAgICAgbWVyZ2VkX3Jlc3VsdHMgPSBbXQogICAgICAgICAgICAgICAgZm9yIHJlc3VsdCwgZXJyb3IgaW4gemlwKHJlc3VsdHMsIGVycm9ycyk6CiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJzdHJpcCgpICsgJ1xuJwogICAgICAgICAgICAgICAgICAgIGlmIGVycm9yLnN0cmlwKCk6CiAgICAgICAgICAgICAgICAgICAgICAgIGFkanVzdGVkX2Vycm9yID0gc2VsZi5hZGp1c3RfZXJyb3JfbGluZV9udW1zKGVycm9yLnJzdHJpcCgpKQogICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xuKioqIFJVTiBFUlJPUiAqKipcbicgKyBhZGp1c3RlZF9lcnJvcgogICAgICAgICAgICAgICAgICAgIG1lcmdlZF9yZXN1bHRzLmFwcGVuZChyZXN1bHQpCgogICAgICAgICAgICAgICAgbWlzc2VkX3Rlc3RzID0gbGVuKHNlbGYudGVzdGNhc2VzKSAtIGxlbihtZXJnZWRfcmVzdWx0cykKCiAgICAgICAgICAgICAgICBmb3IgdGVzdCwgb3V0cHV0IGluIHppcChzZWxmLnRlc3RjYXNlcywgbWVyZ2VkX3Jlc3VsdHMpOgogICAgICAgICAgICAgICAgICAgIHNlbGYucmVzdWx0X3RhYmxlLmFkZF9yb3codGVzdCwgb3V0cHV0KQoKICAgICAgICAgICAgICAgIHNlbGYucmVzdWx0X3RhYmxlLnRlc3RzX21pc3NlZChtaXNzZWRfdGVzdHMpCiAgICAgICAgICAgICAgICBpZiBzZWxmLnRhc2sudGltZWRfb3V0OgogICAgICAgICAgICAgICAgICAgIHNlbGYucmVzdWx0X3RhYmxlLnJlY29yZF9nbG9iYWxfZXJyb3IoVElNRU9VVF9NRVNTQUdFKQogICAgICAgICAgICAgICAgZG9uZSA9IFRydWUKCiAgICAgICAgICAgIGlmIG5vdCBkb25lOgogICAgICAgICAgICAgICAgIyBTb21ldGhpbmcgYnJva2UuIFdlIHdpbGwgbmVlZCB0byBydW4gZWFjaCB0ZXN0IGNhc2Ugc2VwYXJhdGVseQogICAgICAgICAgICAgICAgc2VsZi50YXNrLmV4ZWN1dGFibGVfYnVpbHQgPSBGYWxzZQogICAgICAgICAgICAgICAgc2VsZi5yZXN1bHRfdGFibGUucmVzZXQoKQoKICAgICAgICBpZiBub3QgZG9uZToKICAgICAgICAgICAgIyBJZiBhIHNpbmdsZSBydW4gaXNuJ3QgYXBwcm9wcmlhdGUsIGRvIGEgc2VwYXJhdGUgcnVuIGZvciBlYWNoIHRlc3QgY2FzZS4KICAgICAgICAgICAgYnVpbGRfZWFjaF90ZXN0ID0gbm90IHNlbGYudGFzay5leGVjdXRhYmxlX2J1aWx0CiAgICAgICAgICAgIGZvciBpX3Rlc3QsIHRlc3QgaW4gZW51bWVyYXRlKHNlbGYudGVzdGNhc2VzKToKICAgICAgICAgICAgICAgIGlmIGJ1aWxkX2VhY2hfdGVzdDoKICAgICAgICAgICAgICAgICAgICBzZWxmLnNldHVwX2Zvcl90ZXN0X3J1bnMoW3Rlc3RdKQogICAgICAgICAgICAgICAgICAgIHNlbGYudGFzay5jb21waWxlKFRydWUpCiAgICAgICAgICAgICAgICBzdGFuZGFyZF9pbnB1dCA9IHRlc3QuZXh0cmEgaWYgc2VsZi5wYXJhbXNbJ3N0ZGluZnJvbWV4dHJhJ10gZWxzZSB0ZXN0LnN0ZGluCiAgICAgICAgICAgICAgICBpZiBzZWxmLnBhcmFtc1sndGVzdGlzYmFzaCddOgogICAgICAgICAgICAgICAgICAgIG91dHB1dCwgZXJyb3IgPSBzZWxmLnRhc2sucnVuX2NvZGUoc3RhbmRhcmRfaW5wdXQsIHRlc3QudGVzdGNvZGUpCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIG91dHB1dCwgZXJyb3IgPSBzZWxmLnRhc2sucnVuX2NvZGUoc3RhbmRhcmRfaW5wdXQpCiAgICAgICAgICAgICAgICBhZGp1c3RlZF9lcnJvciA9IHNlbGYuYWRqdXN0X2Vycm9yX2xpbmVfbnVtcyhlcnJvci5yc3RyaXAoKSkKICAgICAgICAgICAgICAgIHNlbGYucmVzdWx0X3RhYmxlLmFkZF9yb3codGVzdCwgb3V0cHV0LCBhZGp1c3RlZF9lcnJvcikKICAgICAgICAgICAgICAgIGlmIGVycm9yIGFuZCBzZWxmLnBhcmFtc1snYWJvcnRvbmVycm9yJ106CiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZXN1bHRfdGFibGUudGVzdHNfbWlzc2VkKGxlbihzZWxmLnRlc3RjYXNlcykgLSBpX3Rlc3QgLSAxKQogICAgICAgICAgICAgICAgICAgIGJyZWFrCgogICAgZGVmIGNvbXBpbGVfYW5kX3J1bihzZWxmKToKICAgICAgICAiIiJQaGFzZSBvbmUgb2YgdGhlIHRlc3Qgb3BlcmF0aW9uOiBkbyBhIHRyaWFsIGNvbXBpbGUgYW5kIHRoZW4sIGlmIGFsbCBpcyB3ZWxsIGFuZCBpdCdzIG5vdCBhIHByZWNoZWNrLAogICAgICAgICAgIGNvbnRpbnVlIG9uIHRvIHJ1biBhbGwgdGVzdHMuCiAgICAgICAgICAgUmV0dXJuIGEgdHVwbGUgbWFyaywgZXJyb3JzIHdoZXJlIG1hcmsgaXMgYSBmcmFjdGlvbiBpbiAwIC0gMSBhbmQgZXJyb3JzIGlzIGEgbGlzdCBvZiBhbGwgdGhlIGVycm9ycy4KICAgICAgICAgICBzZWxmLnRlc3RfcmVzdWx0cyBjb250YWlucyBhbGwgdGhlIHRlc3QgZGV0YWlscy4KICAgICAgICAiIiIKICAgICAgICBtYXJrID0gMAogICAgICAgIGVycm9ycyA9IFtdCgogICAgICAgICMgRG8gYSB0cmlhbCBjb21waWxlLCB0aGVuIGEgc3R5bGUgY2hlY2suIElmIGFsbCBpcyB3ZWxsLCBydW4gdGhlIGNvZGUKICAgICAgICB0cnk6CiAgICAgICAgICAgIHNlbGYudHJpYWxfY29tcGlsZSgpCgogICAgICAgICAgICBpZiBub3Qgc2VsZi5wYXJhbXNbJ25vc3R5bGVjaGVja3MnXToKICAgICAgICAgICAgICAgIGVycm9ycyA9IHNlbGYuc3R5bGVfZXJyb3JzKCkKICAgICAgICAgICAgaWYgbm90IGVycm9yczoKICAgICAgICAgICAgICAgIGlmIHNlbGYucGFyYW1zWydJU19QUkVDSEVDSyddIGFuZCBzZWxmLnBhcmFtc1snUVVFU1RJT05fUFJFQ0hFQ0snXSA8PSAxOgogICAgICAgICAgICAgICAgICAgIG1hcmsgPSAxCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIHNlbGYucnVuX2FsbF90ZXN0cygpCiAgICAgICAgICAgICAgICAgICAgbWF4X21hcmsgPSBzdW0odGVzdC5tYXJrIGZvciB0ZXN0IGluIHNlbGYudGVzdGNhc2VzKQogICAgICAgICAgICAgICAgICAgIG1hcmsgPSBzZWxmLnJlc3VsdF90YWJsZS5nZXRfbWFyaygpIC8gbWF4X21hcmsgICMgRnJhY3Rpb25hbCBtYXJrIDAgLSAxCiAgICAgICAgZXhjZXB0IGxhbmd1YWdldGFzay5Db21waWxlRXJyb3IgYXMgZXJyOgogICAgICAgICAgICBhZGp1c3RlZF9lcnJvciA9IHNlbGYuYWRqdXN0X2Vycm9yX2xpbmVfbnVtcyhzdHIoZXJyKS5yc3RyaXAoKSkKICAgICAgICAgICAgZXJyb3JzLmFwcGVuZCgiQ09NUElMRSBFUlJPUlxuIiArIGFkanVzdGVkX2Vycm9yKQogICAgICAgIGV4Y2VwdCBsYW5ndWFnZXRhc2suUnVuRXJyb3IgYXMgZXJyOgogICAgICAgICAgICBhZGp1c3RlZF9lcnJvciA9IHNlbGYuYWRqdXN0X2Vycm9yX2xpbmVfbnVtcyhzdHIoZXJyKS5yc3RyaXAoKSkKICAgICAgICAgICAgZXJyb3JzLmFwcGVuZCgnUlVOIEVSUk9SXG4nICsgYWRqdXN0ZWRfZXJyb3IpCiAgICAgICAgcmV0dXJuIG1hcmssIGVycm9ycwoKICAgIGRlZiBwcmVydW5faG9vayhzZWxmKToKICAgICAgICAiIiJBIGhvb2sgZm9yIHN1YmNsYXNzZXMgdG8gZG8gaW5pdGlhbCBzZXR1cCBvciBjb2RlIGhhY2tzIGV0YwogICAgICAgICAgIFJldHVybnMgYSBsaXN0IG9mIGVycm9ycywgdG8gd2hpY2ggb3RoZXIgZXJyb3JzIGFyZSBhcHBlbmRlZAogICAgICAgICIiIgogICAgICAgIHJldHVybiBbXQoKICAgIGRlZiBnZXRfYWxsX2ltYWdlc19odG1sKHNlbGYpOgogICAgICAgICIiIlNlYXJjaCB0aGUgY3VycmVudCBkaXJlY3RvcnkgZm9yIGltYWdlcyBuYW1lZCBfaW1hZ2UuKihFeHBlY3RlZHxHb3QpKFxkKykucG5nLgogICAgICAgICAgIEZvciBlYWNoIHN1Y2ggZmlsZSBjb25zdHJ1Y3QgYW4gaHRtbCBpbWcgZWxlbWVudCB3aXRoIHRoZSBkYXRhIGVuY29kZWQKICAgICAgICAgICBpbiBhIGRhdGF1cmwuCiAgICAgICAgICAgSWYgd2UncmUgcnVubmluZyB0aGUgc2FtcGxlIGFuc3dlciwgYWx3YXlzIHJldHVybiBbXSAtIGltYWdlcyB3aWxsIGJlCiAgICAgICAgICAgcGlja2VkIHVwIHdoZW4gd2UgcnVuIHRoZSBhY3R1YWwgYW5zd2VyLgogICAgICAgICAgIFJldHVybnMgYSBsaXN0IG9mIHR1cGxlcyAoaW1nX2VsZW1lbnRzLCBjb2x1bW5fbmFtZSwgcm93X251bWJlcikgd2hlcmUKICAgICAgICAgICBjb2x1bW5fbmFtZSBpcyBlaXRoZXIgJ0V4cGVjdGVkJyBvciAnR290JywgZGVmaW5pbmcgaW4gd2hpY2ggcmVzdWx0IHRhYmxlCiAgICAgICAgICAgY29sdW1uIHRoZSBpbWFnZSBiZWxvbmdzIGFuZCByb3cgbnVtYmVyIGlzIHRoZSByb3cgKDAtb3JpZ2luLCBleGNsdWRpbmcKICAgICAgICAgICB0aGUgaGVhZGVyIHJvdykuCiAgICAgICAgIiIiCiAgICAgICAgaW1hZ2VzID0gW10KICAgICAgICBpZiBzZWxmLnBhcmFtcy5nZXQoJ3J1bm5pbmdfc2FtcGxlX2Fuc3dlcicsIEZhbHNlKToKICAgICAgICAgICAgcmV0dXJuIFtdCiAgICAgICAgaWYgc2VsZi5wYXJhbXNbJ2ltYWdld2lkdGgnXSBpcyBub3QgTm9uZToKICAgICAgICAgICAgd2lkdGhfc3BlYyA9ICIgd2lkdGg9e30iLmZvcm1hdChzZWxmLnBhcmFtc1snaW1hZ2V3aWR0aCddKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHdpZHRoX3NwZWMgPSAiIgogICAgICAgIGZpbGVzID0gc29ydGVkKG9zLmxpc3RkaXIoJy4nKSkKICAgICAgICBmb3IgZmlsZW5hbWUgaW4gZmlsZXM6CiAgICAgICAgICAgIG1hdGNoID0gcmUubWF0Y2gocidfaW1hZ2VbXi5dKlwuKEV4cGVjdGVkfEdvdClcLihcZCspLnBuZycsIGZpbGVuYW1lKQogICAgICAgICAgICBpZiBtYXRjaDoKICAgICAgICAgICAgICAgIGltYWdlX2RhdGEgPSBnZXRfanBlZ19iNjQoZmlsZW5hbWUpCiAgICAgICAgICAgICAgICBpbWdfdGVtcGxhdGUgPSAnPGltZ3t9IHN0eWxlPSJtYXJnaW46M3B4O2JvcmRlcjoxcHggc29saWQgYmxhY2siIHNyYz0iZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCx7fSI+JwogICAgICAgICAgICAgICAgaW1nX2h0bWwgPSBpbWdfdGVtcGxhdGUuZm9ybWF0KHdpZHRoX3NwZWMsIGltYWdlX2RhdGEpCiAgICAgICAgICAgICAgICBjb2x1bW4gPSBtYXRjaC5ncm91cCgxKSAgICMgTmFtZSBvZiBjb2x1bW4KICAgICAgICAgICAgICAgIHJvdyA9IGludChtYXRjaC5ncm91cCgyKSkgIyAwLW9yaWdpbiByb3cgbnVtYmVyCiAgICAgICAgICAgICAgICBpbWFnZXMuYXBwZW5kKChpbWdfaHRtbCwgY29sdW1uLCByb3cpKQogICAgICAgIHJldHVybiBpbWFnZXMKCiAgICBkZWYgdGVzdF9jb2RlKHNlbGYpOgogICAgICAgICIiIlRoZSAibWFpbiBwcm9ncmFtIiBmb3IgdGVzdGluZy4gUmV0dXJucyB0aGUgdGVzdCBvdXRjb21lLCByZWFkeSB0byBiZSBwcmludGVkIGJ5IGpzb24uZHVtcHMiIiIKICAgICAgICBlcnJvcnMgPSBzZWxmLnByZXJ1bl9ob29rKCkKICAgICAgICBpZiBlcnJvcnM6CiAgICAgICAgICAgIG1hcmsgPSAwCiAgICAgICAgZWxzZToKICAgICAgICAgICAgbWFyaywgZXJyb3JzID0gc2VsZi5jb21waWxlX2FuZF9ydW4oKQoKICAgICAgICBvdXRjb21lID0geyJmcmFjdGlvbiI6IG1hcmt9CgogICAgICAgIGVycm9yX3RleHQgPSAnXG4nLmpvaW4oZXJyb3JzKQogICAgICAgICMgVE9ETyAtIGNoZWNrIGlmIGVycm9yIGxpbmUgbnVtYmVycyBhcmUgc3RpbGwgYmVpbmcgY29ycmVjdGVkIGluIEMgYW5kIG1hdGxhYgogICAgICAgIGlmIHNlbGYucGFyYW1zWydJU19QUkVDSEVDSyddOgogICAgICAgICAgICBpZiBtYXJrID09IDE6CiAgICAgICAgICAgICAgICBwcm9sb2d1ZSA9ICI8cCBjbGFzcz0ncHJlY2hlY2tyZXN1bHQnPlBhc3NlZCDwn5mCPC9wPiIKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIHByb2xvZ3VlID0gIjxwIGNsYXNzPSdwcmVjaGVja3Jlc3VsdCc+RmFpbGVkLCBhcyBmb2xsb3dzLjwvcD4iCiAgICAgICAgZWxpZiBlcnJvcnM6CiAgICAgICAgICAgIHByb2xvZ3VlID0gIjxkaXYgY2xhc3M9J2NvZGVydW5uZXItdGVzdC1yZXN1bHRzIGJhZCc+PGgzPlByZS1ydW4gY2hlY2tzIGZhaWxlZDwvaDM+XG4iCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcHJvbG9ndWUgPSAiIgoKICAgICAgICBpZiBwcm9sb2d1ZToKICAgICAgICAgICAgb3V0Y29tZVsncHJvbG9ndWVodG1sJ10gPSBwcm9sb2d1ZSArIHNlbGYuaHRtbGl6ZShlcnJvcl90ZXh0KQoKICAgICAgICBlcGlsb2d1ZSA9ICcnCiAgICAgICAgaW1hZ2VzID0gc2VsZi5nZXRfYWxsX2ltYWdlc19odG1sKCkKICAgICAgICBpZiBpbWFnZXM6CiAgICAgICAgICAgIGZvciAoaW1hZ2UsIGNvbHVtbiwgcm93KSBpbiBpbWFnZXM6CiAgICAgICAgICAgICAgICBzZWxmLnJlc3VsdF90YWJsZS5hZGRfaW1hZ2UoaW1hZ2UsIGNvbHVtbiwgcm93KQogICAgICAgIG91dGNvbWVbJ2NvbHVtbmZvcm1hdHMnXSA9IHNlbGYucmVzdWx0X3RhYmxlLmdldF9jb2x1bW5fZm9ybWF0cygpCgogICAgICAgIGlmIGxlbihzZWxmLnJlc3VsdF90YWJsZS50YWJsZSkgPiAxOgogICAgICAgICAgICBvdXRjb21lWyd0ZXN0cmVzdWx0cyddID0gc2VsZi5yZXN1bHRfdGFibGUuZ2V0X3RhYmxlKCkKICAgICAgICAgICAgb3V0Y29tZVsnc2hvd2RpZmZlcmVuY2VzJ10gPSBUcnVlCgogICAgICAgIGlmIHNlbGYucmVzdWx0X3RhYmxlLmdsb2JhbF9lcnJvcjoKICAgICAgICAgICAgZXBpbG9ndWUgKz0gIjxkaXYgY2xhc3M9J2NvZGVydW5uZXItdGVzdC1yZXN1bHRzIGJhZCc+PGg0PlJ1biBFcnJvcjwvaDQ+PHByZT57fTwvcHJlPjwvZGl2PiIuZm9ybWF0KAogICAgICAgICAgICAgICAgc2VsZi5odG1saXplKHNlbGYucmVzdWx0X3RhYmxlLmdsb2JhbF9lcnJvcikpCgogICAgICAgIGlmIHNlbGYucmVzdWx0X3RhYmxlLmFib3J0ZWQ6CiAgICAgICAgICAgIGVwaWxvZ3VlID0gb3V0Y29tZS5nZXQoJ2VwaWxvZ3VlaHRtbCcsICcnKSArICgKICAgICAgICAgICAgICAgICI8ZGl2IGNsYXNzPSdjb2RlcnVubmVyLXRlc3QtcmVzdWx0cyBiYWQnPlRlc3Rpbmcgd2FzIGFib3J0ZWQgZHVlIHRvIHJ1bnRpbWUgZXJyb3JzLjwvZGl2PiIpCgogICAgICAgIGlmIHNlbGYucmVzdWx0X3RhYmxlLm1pc3NpbmdfdGVzdHMgIT0gMDoKICAgICAgICAgICAgdGVtcGxhdGUgPSAiPGRpdiBjbGFzcz0nY29kZXJ1bm5lci10ZXN0LXJlc3VsdHMgYmFkJz57fSB0ZXN0cyBub3QgcnVuIGR1ZSB0byBwcmV2aW91cyBlcnJvcnMuPC9kaXY+IgogICAgICAgICAgICBlcGlsb2d1ZSArPSB0ZW1wbGF0ZS5mb3JtYXQoc2VsZi5yZXN1bHRfdGFibGUubWlzc2luZ190ZXN0cykKCiAgICAgICAgaWYgc2VsZi5yZXN1bHRfdGFibGUuZmFpbGVkX2hpZGRlbjoKICAgICAgICAgICAgZXBpbG9ndWUgKz0gIjxkaXYgY2xhc3M9J2NvZGVydW5uZXItdGVzdC1yZXN1bHRzIGJhZCc+T25lIG9yIG1vcmUgaGlkZGVuIHRlc3RzIGZhaWxlZC48L2Rpdj4iCgogICAgICAgIGlmIGVwaWxvZ3VlOgogICAgICAgICAgICBvdXRjb21lWydlcGlsb2d1ZWh0bWwnXSA9IGVwaWxvZ3VlCiAgICAgICAgcmV0dXJuIG91dGNvbWUKCiAgICBAc3RhdGljbWV0aG9kCiAgICBkZWYgY2xlYW4oY29kZSk6CiAgICAgICAgIiIiUmV0dXJuIHRoZSBnaXZlbiBjb2RlIHdpdGggdHJhaWxpbmcgd2hpdGUgc3BhY2Ugc3RyaXBwZWQgZnJvbSBlYWNoIGxpbmUiIiIKICAgICAgICByZXR1cm4gJ1xuJy5qb2luKFtsaW5lLnJzdHJpcCgpIGZvciBsaW5lIGluIGNvZGUuc3BsaXQoJ1xuJyldKSArICdcbicKCiAgICBAc3RhdGljbWV0aG9kCiAgICBkZWYgaHRtbGl6ZShtZXNzYWdlKToKICAgICAgICAiIiJBbiBodG1sIHZlcnNpb24gb2YgdGhlIGdpdmVuIGVycm9yIG1lc3NhZ2UiIiIKICAgICAgICByZXR1cm4gJzxwcmU+JyArIGh0bWwuZXNjYXBlKG1lc3NhZ2UpICsgJzwvcHJlPicgaWYgbWVzc2FnZSBlbHNlICcnCg==</file>
<file name="__watchdog.py" path="/" encoding="base64">IyEvdXNyL2Jpbi9weXRob24KIyBmaWxlOiB3YXRjaGRvZy5weQojIGxpY2Vuc2U6IE1JVCBMaWNlbnNlCiMgRnJvbSBodHRwczovL2R6b25lLmNvbS9hcnRpY2xlcy9zaW1wbGUtcHl0aG9uLXdhdGNoZG9nLXRpbWVyCgppbXBvcnQgc2lnbmFsCgpjbGFzcyBXYXRjaGRvZyhFeGNlcHRpb24pOgogICAgZGVmIF9faW5pdF9fKHNlbGYsIHRpbWUpOgogICAgICAgICIiIlNldCB1cCBhIHRpbWVyIGFsYXJtIHRvIGdvIG9mZiBpbiAndGltZScgc2Vjcy4iIiIKICAgICAgICBzZWxmLnRpbWUgPSB0aW1lCgogICAgZGVmIF9fZW50ZXJfXyhzZWxmKToKICAgICAgICAiIiJDYWxsZWQgb24gZW50ZXJpbmcgYSAnd2l0aCcgYmxvY2siIiIKICAgICAgICBzaWduYWwuc2lnbmFsKHNpZ25hbC5TSUdBTFJNLCBzZWxmLmhhbmRsZXIpCiAgICAgICAgc2lnbmFsLmFsYXJtKHNlbGYudGltZSkKCiAgICBkZWYgX19leGl0X18oc2VsZiwgdHlwZSwgdmFsdWUsIHRyYWNlYmFjayk6CiAgICAgICAgIiIiRXhpdGluZyB0aGUgd2l0aCBibG9jay4gQ2FuY2VsIHRoZSB3YXRjaGRvZyIiIgogICAgICAgIHNpZ25hbC5hbGFybSgwKQoKICAgIGRlZiBoYW5kbGVyKHNlbGYsIHNpZ251bSwgZnJhbWUpOgogICAgICAgICIiIkFsYXJtIHdlbnQgb2ZmLiBSYWlzZSBXYXRjaGRvZyBleGNlcHRpb24iIiIKICAgICAgICByYWlzZSBzZWxmCgogICAgZGVmIF9fc3RyX18oc2VsZik6CiAgICAgICAgcmV0dXJuICJXYXRjaGRvZyB0aW1lciBleHBpcmVkIGFmdGVyIHt9IHNlY3MiLmZvcm1hdChzZWxmLnRpbWUpCg==</file>
<file name="pytester.py" path="/" encoding="base64">IiIiVGhlIG1haW4gcHl0aG9uLXByb2dyYW0gdGVzdGluZyBjbGFzcyB0aGF0IGRvZXMgYWxsIHRoZSB3b3JrIC0gc3R5bGUgY2hlY2tzLAogICBydW4gYW5kIGdyYWRlLiBBIHN1YmNsYXNzIG9mIHRoZSBnZW5lcmljIHRlc3Rlci4KICAgU2luY2UgZWFjaCB0ZXN0IGNhbiBieSBydW4gd2l0aGluIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIFB5dGhvbiB1c2luZwogICBhbiBleGVjLCB3ZSBhdm9pZCB0aGUgdXN1YWwgY29tcGxpY2F0aW9uIG9mIGNvbWJpbmF0b3JzIGJ5IHJ1bm5pbmcKICAgZWFjaCB0ZXN0IHNlcGFyYXRlbHkgcmVnYXJkbGVzcyBvZiBwcmVzZW5jZSBvZiBzdGRpbiwgdGVzdGNvZGUsIGV0Yy4KIiIiCmltcG9ydCBfX3B5dGFzayBhcyBweXRhc2sKaW1wb3J0IHJlCmZyb20gX190ZXN0ZXIgaW1wb3J0IFRlc3Rlcgpmcm9tIF9fcHlzdHlsZWNoZWNrZXIgaW1wb3J0IFN0eWxlQ2hlY2tlcgoKCmNsYXNzIFB5VGVzdGVyKFRlc3Rlcik6CiAgICBkZWYgX19pbml0X18oc2VsZiwgcGFyYW1zLCB0ZXN0Y2FzZXMpOgogICAgICAgICIiIkluaXRpYWxpc2UgdGhlIGluc3RhbmNlLCBnaXZlbiB0aGUgdGVzdCBvZiB0ZW1wbGF0ZSBhbmQgZ2xvYmFsIHBhcmFtZXRlcnMgcGx1cwogICAgICAgICAgIGFsbCB0aGUgdGVzdGNhc2VzLiBQYXJhbWV0ZXJzIHJlbGV2YW50IHRvIHRoaXMgY2xhc3MgYXJlIGFsbCB0aG9zZSBsaXN0ZWQgZm9yIHRoZSBUZXN0ZXIgY2xhc3MgcGx1cwogICAgICAgICAgICAgICAnZXh0cmEnIHdoaWNoIHRha2VzIHRoZSB2YWx1ZXMgJ3ByZXRlc3QnIG9yICdwb3N0dGVzdCcgKHRoZSBvdGhlciBwb3NzaWJsZSB2YWx1ZSwgJ3N0ZGluJywgaGFzIGJlZW4KICAgICAgICAgICAgICAgaGFuZGxlZCBieSB0aGUgbWFpbiB0ZW1wbGF0ZSkuCiAgICAgICAgICAgQWRkaXRpb25hbGx5IHRoZSBzdXBwb3J0IGNsYXNzZXMgbGlrZSBzdHlsZWNoZWNrZXIgYW5kIHB5cGFyc2VyIG5lZWQgdGhlaXIKICAgICAgICAgICBvd24gcGFyYW1zIC0gcS52LgogICAgICAgICIiIgogICAgICAgIHN1cGVyKCkuX19pbml0X18ocGFyYW1zLCB0ZXN0Y2FzZXMpICAjIE1vc3Qgb2YgdGhlIHRhc2sgaXMgaGFuZGVkIGJ5IHRoZSBnZW5lcmljIHRlc3RlcgoKICAgICAgICAjIFB5LWRlcGVuZGVudCBhdHRyaWJ1dGVzCiAgICAgICAgc2VsZi50YXNrID0gcHl0YXNrLlB5VGFzayhwYXJhbXMpCiAgICAgICAgc2VsZi5wcmVsdWRlID0gJycKCiAgICAgICAgaWYgcGFyYW1zWydpc2Z1bmN0aW9uJ106CiAgICAgICAgICAgIGlmIG5vdCBzZWxmLmhhc19kb2NzdHJpbmcoKToKICAgICAgICAgICAgICAgIHNlbGYucHJlbHVkZSA9ICciIiJEdW1teSBkb2NzdHJpbmcgZm9yIGEgZnVuY3Rpb24iIiJcbicKCiAgICAgICAgaWYgcGFyYW1zWyd1c2VzbWF0cGxvdGxpYiddOgogICAgICAgICAgICBzZWxmLnByZWx1ZGUgKz0gJ1xuJy5qb2luKFsKICAgICAgICAgICAgICAgICdpbXBvcnQgb3MnLAogICAgICAgICAgICAgICAgJ2ltcG9ydCBtYXRwbG90bGliIGFzIF9tcGwnLAogICAgICAgICAgICAgICAgJ19tcGwudXNlKCJBZ2ciKScsCiAgICAgICAgICAgICAgICAnZnJvbSBfX3Bsb3R0b29scyBpbXBvcnQgcHJpbnRfcGxvdF9pbmZvJywKICAgICAgICAgICAgXSkgKyAnXG4nCiAgICAgICAgICAgIHNlbGYucGFyYW1zWydweWxpbnRvcHRpb25zJ10uYXBwZW5kKCItLWRpc2FibGU9dW5ncm91cGVkLWltcG9ydHMiKQoKICAgICAgICBpZiBwYXJhbXNbJ3VzZXNudW1weSddOgogICAgICAgICAgICBzZWxmLnByZWx1ZGUgKz0gICdpbXBvcnQgbnVtcHkgYXMgbnBcbicKICAgICAgICAgICAgc2VsZi5wYXJhbXNbJ3B5bGludG9wdGlvbnMnXS5hcHBlbmQoIi0tZGlzYWJsZT11bnVzZWQtaW1wb3J0LHVuZ3JvdXBlZC1pbXBvcnRzIikKICAgICAgICAgICAgc2VsZi5wYXJhbXNbJ3B5bGludG9wdGlvbnMnXS5hcHBlbmQoIi0tZXh0ZW5zaW9uLXBrZy13aGl0ZWxpc3Q9bnVtcHkiKQoKICAgICAgICBmb3IgaW1wb3J0X3N0cmluZyBpbiBwYXJhbXNbJ2ltcG9ydHMnXToKICAgICAgICAgICAgaWYgJyAnIG5vdCBpbiBpbXBvcnRfc3RyaW5nOgogICAgICAgICAgICAgICAgc2VsZi5wcmVsdWRlICs9ICdpbXBvcnQgJyArIGltcG9ydF9zdHJpbmcgKyAnXG4nCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBzZWxmLnByZWx1ZGUgKz0gaW1wb3J0X3N0cmluZyArICdcbicKCiAgICAgICAgaWYgcGFyYW1zWydwcmVsdWRlJ10gIT0gJyc6CiAgICAgICAgICAgIHNlbGYucHJlbHVkZSArPSAnXG4nICsgcGFyYW1zWydwcmVsdWRlJ10ucnN0cmlwKCkgKyAnXG4nCgogICAgICAgIHRyeToKICAgICAgICAgICAgd2l0aCBvcGVuKCdfcHJlZml4LnB5JykgYXMgcHJlZml4OgogICAgICAgICAgICAgICAgcHJlZml4X2NvZGUgPSBwcmVmaXgucmVhZCgpCiAgICAgICAgICAgICAgICBzZWxmLnByZWx1ZGUgKz0gcHJlZml4X2NvZGUucnN0cmlwKCkgKyAnXG4nCgogICAgICAgIGV4Y2VwdCBGaWxlTm90Rm91bmRFcnJvcjoKICAgICAgICAgICAgcGFzcwoKICAgICAgICBzZWxmLnByZWx1ZGVfbGVuZ3RoID0gbGVuKHNlbGYucHJlbHVkZS5zcGxpdGxpbmVzKCkpCiAgICAgICAgaWYgc2VsZi5oYXNfZG9jc3RyaW5nKCkgYW5kIHNlbGYucHJlbHVkZV9sZW5ndGggPiAwOgogICAgICAgICAgICAjIElmIHdlIGluc2VydCBwcmVsdWRlIGluIGZyb250IG9mIHRoZSBkb2NzdHJpbmcsIHB5bGludCB3aWxsCiAgICAgICAgICAgICMgZ2l2ZSBhIG1pc3NpbmcgZG9jc3RyaW5nIGVycm9yLiBPdXIgaG9ycmlibGUgaGFjayBzb2x1dGlvbiBpcwogICAgICAgICAgICAjIHRvIGluc2VydCBhbiBleHRyYSBkb2NzdHJpbmcgYXQgdGhlIHN0YXJ0IGFuZCB0dXJuIG9mZiB0aGUKICAgICAgICAgICAgIyByZXN1bHRpbmcgJ3N0cmluZyBzdGF0ZW1lbnQgaGFzIG5vIGVmZmVjdCcgZXJyb3IuCiAgICAgICAgICAgIHNlbGYucHJlbHVkZSA9ICciIiJEdW1teSBkb2NzdHJpbmcgZm9yIGEgZnVuY3Rpb24iIiJcbicgKyBzZWxmLnByZWx1ZGUKICAgICAgICAgICAgc2VsZi5wcmVsdWRlX2xlbmd0aCArPSAxCiAgICAgICAgICAgIHNlbGYucGFyYW1zWydweWxpbnRvcHRpb25zJ10uYXBwZW5kKCItLWRpc2FibGU9VzAxMDUiKQogICAgICAgIHNlbGYuc3R5bGVfY2hlY2tlciA9IFN0eWxlQ2hlY2tlcihzZWxmLnByZWx1ZGUsIHNlbGYucGFyYW1zWydTVFVERU5UX0FOU1dFUiddLCBzZWxmLnBhcmFtcykKCiAgICBkZWYgaGFzX2RvY3N0cmluZyhzZWxmKToKICAgICAgICAiIiJUcnVlIGlmIHRoZSBzdHVkZW50IGFuc3dlciBoYXMgYSBkb2NzdHJpbmcsIHdoaWNoIG1lYW5zIHRoYXQsCiAgICAgICAgICAgd2hlbiBzdHJpcHBlZCwgaXQgc3RhcnRzIHdpdGggYSBzdHJpbmcgbGl0ZXJhbC4KICAgICAgICAiIiIKICAgICAgICBwcm9nID0gc2VsZi5wYXJhbXNbJ1NUVURFTlRfQU5TV0VSJ10ubHN0cmlwKCkKICAgICAgICByZXR1cm4gcHJvZy5zdGFydHN3aXRoKCciJykgb3IgcHJvZy5zdGFydHN3aXRoKCInIikKCiAgICBkZWYgc3R5bGVfZXJyb3JzKHNlbGYpOgogICAgICAgICIiIlJldHVybiBhIGxpc3Qgb2YgYWxsIHRoZSBzdHlsZSBlcnJvcnMuIiIiCiAgICAgICAgdHJ5OgogICAgICAgICAgICAjIFN0eWxlLWNoZWNrIHRoZSBwcm9ncmFtIHdpdGhvdXQgYW55IHRlc3QgY2FzZXMgb3Igb3RoZXIgcG9zdGx1ZGUgYWRkZWQKICAgICAgICAgICAgZXJyb3JzID0gc2VsZi5zdHlsZV9jaGVja2VyLnN0eWxlX2Vycm9ycygpCiAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgICAgICBlcnJvcl90ZXh0ID0gJyoqKiBVbmV4cGVjdGVkIGVycm9yIHdoaWxlIHJ1bm5lciBwcmVjaGVja2Vycy4gUGxlYXNlIHJlcG9ydCAqKipcbicgKyBzdHIoZSkKICAgICAgICAgICAgZXJyb3JzID0gW2Vycm9yX3RleHRdCiAgICAgICAgZXJyb3JzID0gW3NlbGYuYWRqdXN0X2Vycm9yX2xpbmVfbnVtcyhlcnJvcikgZm9yIGVycm9yIGluIGVycm9yc10KCiAgICAgICAgaWYgbGVuKGVycm9ycykgPT0gMDoKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgZXJyb3JzID0gc2VsZi5zdHlsZV9jaGVja2VyLmxvY2FsX2Vycm9ycygpICMgTm90ZTogcHJlbHVkZSBub3QgaW5jbHVkZWQgc28gZG9uJ3QgYWRqdXN0IGxpbmUgbnVtcwogICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgICAgICAgICBlcnJvcl90ZXh0ID0gJyoqKiBVbmV4cGVjdGVkIGVycm9yIHdoaWxlIGRvaW5nIGxvY2FsIHN0eWxlIGNoZWNrcy4gUGxlYXNlIHJlcG9ydCAqKipcbicgKyBzdHIoZSkKICAgICAgICAgICAgICAgIGVycm9ycyA9IFtlcnJvcl90ZXh0XQoKICAgICAgICBjaGVja19mb3JfcGFzc2l2ZSA9IChzZWxmLnBhcmFtc1snd2FybmlmcGFzc2l2ZW91dHB1dCddIGFuZCBzZWxmLnBhcmFtc1snaXNmdW5jdGlvbiddKQogICAgICAgIGlmIGxlbihlcnJvcnMpID09IDAgYW5kIGNoZWNrX2Zvcl9wYXNzaXZlIGFuZCBzZWxmLnBhc3NpdmVfb3V0cHV0KCk6CiAgICAgICAgICAgIGVycm9ycy5hcHBlbmQoIllvdXIgY29kZSB3YXMgbm90IGV4cGVjdGVkIHRvIGdlbmVyYXRlIGFueSBvdXRwdXQgIiArCiAgICAgICAgICAgICAgICAid2hlbiBleGVjdXRlZCBzdGFuZC1hbG9uZS5cbkRpZCB5b3UgYWNjaWRlbnRhbGx5IGluY2x1ZGUgIiArCiAgICAgICAgICAgICAgICAieW91ciB0ZXN0IGNvZGU/IikKCiAgICAgICAgcmV0dXJuIGVycm9ycwoKICAgIGRlZiBwcmVydW5faG9vayhzZWxmKToKICAgICAgICAiIiJBIGhvb2sgZm9yIHN1YmNsYXNzZXMgdG8gZG8gaW5pdGlhbCBzZXR1cCBvciBjb2RlIGhhY2tzIGV0YwogICAgICAgICAgIFJldHVybnMgYSBsaXN0IG9mIGVycm9ycywgdG8gd2hpY2ggb3RoZXIgZXJyb3JzIGFyZSBhcHBlbmRlZC4KICAgICAgICAgICBJbiB0aGlzIGNsYXNzIHdlIHVzZSBpdCB0byBwZXJmb3JtIHJlcXVpcmVkIGhhY2tzIHRvIGRpc2FibGUKICAgICAgICAgICBjYWxscyB0byBtYWluLiBJZiB0aGUgY2FsbCB0byBtYWluX2hhY2tzIGZhaWxzLCBhc3N1bWUgdGhlIGNvZGUKICAgICAgICAgICBpcyBiYWQgYW5kIHdpbGwgZ2V0IGZsYWdnZWQgYnkgcHlsaW50IGluIGR1ZSBjb3Vyc2UuCiAgICAgICAgIiIiCiAgICAgICAgdHJ5OgogICAgICAgICAgICByZXR1cm4gc2VsZi5tYWluX2hhY2tzKCkKICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgIHJldHVybiBbXQoKICAgIGRlZiBwYXNzaXZlX291dHB1dChzZWxmKToKICAgICAgICAiIiIgUmV0dXJuIHRoZSBwYXNzaXZlIG91dHB1dCBmcm9tIHRoZSBzdHVkZW50IGFuc3dlciBjb2RlCiAgICAgICAgICAgIFRoaXMgaXMgZXNzZW50aWFsbHkgYSAiZHJ5IHJ1biIgb2YgdGhlIGNvZGUuCiAgICAgICAgIiIiCiAgICAgICAgY29kZSA9IHNlbGYucHJlbHVkZSArIHNlbGYucGFyYW1zWydTVFVERU5UX0FOU1dFUiddCiAgICAgICAgaWYgc2VsZi5wYXJhbXNbJ3VzZXNtYXRwbG90bGliJ106CiAgICAgICAgICAgIGNvZGUgKz0gJ1xuJy5qb2luKFsKICAgICAgICAgICAgICAgICdmaWdzID0gX21wbC5weXBsb3QuZ2V0X2ZpZ251bXMoKScsCiAgICAgICAgICAgICAgICAnaWYgZmlnczonLAogICAgICAgICAgICAgICAgJyAgICBwcmludChmIntsZW4oZmlncyl9IGZpZ3VyZXMgZm91bmQiKScKICAgICAgICAgICAgXSkgKyAnXG4nCiAgICAgICAgdGFzayA9IHB5dGFzay5QeVRhc2soc2VsZi5wYXJhbXMsIGNvZGUpCiAgICAgICAgdGFzay5jb21waWxlKCkKICAgICAgICBjYXB0dXJlZF9vdXRwdXQsIGNhcHR1cmVkX2Vycm9yID0gdGFzay5ydW5fY29kZSgpCiAgICAgICAgcmV0dXJuIChjYXB0dXJlZF9vdXRwdXQgKyAnXG4nICsgY2FwdHVyZWRfZXJyb3IpLnN0cmlwKCkKCiAgICBkZWYgbWFrZV90ZXN0X3Bvc3RsdWRlKHNlbGYsIHRlc3RjYXNlcyk6CiAgICAgICAgIiIiUmV0dXJuIHRoZSBjb2RlIHRoYXQgZm9sbG93cyB0aGUgc3R1ZGVudCBhbnN3ZXIgY29udGFpbmluZyBhbGwgdGhlIHRlc3Rjb2RlCiAgICAgICAgICAgZnJvbSB0aGUgZ2l2ZW4gbGlzdCBvZiB0ZXN0Y2FzZXMsIHdoaWNoIHNob3VsZCBhbHdheXMgYmUgb2YgbGVuZ3RoIDEKICAgICAgICAgICAoYmVjYXVzZSB3ZSBkb24ndCBib3RoZXIgdHJ5aW5nIHRvIGNvbWJpbmUgYWxsIHRoZSB0ZXN0cyBpbnRvIGEKICAgICAgICAgICBzaW5nbGUgcnVuIGluIFB5dGhvbikKICAgICAgICAiIiIKICAgICAgICBhc3NlcnQgbGVuKHRlc3RjYXNlcykgPT0gMQogICAgICAgIGlmIHNlbGYucGFyYW1zWydub3Rlc3QnXToKICAgICAgICAgICAgcmV0dXJuICcnCiAgICAgICAgdGVzdCA9IHRlc3RjYXNlc1swXQogICAgICAgIHRlc3RlciA9ICcnCiAgICAgICAgaWYgc2VsZi5wYXJhbXNbJ2dsb2JhbGV4dHJhJ10gYW5kIHNlbGYucGFyYW1zWydnbG9iYWxleHRyYSddID09ICdwcmV0ZXN0JzoKICAgICAgICAgICAgdGVzdGVyICs9IHNlbGYucGFyYW1zWydHTE9CQUxfRVhUUkEnXSArICdcbicKICAgICAgICBpZiB0ZXN0LmV4dHJhIGFuZCBzZWxmLnBhcmFtc1snZXh0cmEnXSA9PSAncHJldGVzdCc6CiAgICAgICAgICAgIHRlc3RlciArPSB0ZXN0LmV4dHJhICsgJ1xuJwogICAgICAgIGlmIHRlc3QudGVzdGNvZGU6CiAgICAgICAgICAgIHRlc3RlciArPSB0ZXN0LnRlc3Rjb2RlLnJzdHJpcCgpICsgJ1xuJwogICAgICAgIGlmIHNlbGYucGFyYW1zWydnbG9iYWxleHRyYSddIGFuZCBzZWxmLnBhcmFtc1snZ2xvYmFsZXh0cmEnXSA9PSAncG9zdHRlc3QnOgogICAgICAgICAgICB0ZXN0ZXIgKz0gc2VsZi5wYXJhbXNbJ0dMT0JBTF9FWFRSQSddICsgJ1xuJwogICAgICAgIGlmIHRlc3QuZXh0cmEgYW5kIHNlbGYucGFyYW1zWydleHRyYSddID09ICdwb3N0dGVzdCc6CiAgICAgICAgICAgIHRlc3RlciArPSB0ZXN0LmV4dHJhICsgJ1xuJwoKICAgICAgICBpZiBzZWxmLnBhcmFtc1sndXNlc21hdHBsb3RsaWInXToKICAgICAgICAgICAgaWYgc2VsZi5wYXJhbXMuZ2V0KCdydW5uaW5nX3NhbXBsZV9hbnN3ZXInLCBGYWxzZSk6CiAgICAgICAgICAgICAgICBjb2x1bW4gPSAnRXhwZWN0ZWQnCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBjb2x1bW4gPSAnR290JwogICAgICAgICAgICB0ZXN0X251bSA9IGxlbihzZWxmLnJlc3VsdF90YWJsZS50YWJsZSkgLSAxICAjIDAtb3JpZ2luIHRlc3QgbnVtYmVyIGZyb20gcmVzdWx0IHRhYmxlCiAgICAgICAgICAgIHRlc3RlciArPSAnXG4nLmpvaW4oWwogICAgICAgICAgICAgICAgJ2ZpZ3MgPSBfbXBsLnB5cGxvdC5nZXRfZmlnbnVtcygpJywKICAgICAgICAgICAgICAgICdmb3IgZmlnIGluIGZpZ3M6JywKICAgICAgICAgICAgICAgICcgICAgX21wbC5weXBsb3QuZmlndXJlKGZpZyknLAogICAgICAgICAgICAgICAgJyAgICByb3cgPSB7fScuZm9ybWF0KHRlc3RfbnVtKSwKICAgICAgICAgICAgICAgICcgICAgY29sdW1uID0gInt9IicuZm9ybWF0KGNvbHVtbiksCiAgICAgICAgICAgICAgICAnICAgIF9tcGwucHlwbG90LnNhdmVmaWcoIl9pbWFnZXt9Lnt9Lnt9LnBuZyIuZm9ybWF0KGZpZywgY29sdW1uLCByb3cpLCBiYm94X2luY2hlcz0idGlnaHQiKScsCiAgICAgICAgICAgICAgICAnICAgIF9tcGwucHlwbG90LmNsb3NlKGZpZyknCiAgICAgICAgICAgIF0pICsgJ1xuJwogICAgICAgIHJldHVybiB0ZXN0ZXIKCiAgICBkZWYgc2luZ2xlX3Byb2dyYW1fYnVpbGRfcG9zc2libGUoc2VsZik6CiAgICAgICAgIiIiV2UgYXZvaWQgYWxsIHRoZSBjb21wbGljYXRpb24gb2YgdHJ5aW5nIHRvIHJ1biBhbGwgdGVzdHMgaW4KICAgICAgICAgICBhIHNpbmdsZSBzdWJwcm9jZXNzIHJ1biBieSB1c2luZyBleGVjIHRvIHJ1biBlYWNoIHRlc3Qgc2luZ2x5LgogICAgICAgICIiIgogICAgICAgIHJldHVybiBGYWxzZQoKICAgIGRlZiBhZGp1c3RfZXJyb3JfbGluZV9udW1zKHNlbGYsIGVycm9yKToKICAgICAgICAiIiJTdWJ0cmFjdCB0aGUgcHJlbHVkZSBsZW5ndGggb2YgYWxsIGxpbmUgbnVtYmVycyBpbiB0aGUgZ2l2ZW4gZXJyb3IgbWVzc2FnZQogICAgICAgICIiIgogICAgICAgIGVycm9yX3BhdHRlcm5zID0gWwogICAgICAgICAgICAgICAgKHInKC4qPGZzdHJpbmc+LiogXChzeW50YXgtZXJyb3JcKS4qKScsIFtdKSwKICAgICAgICAgICAgICAgIChyJyguKkZpbGUgIi4qIiwgbGluZSArKShcZCspKCwgaW4gLiopJywgWzJdKSwKICAgICAgICAgICAgICAgIChyJyguKjogKikoXGQrKSgsICpcZCs6LipcKC4qbGluZSArKShcZCspKFwpLiopJywgWzIsIDRdKSwKICAgICAgICAgICAgICAgIChyJyguKjogKikoXGQrKSgsICpcZCs6LipcKC4qXCkuKiknLCBbMl0pLAogICAgICAgICAgICAgICAgKHInKC4qOikoXGQrKSg6XGQrOiBbQS1aXVxkKzogLipsaW5lICkoXGQrKSguKiknLCBbMiwgNF0pLAogICAgICAgICAgICAgICAgKHInKC4qOikoXGQrKSg6XGQrOiBbQS1aXVxkKzogLiopJywgWzJdKSwKICAgICAgICBdCiAgICAgICAgb3V0cHV0X2xpbmVzID0gW10KICAgICAgICBmb3IgbGluZSBpbiBlcnJvci5zcGxpdGxpbmVzKCk6CiAgICAgICAgICAgIGZvciBwYXR0ZXJuLCBsaW5lX2dyb3VwX251bXMgaW4gZXJyb3JfcGF0dGVybnM6CiAgICAgICAgICAgICAgICBtYXRjaCA9IHJlLm1hdGNoKHBhdHRlcm4sIGxpbmUpCiAgICAgICAgICAgICAgICBpZiBtYXRjaDoKICAgICAgICAgICAgICAgICAgICBsaW5lID0gJycKICAgICAgICAgICAgICAgICAgICBmb3IgaSwgZ3JvdXAgaW4gZW51bWVyYXRlKG1hdGNoLmdyb3VwcygpLCAxKToKICAgICAgICAgICAgICAgICAgICAgICAgaWYgaSBpbiBsaW5lX2dyb3VwX251bXM6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lbnVtID0gaW50KG1hdGNoLmdyb3VwKGkpKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRqdXN0ZWQgPSBsaW5lbnVtIC0gc2VsZi5wcmVsdWRlX2xlbmd0aAogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZSArPSBzdHIoYWRqdXN0ZWQpCiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lICs9IGdyb3VwCiAgICAgICAgICAgICAgICAgICAgYnJlYWsKCiAgICAgICAgICAgIG91dHB1dF9saW5lcy5hcHBlbmQobGluZSkKICAgICAgICByZXR1cm4gJ1xuJy5qb2luKG91dHB1dF9saW5lcykKCiAgICBkZWYgbWFpbl9oYWNrcyhzZWxmKToKICAgICAgICAiIiJNb2RpZnkgdGhlIGNvZGUgdG8gYmUgdGVzdGVkIGlmIHBhcmFtcyBzdHJpcG1haW4gb3Igc3RyaXBtYWluaWZwcmVzZW50JwogICAgICAgICAgIGFyZSBzcGVjaWZpZWQuIFJldHVybnMgYSBsaXN0IG9mIGVycm9ycyBlbmNvdW50ZXJlZCB3aGlsZSBzbyBkb2luZy4KICAgICAgICAiIiIKICAgICAgICBlcnJvcnMgPSBbXQogICAgICAgIGlmIHNlbGYucGFyYW1zWydzdHJpcG1haW4nXSBvciBzZWxmLnBhcmFtc1snc3RyaXBtYWluaWZwcmVzZW50J106CiAgICAgICAgICAgIG1haW5fY2FsbHMgPSBzZWxmLnN0eWxlX2NoZWNrZXIuZmluZF9mdW5jdGlvbl9jYWxscygnbWFpbicpCiAgICAgICAgICAgIGlmIHNlbGYucGFyYW1zWydzdHJpcG1haW4nXSBhbmQgbWFpbl9jYWxscyA9PSBbXToKICAgICAgICAgICAgICAgIGVycm9ycy5hcHBlbmQoIk5vIGNhbGwgdG8gbWFpbigpIGZvdW5kIikKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIHN0dWRlbnRfbGluZXMgPSBzZWxmLnN0dWRlbnRfYW5zd2VyLnNwbGl0KCdcbicpCiAgICAgICAgICAgICAgICBmb3IgKGxpbmUsIGRlcHRoKSBpbiBtYWluX2NhbGxzOgogICAgICAgICAgICAgICAgICAgIGlmIGRlcHRoID09IDA6CiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbCA9IHN0dWRlbnRfbGluZXNbbGluZV0KICAgICAgICAgICAgICAgICAgICAgICAgaWYgbm90IHJlLm1hdGNoKCcgKm1haW5cKFwpJywgbWFpbl9jYWxsKToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5hcHBlbmQoZiJJbGxlZ2FsIGNhbGwgdG8gbWFpbigpLlxuIiArCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1haW4gc2hvdWxkIG5vdCB0YWtlIGFueSBwYXJhbWV0ZXJzIGFuZCBzaG91bGQgbm90IHJldHVybiBhbnl0aGluZy4iKQogICAgICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R1ZGVudF9saW5lc1tsaW5lXSA9IG1haW5fY2FsbC5yZXBsYWNlKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWFpbiIsICJwYXNzICAgIyBEaXNhYmxlZCBjYWxsIHRvIG1haW4iKQogICAgICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgICAgIHN0dWRlbnRfbGluZXNbbGluZV0gKz0gIiAgIyBXZSd2ZSBsZXQgeW91IGNhbGwgbWFpbiBoZXJlLiIKICAgICAgICAgICAgICAgIHNlbGYucGFyYW1zWydTVFVERU5UX0FOU1dFUiddID0gc2VsZi5zdHVkZW50X2Fuc3dlciA9ICdcbicuam9pbihzdHVkZW50X2xpbmVzKSArICdcbicKCiAgICAgICAgcmV0dXJuIGVycm9ycwo=</file>
    </testcases>
  </question>

</quiz>