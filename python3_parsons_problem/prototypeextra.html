<!--
Code for use within the CodeRunner HTML UI to implement a Parsons
Problem question type.

-- Richard Lobb, 2021, 2025.

-->

<style>
    .CR-parsons-authoring {
        display: none;
    }

    .CR-parsons-error {
        display: none;
        background-color: yellow;
    }

    .sortable-code {
        position: static;
        padding-left: 0px;
        margin-left: 2%;
        float: left;
        width: 94%;
        max-width: {{ code_width }};
    }

    .sortable-code ul {
        font-size: 90%;
        font-family: monospace;
        list-style: none;
        background-color: #cbcff7;
        padding-bottom: 26px;
        padding-left: 0;
        margin-left: 0;
        border: 1px solid #efefff;
    }

    .sortable-code ul:empty {
        padding-bottom: 30px;
    }

    .sortable-code li,
    .sortable-code li:before,
    .sortable-code li:after {
        box-sizing: content-box;
    }

    ul.output {
        background-color: #FFA;
    }

    [draggable="true"] {
        cursor: move;
        user-select: none;
    }

    .sortable-code.drag-over {
        border-color: #000;
    }

    .sortable-code li {
        border-radius: 10px;
        background-color: white;
        border: 1px solid lightgray;
        padding: 4px 8px;
        margin: 4px 0 0 0;
        white-space: nowrap;
        overflow: hidden;
        cursor: move;
    }

    .sortable-code li:hover {
        overflow: visible;
    }

    .dragging {
        opacity: 0.5;
    }

    .insertion-marker {
        height: 2px;
        opacity: 0;
        background-color: inherit;
        border: 1px dashed rgb(185, 34, 34);
        margin: 4px 0 0 0;
        pointer-events: none;
    }

    .insertion-marker.visible {
        height: 35px;
        opacity: 1;
    }

</style>

<script>
    require([], function () {
        'use strict';

        const CONSTANTS = {
            MAX_INDENT: 7,
            X_INDENT: 35,
            TRIM_REGEXP: /^\s*(.*?)\s*$/,
        };

        // Class to represent a single line of code in the Parsons problem.
        class CodeLine {
            static nextId = 0;

            constructor(codestring, widget, allowIndent) {
                this.code = this.parseCode(codestring);
                this.indent = allowIndent ? this.codeLineIndent(codestring) : 0;
                this.id = `${widget.id_prefix}codeline${CodeLine.nextId++}`;
            }

            // Remove trailing whitespace and a trailing #distractor comment.
            parseCode(codestring) {
                if (!codestring) return '';
                return codestring
                    .replace(/#distractor\s*$/, '')
                    .replace(CONSTANTS.TRIM_REGEXP, '$1')
                    .replace(/\\n/g, '\n');
            }

            // Calculate the indent level of the line of code.
            codeLineIndent(codestring) {
                const spaces = codestring.length - codestring.replace(/^\s+/, '').length;
                return Math.min(Math.floor(spaces / 4), CONSTANTS.MAX_INDENT);
            }

            // Convert the code line to HTML for display in the UL element.
            toHTML(xIndent) {
                const indent = this.indent ? `margin-left: ${xIndent * this.indent}px` : '';
                return `<li id="${this.id}" class="ace-static-highlight lang-py" style="${indent}">${this.code}</li>`;
            }
        }

        // Class to manage drag and drop operations for the Parsons problem.
        // The DnD API is used for desktop browsers and touch events for touch devices.
        class DragDropManager {
            constructor(sourceElement, targetElement, parsonsWidget) {
                this.sourceElement = sourceElement;  // The UL element containing the draggable items (source).
                this.targetElement = targetElement;  // The UL element where the solution is constructed (target).
                this.parsonsWidget = parsonsWidget;  // Link back to the ParsonsWidget object.
                this.draggedElement = null;          // The element currently being dragged
                this.dragOffsetX = 0;                // Offset of the pointer from the left edge of the dragged element.
                this.dragOffsetY = 0;                // Offset of the pointer from the top edge of the dragged element.     
                this.clone = null;                   // The clone of the dragged element when dragging with touch.
                this.indentOnly = false;             // True if the dragged element is being indented, not moved.
                this.touchId = null;                 // The touch identifier for the current touch event.

                this.setupEventListeners();
            }

            setupEventListeners() {
                [this.sourceElement, this.targetElement].forEach(element => {
                    element.addEventListener('dragstart', this.handleDragStart.bind(this));
                    element.addEventListener('dragover', this.handleDragOver.bind(this));
                    element.addEventListener('dragleave', this.handleDragLeave.bind(this));
                    element.addEventListener('drop', this.handleDrop.bind(this));
                    element.addEventListener('dragend', this.handleDragEnd.bind(this));
                    element.addEventListener('touchstart', this.handleTouchStart.bind(this));
                });

                document.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                document.addEventListener('touchend', this.handleTouchEnd.bind(this));
            }

            // =============== Event handlers for mouse-based drag and drop ===============

            handleDragStart(e) {
                this.draggedElement = e.target;   // The element being dragged
                const element = e.currentTarget;  // The UL element containing the dragged element.
                const rect = element.getBoundingClientRect();
                const leftMargin = parseFloat(getComputedStyle(this.draggedElement).marginLeft);
                this.dragOffsetX = e.clientX - rect.left - leftMargin;
                this.draggedElement.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                this.indentOnly = false;
            }

            handleDragOver(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                const element = e.currentTarget; // The UL element being dragged over.
                const rect = element.getBoundingClientRect();
                const [indentOnly, insertBefore] = this.findInsertionPoint(
                    [...element.children], // Candidate items in the targets UL list.
                    e.clientY,
                    rect
                );
                this.indentOnly = indentOnly;

                let marker = element.querySelector('.insertion-marker');
                if (indentOnly && marker) {
                    marker.classList.remove('visible');
                    if (marker.parentElement) {
                        marker.parentElement.removeChild(marker);
                    }
                } else if (!indentOnly) {
                    const indent = this.calculateIndent(e.clientX, element)
                    this.updateInsertionMarker(element, marker, insertBefore, indent);
                }
            }

            handleDragLeave(e) {
                // Remove the marker unless this is a false dragleave resulting from
                // moving over a child element.
                const element = e.currentTarget
                if (!element.contains(e.relatedTarget)) {  // If not dragging over a child element...
                    const marker = element.querySelector('.insertion-marker');
                    if (marker) {
                        marker.classList.remove('visible');
                        if (marker.parentElement) {
                            marker.parentElement.removeChild(marker);
                        }
                    }
                }
            }

            handleDragEnd(e) {
                // Clean up after the drag operation.
                // Called on both source and destination elements in the DnD API.
                this.draggedElement.classList.remove('dragging');
                this.draggedElement = null;
                const marker = e.currentTarget.querySelector('.insertion-marker');
                if (marker) {
                    marker.classList.remove('visible');
                    if (marker.parentElement) {
                        marker.parentElement.removeChild(marker);
                    }
                }
            }

            handleDrop(e) {
                // The dragged element has been dropped on the current target.
                e.preventDefault();
                const element = e.currentTarget;
                this.setDraggedElementIndent(e.clientX, element);
                if (!this.indentOnly) {
                    const marker = element.querySelector('.insertion-marker');
                    if (marker) {
                        element.insertBefore(this.draggedElement, marker);
                        marker.remove();
                    } else {
                        element.appendChild(this.draggedElement);
                    }
                }
                this.parsonsWidget.syncToTextareas();
            }

            // =============== Event handlers for touch-based drag and drop ===============
            // Messier because we have to handle the touch events on the document, not the elements.
            // Also, we have to create a clone of the dragged element for visual feedback and
            // manage the movement of that clone.
            // There is also the possibility of multiple touches, but we process only single
            // finger touch events.

            handleTouchStart(e) {
                e.preventDefault();
                if (e.touches.length !== 1) return;
                this.touchId = e.touches[0].identifier;
                const touch = e.touches[0];
                const element = e.currentTarget;
                let target = touch.target;
                // Find the draggable element
                while (target && target !== element && !target.draggable) {
                    target = target.parentElement;
                }
                if (target && target.draggable) {
                    this.draggedElement = target;
                    const rect = this.draggedElement.getBoundingClientRect();
                    this.dragOffsetX = touch.clientX - rect.x;
                    this.dragOffsetY = touch.clientY - rect.y;
                    this.draggedElement.classList.add('dragging');

                    // Create a clone for visual feedback, with styles copied from the original element.
                    this.clone = this.draggedElement.cloneNode(true);
                    this.clone.id = 'drag-clone';
                    const computedStyles = window.getComputedStyle(this.draggedElement);
                    for (let style of computedStyles) {
                        this.clone.style[style] = computedStyles.getPropertyValue(style);
                    }

                    // Tweak the ones we need to change.
                    this.clone.style.position = 'fixed';
                    this.clone.style.margin = '0';
                    this.clone.style.left = `${rect.x}px`;
                    this.clone.style.top = `${touch.clientY - this.dragOffsetY}px`;
                    this.clone.style.opacity = '0.6';
                    this.clone.style.pointerEvents = 'none';
                    document.body.appendChild(this.clone);
                }
            }

            handleTouchMove(e) {
                // This is the messiest part of the touch-based drag and drop.
                if (!this.draggedElement || !this.clone) return; // This isn't for me.
                const touch = Array.from(e.touches).find(t => t.identifier === this.touchId);
                if (!touch) return; // This isn't the touch we're interested in.

                e.preventDefault();

                // Update clone position.
                this.clone.style.left = `${touch.clientX - this.dragOffsetX}px`;
                this.clone.style.top = `${touch.clientY - this.dragOffsetY}px`;

                // Determine current drop zone.
                const currentElement = this.findDropZone(touch);
                if (!currentElement) {
                    [this.sourceElement, this.targetElement].forEach(el => {
                        marker = el.querySelector('.insertion-marker');
                        if (marker) {
                            marker.classList.remove('visible');
                            if (marker.parentElement) {
                                marker.parentElement.removeChild(marker);
                            }
                        }
                    });
                    return;
                }

                // Calculate insertion point and indent
                const rect = currentElement.getBoundingClientRect();
                const items = [...currentElement.children].filter(child => child !== this.clone);

                const [indentOnly, insertBefore] = this.findInsertionPoint(
                    items, // Candidate items in the targets UL list.
                    touch.clientY,
                    rect
                );

                this.indentOnly = indentOnly;

                const marker = currentElement.querySelector('.insertion-marker');
                if (indentOnly && marker) {
                    marker.classList.remove('visible');
                    if (marker.parentElement) {
                        marker.parentElement.removeChild(marker);
                    }
                } else if (!indentOnly) {
                    const indent = this.calculateIndent(touch.clientX, currentElement);
                    this.updateInsertionMarker(currentElement, marker, insertBefore, indent);
                }
            }

            handleTouchEnd(e) {
                // This is equivalent to drop in the DnD API.
                const touch = Array.from(e.changedTouches).find(t => t.identifier === this.touchId);
                if (!touch || !this.draggedElement) return;

                e.preventDefault();
                this.draggedElement.classList.remove('dragging');
                if (this.clone) {
                    this.clone.remove();
                    this.clone = null;
                }
                
                const currentElement = this.findDropZone(touch);

                if (currentElement) {
                    const rect = currentElement.getBoundingClientRect();
                    this.setDraggedElementIndent(touch.clientX, currentElement);
                    if (!this.indentOnly) {
                        const marker = currentElement.querySelector('.insertion-marker');
                        if (marker) {
                            currentElement.insertBefore(this.draggedElement, marker);
                        } else {
                            currentElement.appendChild(this.draggedElement);
                        }
                    }
                    this.parsonsWidget.syncToTextareas();
                }

                [this.sourceElement, this.targetElement].forEach(el => {
                    const marker = el.querySelector('.insertion-marker');
                    if (marker) {
                        marker.classList.remove('visible');
                        if (marker.parentElement) {
                            marker.parentElement.removeChild(marker);
                        }
                    }
                });

                this.draggedElement = null;
                this.indentOnly = false;
                this.dragOffsetX = 0;
            }

            // =============== Utility methods ===============


            // Find the point at which to insert the dragged element in the given list
            // of the list items, based on the y-coordinate of the mouse/touch and the bounding
            // rectangle of the list.
            // @return [indentOnly, insertBefore] where indentOnly is true if no insertion
            // is required, only indentation. insertBefore is the list item before which the
            // dragged element should be inserted, null if it should be appended to the end.
            findInsertionPoint(items, y, rect) {
                let insertBefore = null;
                let indentOnly = false;
                for (let i = 0; i < items.length; i++) {
                    let item = items[i];
                    if (item.classList.contains('insertion-marker')) {
                        continue;
                    }

                    const box = item.getBoundingClientRect();
                    // Check if item is the dragged item and mouse is somwwhere between the centre of
                    // the item below and the centre of the item above. In that case we only want to indent.
                    if (item.classList.contains('dragging')) {
                        let lowBound = box.top;
                        let highBound = box.bottom;
                        if (i < items.length - 1) {
                            let nextBox = items[i + 1].getBoundingClientRect();
                            highBound = (nextBox.bottom + nextBox.top) / 2;
                        }
                        if (i > 0) {
                            let prevBox = items[i - 1].getBoundingClientRect();
                            lowBound = (prevBox.top + prevBox.bottom) / 2;
                        }
                        if (y > lowBound && y < highBound) {
                            indentOnly = true;
                            break;
                        }
                    }

                    if (y < box.top + box.height / 2) {
                        insertBefore = item;
                        break;
                    }
                }
                return [indentOnly, insertBefore];
            }

            // Find and return whichever of the sourceElement or targetElement the touch is over.
            findDropZone(touch) {
                let currentElement = null;
                const elements = [this.sourceElement, this.targetElement];
                for (const el of elements) {
                    const rect = el.getBoundingClientRect();
                    if (touch.clientX >= rect.left && touch.clientX <= rect.right &&
                        touch.clientY >= rect.top && touch.clientY <= rect.bottom) {
                        currentElement = el;
                        break;
                    }
                }
                return currentElement;
            }

            calculateIndent(clientX, droppedOnElement) {
                if (droppedOnElement === this.sourceElement) {
                    return 0;
                }
                const leftx = clientX - this.dragOffsetX;
                const rect = droppedOnElement.getBoundingClientRect();
                return Math.max(0, Math.round((leftx - rect.left) / CONSTANTS.X_INDENT));
            }

            setDraggedElementIndent(clientX, element) {
                this.draggedElement.style.marginLeft = this.calculateIndent(clientX, element) * CONSTANTS.X_INDENT + 'px';
            }

            updateInsertionMarker(targetElement, marker, insertBefore, indent) {
                if (!marker) {
                    // No marker yet, so create one.
                    marker = document.createElement('div');
                    marker.className = 'insertion-marker';
                }

                marker.style.marginLeft = `${CONSTANTS.X_INDENT * indent}px`;
                
                if (insertBefore) {
                    targetElement.insertBefore(marker, insertBefore);
                } else {
                    targetElement.appendChild(marker);
                }

                if (!marker.classList.contains('visible')) {
                    requestAnimationFrame(() => {
                        marker.classList.add('visible');
                    });
                }
            }
        }

        //  ===== The ParsonsWidget class manages the Parsons problem UI =====
        class ParsonsWidget {
            constructor(sourceUlId, targetUlId, sourceTaId, targetTaId) {
                this.config = {
                    sourceUlId,
                    targetUlId,
                    sourceTaId,
                    targetTaId,
                    id_prefix: `${targetUlId}codeline`
                };
                
                this.dragDropManager = new DragDropManager(
                    document.getElementById(sourceUlId),
                    document.getElementById(targetUlId),
                    this
                );
                
                this.loadFromTextareas();
                // this.setupMutationObservers(); // Not currently used.
                this.makeItemsDraggable();
                const sourceTextArea = document.getElementById(sourceTaId);
                const parentQuestionDiv = sourceTextArea.closest('div.que');
                // const sourceUl = document.getElementById(sourceUlId);
                // sourceUl.style.minHeight = window.getComputedStyle(sourceUl).height; // Prevent annoying resizing.
            }

            loadFromTextareas() {
                ['source', 'target'].forEach(type => {
                    const taId = this.config[`${type}TaId`];
                    const ulId = this.config[`${type}UlId`];
                    const textarea = document.getElementById(taId);
                    const lines = this.parseCode(textarea.value.split('\n'), true);
                    const html = this.codeLinesToHTML(lines);
                    document.getElementById(ulId).innerHTML = html.join('\n');
                });
            }

            parseCode(lines, allowIndent) {
                return lines
                    .map(line => new CodeLine(line, this, allowIndent))
                    .filter(line => line.code.trim().length > 0);
            }

            codeLinesToHTML(lines) {
                return lines.map(line => line.toHTML(CONSTANTS.X_INDENT));
            }

            // This code was part of the previous implementation. It seems unnecessary but I'm keeping it for now,
            // though it's not currently used.
            setupMutationObservers() {
                const observer = new MutationObserver(() => this.syncToTextareas());
                observer.observe(document.getElementById(`CR-parsons-sortables-___textareaId___`), {
                    childList: true,
                    attributes: true,
                    subtree: true,
                    attributeFilter: ['style']
                });
            }

            // Synchronise the contents of the UL elements with the corresponding textareas.
            syncToTextareas() {
                ['source', 'target'].forEach(type => {
                    const list = document.getElementById(this.config[`${type}UlId`]);
                    const textarea = document.getElementById(this.config[`${type}TaId`]);
                    textarea.value = this.getCodeString(list);
                });
            }

            // Convert the list of code lines in the UL element to a program string.
            getCodeString(ulElement) {
                return Array.from(ulElement.children)
                    .map(item => {
                        const indent = parseInt(item.style.marginLeft || 0, 10) / CONSTANTS.X_INDENT;
                        return ' '.repeat(indent * 4) + item.textContent.trim();
                    })
                    .join('\n');
            }

            // Make the items in the source and target UL elements draggable.
            makeItemsDraggable() {
                [this.config.sourceUlId, this.config.targetUlId].forEach(id => {
                    const element = document.getElementById(id);
                    Array.from(element.children).forEach(item => {
                        item.draggable = true;
                    });
                });
            }
        }

        // Check that the target (aka answer) textarea contains only lines
        // that are present in the source textarea. Turns on the error
        // message (yellow highlighted) if not.
        // Also rebuilds the source field for the answer to contain all unused
        // lines in the target.
        // Works only in the question authoring context.
        function checkAnswer() {
            const sourceTa = document.getElementById('CR-parsons-source-ta-id_answerpreload');
            const targetTa = document.getElementById('CR-parsons-target-ta-id_answer');
            const errorPara = document.getElementById('CR-parsons-answer-error-id_answer');
            const sourceLines = sourceTa.value.trim().split("\n");
            const answerLines = targetTa.value.trim().split("\n");

            errorPara.style.display = 'none';
            let used = [];

            for (const answerLine of answerLines) {
                if (!sourceLines.some((srcLine, index) => {
                    if (used.includes(index)) return false;
                    if (srcLine.trim() === answerLine.trim()) {
                        used.push(index);
                        return true;
                    }
                    return false;
                })) {
                    errorPara.style.display = 'inline';
                }
            }

            const answerUnused = document.getElementById('CR-parsons-source-ta-id_answer');
            answerUnused.value = sourceLines
                .filter((_, index) => !used.includes(index))
                .join('\n');
        }


        function doAceHighlighting(parentQuestionDiv) {
            if (window.ace) {
                const highlight = window.ace.require("ace/ext/static_highlight");
                const codeElements = parentQuestionDiv.getElementsByClassName('ace-static-highlight');

                for (let i = 0; i < codeElements.length; i++) {
                    let element = codeElements[i];

                    const mode = "ace/mode/python";
                    if (element.hasAttribute("lang")) {
                        mode = "ace/mode/" + element.getAttribute("lang");
                    }

                    highlight(element, {
                        mode: mode,
                        showGutter: false,
                    }, function (highlighted) {
                        const fontSize = "14px";
                        if (element.hasAttribute("font-size")) {
                            fontSize = element.getAttribute("font-size");
                        }
                        // The class ace_static_highlight (with underscores)
                        // is not to be confused with ace-static-highlight.
                        // The latter is generated by the Ace highlighter.
                        element.getElementsByClassName('ace_static_highlight')[0].style['font-size'] = fontSize;
                    });
                }
            }
        }


        // The authoring page is tricky. The answer preload displays a list of lines that will be
        // displayed in the source area. The author can shuffle these lines and remove indentation.
        // The answer area displays the solution constructed by the author.
        function setupAuthoring(sourceTextArea, targetTextArea) {
            document.querySelectorAll('.sortable-code').forEach(el => el.style.display = 'none');

            const isPreload = sourceTextArea.closest('.preloadanswer') !== null;
            if (isPreload) {
                document.getElementById("CR-parsons-preload-authoring-div-___textareaId___").style.display = "block";
                targetTextArea.value = '';

                document.getElementById("CR-parsons-shuffle-___textareaId___").onclick = function() {
                    const lines = sourceTextArea.value.trim().split('\n');
                    shuffleArray(lines);
                    sourceTextArea.value = lines.join('\n');
                };

                document.getElementById("CR-unindent-___textareaId___").onclick = function() {
                    const lines = sourceTextArea.value.trim().split('\n').map(l => l.trim());
                    sourceTextArea.value = lines.join('\n');
                };

                sourceTextArea.addEventListener('input', checkAnswer);
            } else {
                document.getElementById("CR-parsons-answer-authoring-div-___textareaId___").style.display = "block";
                targetTextArea.addEventListener('input', checkAnswer);
            }
            checkAnswer();
        }

        /* Randomize array in-place using Durstenfeld shuffle algorithm */
        function shuffleArray(array) {
            for (var i = array.length - 1; i >= 0; i--) {
                var j = Math.floor(Math.random() * (i + 1));
                var temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
        }

        function startUp() {
            const sourceUlId = 'CR-parsons-source-ul-___textareaId___';
            const targetUlId = 'CR-parsons-target-ul-___textareaId___';
            const sourceTaId = 'CR-parsons-source-ta-___textareaId___';
            const targetTaId = 'CR-parsons-target-ta-___textareaId___';
            const sourceTextArea = document.getElementById(sourceTaId);
            const targetTextArea = document.getElementById(targetTaId);
            const parentQuestionDiv = sourceTextArea.closest('div.que');
            const isQuestion = parentQuestionDiv !== null;

            const parson = new ParsonsWidget(sourceUlId, targetUlId, sourceTaId, targetTaId);

            if (isQuestion) {
                doAceHighlighting(parentQuestionDiv);
            } else {    
                setupAuthoring(sourceTextArea, targetTextArea);
            }
        }

        startUp();
    });
</script>

<div id="CR-parsons-answer-authoring-div-___textareaId___" class="CR-parsons-authoring">
    <h4>Answer:</h4>
    <p id="CR-parsons-answer-error-___textareaId___" class="CR-parsons-error">
        The answer contains line(s) not available in the preload!
    </p>
    <textarea id="CR-parsons-target-ta-___textareaId___" name='CR-parsons-target' 
              class="coderunner-ui-element" rows="8"></textarea>
</div>

<div id="CR-parsons-preload-authoring-div-___textareaId___" class="CR-parsons-authoring">
    <h4>Drag-able code lines:</h4>
    <textarea id="CR-parsons-source-ta-___textareaId___" name='CR-parsons-source'
              class="coderunner-ui-element CR-parsons-answer-edit" rows="8"></textarea>
    <div id="CR-parsons-button-div-___textareaId___">
        <button id="CR-parsons-shuffle-___textareaId___" type="button">Shuffle</button>
        <button id="CR-unindent-___textareaId___" type="button">Remove indentation</button>
    </div>
</div>

<div id="CR-parsons-sortables-___textareaId___">
    <div id="CR-parsons-source-div-___textareaId___" class="sortable-code">
        <p>Drag from here</p>
        <ul id="CR-parsons-source-ul-___textareaId___"></ul>
        </div>

        <div id="CR-parsons-target-div-___textareaId___" class="sortable-code">
            <p>Construct solution here</p>
            <ul id="CR-parsons-target-ul-___textareaId___" class="output"></ul>
        </div>

        <div style="clear:both;"></div>
    </div>
</body>

</html>