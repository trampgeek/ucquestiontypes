<!--
Code for use within the CodeRunner HTML UI to implement a Parsons
Problem question type.

Much of this code was original derived from the jsparson project by Ihantola
and Karavirta, though it has now mostly been rewritten to work within the
CodeRunner question type framework and to avoid use of jQuery, which was
fundamental to the jsparson implementation. The css is largely unchanged,
however.

-- Richard Lobb, 2021, 2025.

-->

<style>
    .CR-parsons-authoring {
        display: none;
    }

    .CR-parsons-error {
        display: none;
        background-color: yellow;
    }

    .sortable-code {
        position: static;
        padding-left: 0px;
        margin-left: 2%;
        float: left;
        width: 94%;
        max-width: {{ code_width }};
    }

    .sortable-code ul {
        font-size: 90%;
        font-family: monospace;
        list-style: none;
        background-color: #cbcff7;
        padding-bottom: 26px;
        padding-left: 0;
        margin-left: 0;
        border: 1px solid #efefff;
    }

    .sortable-code ul:empty {
        padding-bottom: 30px;
    }

    .sortable-code li,
    .sortable-code li:before,
    .sortable-code li:after {
        box-sizing: content-box;
    }

    ul.output {
        background-color: #FFA;
    }

    [draggable="true"] {
        cursor: move;
        user-select: none;
    }

    .sortable-code.drag-over {
        border-color: #000;
    }

    .sortable-code li {
        border-radius: 10px;
        background-color: white;
        border: 1px solid lightgray;
        padding: 4px 8px;
        margin-top: 4px;
        white-space: nowrap;
        overflow: hidden;
        cursor: move;
    }

    .sortable-code li:hover {
        overflow: visible;
    }

    .dragging {
        opacity: 0.5;
    }

    .insertion-marker {
        height: 35px;
        background-color: inherit;
        border: 1px dashed rgb(185, 34, 34);
        margin: 5px 0;
        pointer-events: none;
    }

    .dragging-ghost {
        background: white;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        z-index: 1000;
        width: 100%;
        max-width: 300px;
    }
</style>

<script>
    require([], function () {
        'use strict';

        const CONSTANTS = {
            MAX_INDENT: 7,
            X_INDENT: 35,
            TRIM_REGEXP: /^\s*(.*?)\s*$/,
        };

        class CodeLine {
            static nextId = 0;

            constructor(codestring, widget, allowIndent) {
                this.code = this.parseCode(codestring);
                this.indent = allowIndent ? this.calculateIndent(codestring) : 0;
                this.id = `${widget.id_prefix}codeline${CodeLine.nextId++}`;
            }

            parseCode(codestring) {
                if (!codestring) return '';
                return codestring
                    .replace(/#distractor\s*$/, '')
                    .replace(CONSTANTS.TRIM_REGEXP, '$1')
                    .replace(/\\n/g, '\n');
            }

            calculateIndent(codestring) {
                const spaces = codestring.length - codestring.replace(/^\s+/, '').length;
                return Math.min(Math.floor(spaces / 4), CONSTANTS.MAX_INDENT);
            }

            toHTML(xIndent) {
                const indent = this.indent ? `margin-left: ${xIndent * this.indent}px` : '';
                return `<li id="${this.id}" class="ace-static-highlight lang-py" style="${indent}">${this.code}</li>`;
            }
        }

        class DragDropManager {
            constructor(sourceElement, targetElement, parsonsWidget) {
                this.sourceElement = sourceElement;
                this.targetElement = targetElement;
                this.parsonsWidget = parsonsWidget;
                this.draggedElement = null;
                this.dragOffsetX = 0;
                this.dragOffsetY = 0;
                this.clone = null;
                this.indentOnly = false;
                this.setupEventListeners();
            }

            setupEventListeners() {
                [this.sourceElement, this.targetElement].forEach(element => {
                    element.addEventListener('dragstart', this.handleDragStart.bind(this));
                    element.addEventListener('dragover', this.handleDragOver.bind(this));
                    element.addEventListener('dragleave', this.handleDragLeave.bind(this));
                    element.addEventListener('drop', this.handleDrop.bind(this));
                    element.addEventListener('dragend', this.handleDragEnd.bind(this));
                    element.addEventListener('touchstart', this.handleTouchStart.bind(this));
                });

                document.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                document.addEventListener('touchend', this.handleTouchEnd.bind(this));
            }

            handleDragStart(e) {
                this.draggedElement = e.target; // The element being dragged
                const element = e.currentTarget;
                const rect = element.getBoundingClientRect();
                const leftMargin = parseFloat(getComputedStyle(this.draggedElement).marginLeft);
                this.dragOffsetX = e.clientX - rect.left - leftMargin;
                this.draggedElement.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                this.indentOnly = false;
            }

            handleDragOver(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                
                const element = e.currentTarget;
                const rect = element.getBoundingClientRect();
                const [indentOnly, insertBefore] = this.findInsertionPoint(
                    [...element.children], // Candidate items in the targets UL list.
                    e.clientY,
                    rect
                );
                this.indentOnly = indentOnly;

                let marker = element.querySelector('.insertion-marker');
                if (indentOnly && marker) {
                    marker.remove();
                } else if (!indentOnly) {
                    this.updateInsertionMarker(element, marker, insertBefore, this.calculateIndent(e, rect));
                }
            }

            handleDragLeave(e) {
                // Remove the marker unless this is a false dragleave resulting from
                // moving over a child element.
                const element = e.currentTarget
                if (!element.contains(e.relatedTarget)) {  // If not dragging over a child element...
                    const marker = element.querySelector('.insertion-marker');
                    if (marker) {
                        marker.remove();
                    }
                }
            }

            handleDragEnd(e) {
                this.draggedElement.classList.remove('dragging');
                this.draggedElement = null;
                if (this.clone) {
                    this.clone.remove();
                    this.clone = null;
                }
                const marker = e.currentTarget.querySelector('.insertion-marker');
                if (marker) {
                    marker.remove();
                }
            }

            handleDrop(e) {
                e.preventDefault();
                const element = e.currentTarget;
                const rect = element.getBoundingClientRect();
                this.setDraggedElementIndent(e, rect);
                if (!this.indentOnly) {
                    const marker = element.querySelector('.insertion-marker');
                    if (marker) {
                        element.insertBefore(this.draggedElement, marker);
                    } else {
                        element.appendChild(this.draggedElement);
                    }
                }
                this.parsonsWidget.syncToTextareas();
            }

            handleTouchStart(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const element = e.currentTarget;
                let target = touch.target;
                // Find the draggable element
                while (target && target !== element && !target.draggable) {
                    target = target.parentElement;
                }
                if (target && target.draggable) {
                    this.draggedElement = target;
                    const rect = this.draggedElement.getBoundingClientRect();
                    const leftMargin = parseFloat(getComputedStyle(this.draggedElement).marginLeft);
                    this.dragOffsetX = touch.clientX - rect.left;
                    this.dragOffsetY = touch.clientY - rect.top;
                    this.draggedElement.classList.add('dragging');

                    // Create a clone for visual feedback, with styles copied from the original element.
                    this.clone = this.draggedElement.cloneNode(true);
                    this.clone.id = 'drag-clone';
                    const computedStyles = window.getComputedStyle(this.draggedElement);
                    for (let style of computedStyles) {
                        this.clone.style[style] = computedStyles.getPropertyValue(style);
                    }

                    // Tweak the ones we need to change.
                    this.clone.style.position = 'fixed';
                    this.clone.style.left = `${rect.left}px`;
                    this.clone.style.top = `${touch.clientY - this.dragOffsetY}px`;
                    this.clone.style.opacity = '0.6';
                    this.clone.style.pointerEvents = 'none';
                    document.body.appendChild(this.clone);
                }
            }

            handleTouchMove(e) {
                if (!this.draggedElement || !this.clone) return;
                e.preventDefault();
                const touch = e.touches[0];
                let marker = null;

                // Update clone position.
                this.clone.style.left = `${touch.clientX - this.dragOffsetX}px`;
                this.clone.style.top = `${touch.clientY - this.dragOffsetY}px`;

                // Determine current drop zone.
                const currentElement = this.findDropZone(touch);
                if (!currentElement) {
                    [this.sourceElement, this.targetElement].forEach(el => {
                        marker = el.querySelector('.insertion-marker');
                        if (marker) marker.remove();
                    });
                    return;
                }

                // Calculate insertion point and indent
                const rect = currentElement.getBoundingClientRect();
                const items = [...currentElement.children].filter(child => child !== this.clone);

                const [indentOnly, insertBefore] = this.findInsertionPoint(
                    items, // Candidate items in the targets UL list.
                    touch.clientY,
                    rect
                );

                this.indentOnly = indentOnly;

                marker = e.currentTarget.querySelector('.insertion-marker');
                if (indentOnly && marker) {
                    marker.remove();
                } else if (!indentOnly) {
                    this.updateInsertionMarker(element, marker, insertBefore, this.calculateIndent(touch, rect));
                }
            }

            handleTouchEnd(e) {
                if (!this.draggedElement) return;

                e.preventDefault();
                this.draggedElement.classList.remove('dragging');
                this.draggedElement = null;
                if (this.clone) {
                    this.clone.remove();
                    this.clone = null;
                }
                
                const touch = e.changedTouches[0];
                const currentElement = this.findDropZone(touch);

                if (currentElement) {
                    const rect = currentElement.getBoundingClientRect();
                    this.setDraggedElementIndent(touch, rect);
                    if (!this.indentOnly) {
                        const marker = currentElement.querySelector('.insertion-marker');
                        if (marker) {
                            currentElement.insertBefore(this.draggedElement, marker);
                        } else {
                            currentElement.appendChild(this.draggedElement);
                        }
                    }
                    this.parsonsWidget.syncToTextareas();
                }

                [this.sourceElement, this.targetElement].forEach(el => {
                    const marker = el.querySelector('.insertion-marker');
                    if (marker) {
                        marker.remove();
                    }
                });

                this.draggedElement = null;
                this.indentOnly = false;
                this.dragOffsetX = 0;
            }


            // Find the point at which to insert the dragged element in the given list
            // of the list items, based on the y-coordinate of the mouse/touch and the bounding
            // rectangle of the list.
            // @return [indentOnly, insertBefore] where indentOnly is true if no insertion
            // is required, only indentation. insertBefore is the list item before which the
            // dragged element should be inserted, null if it should be appended to the end.
            findInsertionPoint(items, y, rect) {
                let insertBefore = null;
                let indentOnly = false;
                for (let i = 0; i < items.length; i++) {
                    let item = items[i];
                    if (item.classList.contains('insertion-marker')) {
                        continue;
                    }

                    const box = item.getBoundingClientRect();
                    // Check if item is the dragged item and mouse is somwwhere between the centre of
                    // the item below and the centre of the item above. In that case we only want to indent.
                    if (item.classList.contains('dragging')) {
                        let lowBound = box.top;
                        let highBound = box.bottom;
                        if (i < items.length - 1) {
                            let nextBox = items[i + 1].getBoundingClientRect();
                            highBound = (nextBox.bottom + nextBox.top) / 2;
                        }
                        if (i > 0) {
                            let prevBox = items[i - 1].getBoundingClientRect();
                            lowBound = (prevBox.top + prevBox.bottom) / 2;
                        }
                        if (y > lowBound && y < highBound) {
                            indentOnly = true;
                            break;
                        }
                    }

                    if (y < box.top + box.height / 2) {
                        insertBefore = item;
                        break;
                    }
                }
                return [indentOnly, insertBefore];
            }

            // Find and return whichever of the sourceElement or targetElement the touch is over.
            findDropZone(touch) {
                let currentElement = null;
                const elements = [this.sourceElement, this.targetElement];
                for (const el of elements) {
                    const rect = el.getBoundingClientRect();
                    if (touch.clientX >= rect.left && touch.clientX <= rect.right &&
                        touch.clientY >= rect.top && touch.clientY <= rect.bottom) {
                        currentElement = el;
                        break;
                    }
                }
                return currentElement;
            }

            calculateIndent(e, rect) {
                if (e.currentTarget === this.sourceElement) {
                    return 0;
                }
                const leftx = e.clientX - this.dragOffsetX;
                return Math.max(0, Math.round((leftx - rect.left) / CONSTANTS.X_INDENT));
            }

            setDraggedElementIndent(e, rect) {
                this.draggedElement.style.marginLeft = this.calculateIndent(e, rect) * CONSTANTS.X_INDENT + 'px';
            }

            updateInsertionMarker(element, marker, insertBefore, indent) {
                if (!marker) {
                    marker = document.createElement('div');
                    marker.className = 'insertion-marker';
                }

                marker.style.marginLeft = `${CONSTANTS.X_INDENT * indent}px`;
                
                if (insertBefore) {
                    element.insertBefore(marker, insertBefore);
                } else {
                    element.appendChild(marker);
                }
            }
        }

        class ParsonsWidget {
            constructor(sourceUlId, targetUlId, sourceTaId, targetTaId) {
                this.config = {
                    sourceUlId,
                    targetUlId,
                    sourceTaId,
                    targetTaId,
                    id_prefix: `${targetUlId}codeline`
                };
                
                this.dragDropManager = new DragDropManager(
                    document.getElementById(sourceUlId),
                    document.getElementById(targetUlId),
                    this
                );
                
                this.loadFromTextareas();
                this.setupMutationObservers();
                this.makeItemsDraggable();
                const sourceTextArea = document.getElementById(sourceTaId);
                const parentQuestionDiv = sourceTextArea.closest('div.que');
            }

            loadFromTextareas() {
                ['source', 'target'].forEach(type => {
                    const taId = this.config[`${type}TaId`];
                    const ulId = this.config[`${type}UlId`];
                    const textarea = document.getElementById(taId);
                    const lines = this.parseCode(textarea.value.split('\n'), true);
                    const html = this.codeLinesToHTML(lines);
                    document.getElementById(ulId).innerHTML = html.join('\n');
                });
            }

            parseCode(lines, allowIndent) {
                return lines
                    .map(line => new CodeLine(line, this, allowIndent))
                    .filter(line => line.code.trim().length > 0);
            }

            codeLinesToHTML(lines) {
                return lines.map(line => line.toHTML(CONSTANTS.X_INDENT));
            }

            setupMutationObservers() {
                const observer = new MutationObserver(() => this.syncToTextareas());
                observer.observe(document.getElementById(`CR-parsons-sortables-___textareaId___`), {
                    childList: true,
                    attributes: true,
                    subtree: true,
                    attributeFilter: ['style']
                });
            }

            syncToTextareas() {
                ['source', 'target'].forEach(type => {
                    const list = document.getElementById(this.config[`${type}UlId`]);
                    const textarea = document.getElementById(this.config[`${type}TaId`]);
                    textarea.value = this.getCodeString(list);
                });
            }

            getCodeString(ulElement) {
                return Array.from(ulElement.children)
                    .map(item => {
                        const indent = parseInt(item.style.marginLeft || 0, 10) / CONSTANTS.X_INDENT;
                        return ' '.repeat(indent * 4) + item.textContent.trim();
                    })
                    .join('\n');
            }

            makeItemsDraggable() {
                [this.config.sourceUlId, this.config.targetUlId].forEach(id => {
                    const element = document.getElementById(id);
                    Array.from(element.children).forEach(item => {
                        item.draggable = true;
                    });
                });
            }
        }

        // Check that the target (aka answer) textarea contains only lines
        // that are present in the source textarea. Turns on the error
        // message (yellow highlighted) if not.
        // Also rebuilds the source field for the answer to contain all unused
        // lines in the target.
        // Works only in the question authoring context.
        function checkAnswer() {
            const sourceTa = document.getElementById('CR-parsons-source-ta-id_answerpreload');
            const targetTa = document.getElementById('CR-parsons-target-ta-id_answer');
            const errorPara = document.getElementById('CR-parsons-answer-error-id_answer');
            const sourceLines = sourceTa.value.trim().split("\n");
            const answerLines = targetTa.value.trim().split("\n");

            errorPara.style.display = 'none';
            let used = [];

            for (const answerLine of answerLines) {
                if (!sourceLines.some((srcLine, index) => {
                    if (used.includes(index)) return false;
                    if (srcLine.trim() === answerLine.trim()) {
                        used.push(index);
                        return true;
                    }
                    return false;
                })) {
                    errorPara.style.display = 'inline';
                }
            }

            const answerUnused = document.getElementById('CR-parsons-source-ta-id_answer');
            answerUnused.value = sourceLines
                .filter((_, index) => !used.includes(index))
                .join('\n');
        }


        function doAceHighlighting(parentQuestionDiv) {
            if (window.ace) {
                const highlight = window.ace.require("ace/ext/static_highlight");
                const codeElements = parentQuestionDiv.getElementsByClassName('ace-static-highlight');

                for (let i = 0; i < codeElements.length; i++) {
                    let element = codeElements[i];

                    const mode = "ace/mode/python";
                    if (element.hasAttribute("lang")) {
                        mode = "ace/mode/" + element.getAttribute("lang");
                    }

                    highlight(element, {
                        mode: mode,
                        showGutter: false,
                    }, function (highlighted) {
                        const fontSize = "14px";
                        if (element.hasAttribute("font-size")) {
                            fontSize = element.getAttribute("font-size");
                        }
                        // The class ace_static_highlight (with underscores)
                        // is not to be confused with ace-static-highlight.
                        // The latter is generated by the Ace highlighter.
                        element.getElementsByClassName('ace_static_highlight')[0].style['font-size'] = fontSize;
                    });
                }
            }
        }



        function setupAuthoring(sourceTextArea, targetTextArea) {
            document.querySelectorAll('.sortable-code').forEach(el => el.style.display = 'none');

            const isPreload = sourceTextArea.closest('.preloadanswer') !== null;
            if (isPreload) {
                document.getElementById("CR-parsons-preload-authoring-div-___textareaId___").style.display = "block";
                targetTextArea.value = '';

                document.getElementById("CR-parsons-shuffle-___textareaId___").onclick = function() {
                    const lines = sourceTextArea.value.trim().split('\n');
                    shuffleArray(lines);
                    sourceTextArea.value = lines.join('\n');
                };

                document.getElementById("CR-unindent-___textareaId___").onclick = function() {
                    const lines = sourceTextArea.value.trim().split('\n').map(l => l.trim());
                    sourceTextArea.value = lines.join('\n');
                };

                sourceTextArea.addEventListener('input', checkAnswer);
            } else {
                document.getElementById("CR-parsons-answer-authoring-div-___textareaId___").style.display = "block";
                targetTextArea.addEventListener('input', checkAnswer);
            }
            checkAnswer();
        }

        function startUp() {
            const sourceUlId = 'CR-parsons-source-ul-___textareaId___';
            const targetUlId = 'CR-parsons-target-ul-___textareaId___';
            const sourceTaId = 'CR-parsons-source-ta-___textareaId___';
            const targetTaId = 'CR-parsons-target-ta-___textareaId___';
            const sourceTextArea = document.getElementById(sourceTaId);
            const targetTextArea = document.getElementById(targetTaId);
            const parentQuestionDiv = sourceTextArea.closest('div.que');
            const isQuestion = parentQuestionDiv !== null;

            const parson = new ParsonsWidget(sourceUlId, targetUlId, sourceTaId, targetTaId);

            if (isQuestion) {
                doAceHighlighting(parentQuestionDiv);
            } else {    
                setupAuthoring(sourceTextArea, targetTextArea);
            }

            
        }

        startUp();
    });
</script>

<div id="CR-parsons-answer-authoring-div-___textareaId___" class="CR-parsons-authoring">
    <h4>Answer:</h4>
    <p id="CR-parsons-answer-error-___textareaId___" class="CR-parsons-error">
        The answer contains line(s) not available in the preload!
    </p>
    <textarea id="CR-parsons-target-ta-___textareaId___" name='CR-parsons-target' 
              class="coderunner-ui-element" rows="8"></textarea>
</div>

<div id="CR-parsons-preload-authoring-div-___textareaId___" class="CR-parsons-authoring">
    <h4>Drag-able code lines:</h4>
    <textarea id="CR-parsons-source-ta-___textareaId___" name='CR-parsons-source'
              class="coderunner-ui-element CR-parsons-answer-edit" rows="8"></textarea>
    <div id="CR-parsons-button-div-___textareaId___">
        <button id="CR-parsons-shuffle-___textareaId___" type="button">Shuffle</button>
        <button id="CR-unindent-___textareaId___" type="button">Remove indentation</button>
    </div>
</div>

<div id="CR-parsons-sortables-___textareaId___">
    <div id="CR-parsons-source-div-___textareaId___" class="sortable-code">
        <p>Drag from here</p>
        <ul id="CR-parsons-source-ul-___textareaId___"></ul>
        </div>

        <div id="CR-parsons-target-div-___textareaId___" class="sortable-code">
            <p>Construct solution here</p>
            <ul id="CR-parsons-target-ul-___textareaId___" class="output"></ul>
        </div>

        <div style="clear:both;"></div>
    </div>
</body>

</html>